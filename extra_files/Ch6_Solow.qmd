---
title: "Chapter 6"
subtitle: "Macro"
author: ""
format:
  html:
    self-contained: true
    page-layout: full
    title-block-banner: true
    toc: true
    toc-depth: 3
    toc-location: body
    number-sections: false
    html-math-method: katex
    code-fold: true
    code-summary: "Show the code"
    code-overflow: wrap
    code-copy: hover
    code-tools:
        source: false
        toggle: true
        caption: See code
execute: 
  warning: false
    
---

# 06CH 1 Solow


```{python}
# model 0.6
# adding rest of calculations

import pandas as pd

parameters = {
    'Simulation Period (yrs)': 50,
    's': 0.2,
    'delta': 0.15,
    'n': 0.02,
    'z': 0.02,
    'l': 0.1,
    'k_star_initial': None,  # Initialize with None
    'A': 1.0,  # Initial value for A
    'L': 1.0,  # Initial value for L
}

# Extract values from the parameters to calculate for k_star_initial
s = parameters['s']
delta = parameters['delta']
n = parameters['n']
z = parameters['z']
l = parameters['l']
A = parameters['A']
L = parameters['L']

# Calculate k_star_initial and update parameters
k_star_initial = ((s / (delta + n + z * l)) ** 1.5) * (1 - l)
parameters['k_star_initial'] = k_star_initial


quantitative_experiments = {
    'delta': [
        {'new_value': .1, 'time_period': 22, 'length': 50}
    ],
    's': [
        {'new_value': 0.025, 'time_period': 22, 'length': 50}
    ],
    'z': [
        {'new_value': 0.04, 'time_period': 20, 'length': 130}
    ]
} # to add just use the same format & change parameter


# Initialize the DataFrame
num_periods = parameters['Simulation Period (yrs)'] + 1
df = pd.DataFrame({
    'Period': range(num_periods),
    's': [parameters['s']] * num_periods,
    'delta': [parameters['delta']] * num_periods,
    'n': [parameters['n']] * num_periods,
    'z': [parameters['z']] * num_periods,
    'l': [parameters['l']] * num_periods,
    'Delta k': [0.0] * num_periods,
    'k*': [parameters['k_star_initial']] * num_periods,
    'A': [parameters['A']] * num_periods,
    'L': [parameters['L']] * num_periods,
    'K': [0.0] * num_periods,  # Will be calculated
    'Y': [0.0] * num_periods,  # Will be calculated
})

# Apply Quantitative Experiments
for param, changes_list in quantitative_experiments.items():
    for changes in changes_list:
        for period in range(changes['time_period'], changes['time_period'] + changes['length']):
            if period < num_periods:
                df.at[period, param] = changes['new_value']

# calculate delta k
def calculate_Delta_k(df, row_index):
    if row_index == 0:
        return 0.0
    else:
        delta_k = df.at[row_index, 's'] * ((1 - df.at[row_index, 'l']) ** (2/3)) * (df.at[row_index - 1, 'k*'] ** (1/3)) - \
                  (df.at[row_index, 'z'] * df.at[row_index, 'l'] + df.at[row_index, 'n'] + df.at[row_index, 'delta']) * df.at[row_index - 1, 'k*']
        return delta_k

# calculate k* (def python functions can have *)
def calculate_k_star(df, row_index, k_star_initial):
    if row_index == 0:
        k_star_value = k_star_initial
    else:
        k_star_value = (df.at[row_index - 1, 'k*'] + df.at[row_index, 'Delta k'])
    return k_star_value

# Calculating 'A'
def calculate_A(df, row_index, initial_A):
    if row_index == 0:
        return initial_A
    else:
        A = df.at[row_index - 1, 'A'] * (1 + df.at[row_index, 'z'] * df.at[row_index, 'l'])
        return A

# Calculation 'L'
def calculate_L(df, row_index, initial_L):
    if row_index == 0:
        return initial_L
    else:
        L = df.at[row_index - 1, 'L'] * (1 + df.at[row_index, 'n'])
        return L

# calculating 'K'
def calculate_K(df, row_index):
    K = df.at[row_index, 'k*'] * df.at[row_index, 'L'] * df.at[row_index, 'A']
    return K

# calculating 'Y'
def calculate_Y(df, row_index):
    return (1 - df.at[row_index, 'l']) ** (2/3) * df.at[row_index, 'K'] ** (1/3) * \
           (df.at[row_index, 'A'] * df.at[row_index, 'L']) ** (2/3)

# Loop def functions through DataFrame
for i in range(len(df)):
    df.at[i, 'Delta k'] = calculate_Delta_k(df, i)
    df.at[i, 'k*'] = calculate_k_star(df, i, k_star_initial)
    df.at[i, 'A'] = calculate_A(df, i, parameters['A'])
    df.at[i, 'L'] = calculate_L(df, i, parameters['L'])
    df.at[i, 'K'] = calculate_K(df, i)
    df.at[i, 'Y'] = calculate_Y(df, i)

df

```



# 05CH 1 Solow simulations
I will use 06CH solow model to make this one since it is similar

__Model 1__
```{python}
# model 0.6
# adding rest of calculations

import pandas as pd

parameters = {
    'Simulation Period (yrs)': 15,
    's': 0.2,
    'delta': 0.15,
    'alpha': 1/3,
    'A': 1, 
    'L': 1, 
    'k_star_initial': None,  # Initialize with None
}

# Extract values from the parameters to calculate for k_star_initial
s = parameters['s']
delta = parameters['delta']
alpha = parameters['alpha']
A = parameters['A']
L = parameters['L']

# Calculate k_star_initial and update parameters
k_star_initial = (s * A / delta) ** (1/(1-alpha))
parameters['k_star_initial'] = k_star_initial


quantitative_experiments = {
    's': [
        {'new_value': -5, 'time_period': 5, 'length': 6},
        {'new_value': 2, 'time_period': 11, 'length': 3}
    ],
    'A': [
        {'new_value': 1, 'time_period': 6, 'length': 6}
    ]
} # to add just use the same format & change parameter


# Initialize the DataFrame
num_periods = parameters['Simulation Period (yrs)'] + 1
df = pd.DataFrame({
    'Period': range(num_periods),
    's': [parameters['s']] * num_periods,
    'delta': [parameters['delta']] * num_periods,
    'alpha': [parameters['alpha']] * num_periods,
    'A': [parameters['A']] * num_periods,
    'L': [parameters['L']] * num_periods,
    'Delta k': [0.0] * num_periods, # will be calculated
    'k*': [parameters['k_star_initial']] * num_periods,
    'C': [0.0] * num_periods, # will be calculated
    'K': [0.0] * num_periods, # will be calculated
    'Y': [0.0] * num_periods, # will be calculated 
})

# Apply Quantitative Experiments
for param, changes_list in quantitative_experiments.items():
    for changes in changes_list:
        for period in range(changes['time_period'], changes['time_period'] + changes['length']):
            if period < num_periods:
                df.at[period, param] = changes['new_value']

# calculate delta k
def calculate_Delta_k(df, row_index):
    if row_index == 0:
        return 0.0
    else:
        delta_k = df.at[row_index, 's'] * ((df.at[row_index, 'A'] * df.at[row_index - 1, 'k*']) ** (df.at[row_index, 'alpha'])) - df.at[row_index, 'delta'] * df.at[row_index - 1, 'k*']
        return delta_k # updated for 05ch

# calculate k* (def python functions can have *)
def calculate_k_star(df, row_index, k_star_initial):
    if row_index == 0:
        k_star_value = k_star_initial
    else:
        k_star_value = (df.at[row_index - 1, 'k*'] + df.at[row_index, 'Delta k'])
    return k_star_value # def doesn't change from 05 to 06

# Calculating 'C'
def calculate_C(df, row_index):
    C = (1 - df.at[row_index, 's']) * df.at[row_index, 'A'] * df.at[row_index, 'k*'] ** df.at[row_index, 'alpha']
    return C

# calculating 'K'
def calculate_K(df, row_index):
    K = df.at[row_index, 'k*'] * df.at[row_index, 'L']
    return K

# calculating 'Y' K needs to be calculated first for Y to work.
def calculate_Y(df, row_index):
    Y =  df.at[row_index, 'A'] * ((df.at[row_index, 'K'] ** df.at[row_index, 'alpha']) * (df.at[row_index, 'L'] ** (1 - df.at[row_index, 'alpha'])))
    return Y

# Loop def functions through DataFrame
for i in range(len(df)):
    df.at[i, 'Delta k'] = calculate_Delta_k(df, i)
    df.at[i, 'k*'] = calculate_k_star(df, i, k_star_initial)
    df.at[i, 'C'] = calculate_C(df, i)
    df.at[i, 'K'] = calculate_K(df, i)
    df.at[i, 'Y'] = calculate_Y(df, i)

df

```





# Python Solow model

python solow model project

__model 1__ does the same thing as the project, but does not have the stop once epsilon is met nor does it print the results. 
this model is struture after the latter models for easy connection

```{python}
# first model of trying to adapt latter structure code.
# but this one needs a scenario where it stops when steady state is reach.


# Define exogenous variables and parameters values.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

parameters = {
    'Simulation Period (yrs)': 55,
    'K_0': 100.0, # K_0 is 'capital' & eventually capital_steady_state
    'L': 1000.0, # needed to calculate output
    'A': 1.0,
    'd': 0.15, # depreciation
    's': 0.2,
    'alpha': 1/3,
    'epsilon': 10
}

quantitative_experiments = {
    's': [
        {'new_value': 0.2, 'time_period': 10, 'length': 100}
    ]
} # to add just use the same format & change parameter

# Initialize the DataFrame
num_periods = parameters['Simulation Period (yrs)'] + 1
df = pd.DataFrame({
    'Period': range(num_periods),
    'Capital': [0.0] * num_periods, # K_0 & eventually capital_steady_state (K*), but K* is in its own column (K_star)
    'Output': [0.0] * num_periods, # Y & eventually output_steady_state(Y*), but Y* is its own column
    'Investment': [0.0] * num_periods, # will be calculated
    'Depreciation': [0.0] * num_periods, # will be calculated
    'Change in Capital': [0.0] * num_periods, # will be calculated
    'Epsilon': [0.0] * num_periods, # will be calculated 
    's': [parameters['s']] * num_periods,
    'd': [parameters['d']] * num_periods,
    'A': [parameters['A']] * num_periods,
    'alpha': [parameters['alpha']] * num_periods,
    'L': [parameters['L']] * num_periods,
    'K_star': [0.0] * num_periods, # will be calculated
    'Y_star': [0.0] * num_periods
})

# Apply Quantitative Experiments
for param, changes_list in quantitative_experiments.items():
    for changes in changes_list:
        for period in range(changes['time_period'], changes['time_period'] + changes['length']):
            if period < num_periods:
                df.at[period, param] = changes['new_value']



def production_function(df, row_index, A, K_0, L, alpha): # 'output'
    if row_index == 0:
      Output = A * K_0 ** alpha * L ** (1 - alpha)
    else:
      Output =  df.at[row_index, 'A'] * df.at[row_index, 'Capital'] ** df.at[row_index, 'alpha'] * df.at[row_index, 'L'] ** (1 - df.at[row_index, 'alpha']) # formula 
    return Output


def calc_K_star(df, row_index, L, s, d, A, alpha): # capital_steady_state
    '''This is to calculat capital_steady_state and is use to find epsilon by doing: 'Capital' - capital_steady_state. Which capital steady state is K_star
    now the question if this calculation is calculated only once or at every row. I'm assuming is every row, but research shows it is only once
    Ok i may have to remove this from the df, or keep it and add a constant K_star.
    It is calculated every period due to the quantitative experiment where s can change so that changes capital steady state. '''
    if row_index == 0:
      K_star = L * ((s * A)/d) ** (1.0/(1.0 - alpha))
    else: 
      A = df.at[row_index, 'A']
      s = df.at[row_index, 's']
      L = df.at[row_index, 'L']
      d = df.at[row_index, 'd']
      alpha = df.at[row_index, 'alpha']
      K_star =  L * ((s * A)/d) ** (1.0/(1.0 - alpha)) # formula
    return K_star

def calc_Y_star(df, row_index, L, s, d, A, alpha):
    if row_index == 0:
      Y_star = A ** (1.0/(1.0 - alpha)) * (s/d) ** (alpha/ (1.0 - alpha)) * L
    else:
      A = df.at[row_index, 'A']
      s = df.at[row_index, 's']
      L = df.at[row_index, 'L']
      d = df.at[row_index, 'd']
      alpha = df.at[row_index, 'alpha']
      Y_star = A ** (1.0/(1.0 - alpha)) * (s/d) ** (alpha/ (1.0 - alpha)) * L # formula
    return Y_star

def calc_Capital(df, row_index, K_0): # capital initial, we get epsilon by getting this K_0 or 'Capital'minus capital_steay_state
    if row_index == 0:
        return K_0
    else:
      Capital = df.at[row_index - 1, 'Capital'] + df.at[row_index - 1, 'Change in Capital']
    return  Capital

'''
def calc_output(df, row_index): # same as production function but due to the def fomrulas order i'll leave both for now. 
    A = df.at[row_index, 'A']
    capital = df.at[row_index, 'Capital']
    L = df.at[row_index, 'L']
    alpha = df.at[row_index, 'alpha']
    Output = A * capital ** alpha * L ** (1 - alpha) # 'Output'
    return Output
'''

def calc_Investment(df, row_index):
    s = df.at[row_index, 's']
    Output = df.at[row_index, 'Output']
    Investment = s * Output
    return Investment

def calc_Depreciation(df, row_index):
    d = df.at[row_index, 'd']
    Capital = df.at[row_index, 'Capital']
    Depreciation = d * Capital
    return Depreciation

def calc_change_in_Capital(df, row_index):
    investment = df.at[row_index, 'Investment']
    Depreciation = df.at[row_index, 'Depreciation']
    Change_in_Capital = investment - Depreciation
    return Change_in_Capital

def calc_epsilon_value(df, row_index):
    capital = df.at[row_index, 'Capital']
    capital_steady_state = df.at[row_index, 'K_star']
    Epsilon = abs(capital - capital_steady_state)
    return Epsilon


# Loop def functions through DataFrame
for i in range(len(df)):

    Capital = calc_Capital(df, i, parameters['K_0'])
    df.at[i, 'Capital'] = Capital

    Output = production_function(df, i, parameters['A'], parameters['K_0'], parameters['L'], parameters['alpha']) # Output done using first formula & not second
    df.at[i, 'Output'] = Output 


    K_star = calc_K_star(df, i, parameters['A'], parameters['s'], parameters['L'], parameters['alpha'], parameters['d'])
    df.at[i, 'K_star'] = K_star

    Y_star = calc_Y_star(df, i, parameters['A'], parameters['s'], parameters['L'], parameters['alpha'], parameters['d'])
    df.at[i, 'Y_star'] = Y_star

    # Output = production_function(df, i)
    # df.at[i, 'Output'] = Output

    Investment = calc_Investment(df, i)
    df.at[i, 'Investment'] = Investment

    Depreciation = calc_Depreciation(df, i)
    df.at[i, 'Depreciation'] = Depreciation

    Change_in_Capital = calc_change_in_Capital(df, i)
    df.at[i, 'Change in Capital'] = Change_in_Capital

    Epsilon = calc_epsilon_value(df, i)
    df.at[i, 'Epsilon'] = Epsilon


df

```


__model 2__
this model does python solow model project question 1 C & it is structure after my main codes.

the code for the condition to stop once epsilon is met can just be copy into other models as only the end changes and no other part of the code does.

Once thing to notice is this code actually change the for i calculations part at the end, which just made it shorter, but this can cause conflicts with def with two functions, specially chapter 13 where they have to be calculated in order.


```{python}
# this model does python solow model project question 1 C & it is structure after my main codes.

# the code for the condition to stop once epsilon is met can just be copy into other models as only the end changes and no other part of the code does.

# Once thing to notice is this code actually change the for i calculations part at the end, which just made it shorter, but this can cause conflicts with def with two functions, specially chapter 13 where they have to be calculated in order.

# Define exogenous variables and parameters values.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

parameters = {
    'Simulation Period (yrs)': 55,
    'K_0': 100.0, # K_0 is 'capital' & eventually capital_steady_state
    'L': 1000.0, # needed to calculate output
    'A': 1.0,
    'd': 0.15, # depreciation
    's': 0.2,
    'alpha': 1/3,
    'epsilon': 10
}

quantitative_experiments = {
    's': [
        {'new_value': 0.2, 'time_period': 10, 'length': 100}
    ]
} # to add just use the same format & change parameter

# Initialize the DataFrame
num_periods = parameters['Simulation Period (yrs)'] + 1
df = pd.DataFrame({
    'Period': range(num_periods),
    'Capital': [0.0] * num_periods, # K_0 & eventually capital_steady_state (K*), but K* is in its own column (K_star)
    'Output': [0.0] * num_periods, # Y & eventually output_steady_state(Y*), but Y* is its own column
    'Investment': [0.0] * num_periods, # will be calculated
    'Depreciation': [0.0] * num_periods, # will be calculated
    'Change in Capital': [0.0] * num_periods, # will be calculated
    'Epsilon': [0.0] * num_periods, # will be calculated 
    's': [parameters['s']] * num_periods,
    'd': [parameters['d']] * num_periods,
    'A': [parameters['A']] * num_periods,
    'alpha': [parameters['alpha']] * num_periods,
    'L': [parameters['L']] * num_periods,
    'K_star': [0.0] * num_periods, # will be calculated
    'Y_star': [0.0] * num_periods
})

# Apply Quantitative Experiments
for param, changes_list in quantitative_experiments.items():
    for changes in changes_list:
        for period in range(changes['time_period'], changes['time_period'] + changes['length']):
            if period < num_periods:
                df.at[period, param] = changes['new_value']



def production_function(df, row_index, A, K_0, L, alpha): # 'output'
    if row_index == 0:
      Output = A * K_0 ** alpha * L ** (1 - alpha)
    else:
      Output =  df.at[row_index, 'A'] * df.at[row_index, 'Capital'] ** df.at[row_index, 'alpha'] * df.at[row_index, 'L'] ** (1 - df.at[row_index, 'alpha']) # formula 
    return Output


def calc_K_star(df, row_index, L, s, d, A, alpha): # capital_steady_state
    '''This is to calculat capital_steady_state and is use to find epsilon by doing: 'Capital' - capital_steady_state. Which capital steady state is K_star
    now the question if this calculation is calculated only once or at every row. I'm assuming is every row, but research shows it is only once
    Ok i may have to remove this from the df, or keep it and add a constant K_star.
    It is calculated every period due to the quantitative experiment where s can change so that changes capital steady state. '''
    if row_index == 0:
      K_star = L * ((s * A)/d) ** (1.0/(1.0 - alpha))
    else: 
      A = df.at[row_index, 'A']
      s = df.at[row_index, 's']
      L = df.at[row_index, 'L']
      d = df.at[row_index, 'd']
      alpha = df.at[row_index, 'alpha']
      K_star =  L * ((s * A)/d) ** (1.0/(1.0 - alpha)) # formula
    return K_star

def calc_Y_star(df, row_index, L, s, d, A, alpha):
    if row_index == 0:
      Y_star = A ** (1.0/(1.0 - alpha)) * (s/d) ** (alpha/ (1.0 - alpha)) * L
    else:
      A = df.at[row_index, 'A']
      s = df.at[row_index, 's']
      L = df.at[row_index, 'L']
      d = df.at[row_index, 'd']
      alpha = df.at[row_index, 'alpha']
      Y_star = A ** (1.0/(1.0 - alpha)) * (s/d) ** (alpha/ (1.0 - alpha)) * L # formula
    return Y_star

def calc_Capital(df, row_index, K_0): # capital initial, we get epsilon by getting this K_0 or 'Capital'minus capital_steay_state
    if row_index == 0:
        return K_0
    else:
      Capital = df.at[row_index - 1, 'Capital'] + df.at[row_index - 1, 'Change in Capital']
    return  Capital


def calc_Investment(df, row_index):
    s = df.at[row_index, 's']
    Output = df.at[row_index, 'Output']
    Investment = s * Output
    return Investment

def calc_Depreciation(df, row_index):
    d = df.at[row_index, 'd']
    Capital = df.at[row_index, 'Capital']
    Depreciation = d * Capital
    return Depreciation

def calc_change_in_Capital(df, row_index):
    investment = df.at[row_index, 'Investment']
    Depreciation = df.at[row_index, 'Depreciation']
    Change_in_Capital = investment - Depreciation
    return Change_in_Capital

def calc_epsilon_value(df, row_index):
    capital = df.at[row_index, 'Capital']
    capital_steady_state = df.at[row_index, 'K_star']
    Epsilon = abs(capital - capital_steady_state)
    return Epsilon


# Loop def functions through DataFrame
for i in range(len(df)):
    # Existing calculations
    df.at[i, 'Capital'] = calc_Capital(df, i, parameters['K_0'])
    df.at[i, 'Output'] = production_function(df, i, parameters['A'], parameters['K_0'], parameters['L'], parameters['alpha'])
    df.at[i, 'K_star'] = calc_K_star(df, i, parameters['A'], parameters['s'], parameters['L'], parameters['alpha'], parameters['d'])
    df.at[i, 'Y_star'] = calc_Y_star(df, i, parameters['A'], parameters['s'], parameters['L'], parameters['alpha'], parameters['d'])
    df.at[i, 'Investment'] = calc_Investment(df, i)
    df.at[i, 'Depreciation'] = calc_Depreciation(df, i)
    df.at[i, 'Change in Capital'] = calc_change_in_Capital(df, i)
    df.at[i, 'Epsilon'] = calc_epsilon_value(df, i)

    # New stopping condition
    if df.at[i, 'Epsilon'] < parameters['epsilon']:
        print('Stopping condition met at period:', i)
        print('Capital:', '{:,.2f}'.format(df.at[i, 'Capital']))
        print('Output:', '{:,.2f}'.format(df.at[i, 'Output']))
        print('Investment:', '{:,.2f}'.format(df.at[i, 'Investment']))
        print('Depreciation: ', '{:,.2f}'.format(df.at[i, 'Depreciation']))
        print('Change in capital: ', '{:,.2f}'.format(df.at[i, 'Change in Capital']))
        print('Epsilon', '{:,.2f}'.format(df.at[i, 'Epsilon']))
        df = df[:i+1]
        # display(df) # uncheck or check for df
        break  # Exit the loop

```






# spacer

```{r}
# this is one of the first shiny app version for the chapter 6 solow model

library(shiny)
library(dplyr)
library(ggplot2)

# orignal working code, going to add the new fetures in the other one
# Define UI
# This is model after excel - 2024 winter - 381econ - python -data/
ui <- fluidPage(
  titlePanel("Economic Growth Simulation"),
  sidebarLayout(
    sidebarPanel(
      numericInput("Simulation_Period", "Simulation Period (yrs)", value = 50, step = 1),
      numericInput("s", "Parameter s", value = 0.2, step = 0.01),
      numericInput("delta", "Parameter delta", value = 0.15, step = 0.01),
      numericInput("n", "Parameter n", value = 0.02, step = 0.01),
      numericInput("z", "Parameter z", value = 0.02, step = 0.01),
      numericInput("l", "Parameter l", value = 0.1, step = 0.01),
      numericInput("A", "Initial value for A", value = 1.0, step = 0.1),
      numericInput("L", "Initial value for L", value = 1.0, step = 0.1),
      textInput("param_name", "Quantitative exp (s, delta, n, z, l)"),
      numericInput("new_value", "New Value", value = 0, step = 0.01),
      numericInput("start_period", "Start Period", value = 0, step = 1),
      numericInput("length", "Length of Effect", value = 10, step = 1),
      actionButton("add_experiment", "Add Experiment"),
      actionButton("simulate", "Simulate"),
      tableOutput("experimentsTable")
    ),
    mainPanel(
      tableOutput("resultsTable"),
      fluidRow(
        column(6, plotOutput("plot_K")),
        column(6, plotOutput("plot_Y"))
      )
    )
  )
)

# Define server logic
server <- function(input, output, session) {
  experiments <- reactiveVal(data.frame(
    param = character(),
    new_value = numeric(),
    start_period = integer(),
    length = integer(),
    stringsAsFactors = FALSE
  ))
  
  observeEvent(input$add_experiment, {
    new_experiment <- data.frame(
      param = input$param_name,
      new_value = input$new_value,
      start_period = input$start_period,
      length = input$length
    )
    experiments(rbind(experiments(), new_experiment))
  })
  
  output$experimentsTable <- renderTable({
    experiments()
  })
  
  results <- eventReactive(input$simulate, {
    # Initialize parameters
    num_periods <- input$Simulation_Period + 1
    s <- input$s
    delta <- input$delta
    n <- input$n
    z <- input$z
    l <- input$l
    A <- input$A
    L <- input$L
    
    # Calculate k_star_initial
    k_star_initial <- ((s / (delta + n + z * l)) ** 1.5) * (1 - l)
    
    params <- data.frame(
      Period = 0:(num_periods - 1),
      s = rep(s, num_periods),
      delta = rep(delta, num_periods),
      n = rep(n, num_periods),
      z = rep(z, num_periods),
      l = rep(l, num_periods),
      `Delta k` = rep(0.0, num_periods),
      `k*` = rep(k_star_initial, num_periods),
      A = rep(A, num_periods),
      L = rep(L, num_periods),
      K = rep(0.0, num_periods),
      Y = rep(0.0, num_periods)
    )
    
    # Apply quantitative experiments
    exps <- experiments()
    for (exp in 1:nrow(exps)) {
      start <- exps$start_period[exp] + 1
      end <- min(start + exps$length[exp] - 1, num_periods - 1)
      params[start:end, exps$param[exp]] <- exps$new_value[exp]
    }
    
    # Calculation functions
    calculate_Delta_k <- function(df, row_index) {
      if (row_index == 1) {
        return(0.0)
      } else {
        delta_k <- df[row_index, 's'] * ((1 - df[row_index, 'l']) ** (2/3)) * (df[row_index - 1, 'k*'] ** (1/3)) -
          (df[row_index, 'z'] * df[row_index, 'l'] + df[row_index, 'n'] + df[row_index, 'delta']) * df[row_index - 1, 'k*']
        return(delta_k)
      }
    }
    
    calculate_k_star <- function(df, row_index, k_star_initial) {
      if (row_index == 1) {
        k_star_value <- k_star_initial
      } else {
        k_star_value <- (df[row_index - 1, 'k*'] + df[row_index, 'Delta k'])
      }
      return(k_star_value)
    }
    
    calculate_A <- function(df, row_index, initial_A) {
      if (row_index == 1) {
        return(initial_A)
      } else {
        A <- df[row_index - 1, 'A'] * (1 + df[row_index, 'z'] * df[row_index, 'l'])
        return(A)
      }
    }
    
    calculate_L <- function(df, row_index, initial_L) {
      if (row_index == 1) {
        return(initial_L)
      } else {
        L <- df[row_index - 1, 'L'] * (1 + df[row_index, 'n'])
        return(L)
      }
    }
    
    calculate_K <- function(df, row_index) {
      K <- df[row_index, 'k*'] * df[row_index, 'L'] * df[row_index, 'A']
      return(K)
    }
    
    calculate_Y <- function(df, row_index) {
      return((1 - df[row_index, 'l']) ** (2/3) * df[row_index, 'K'] ** (1/3) * (df[row_index, 'A'] * df[row_index, 'L']) ** (2/3))
    }
    
    # Apply calculations
    for (i in 1:num_periods) {
      params$`Delta k`[i] <- calculate_Delta_k(params, i)
      params$`k*`[i] <- calculate_k_star(params, i, k_star_initial)
      params$A[i] <- calculate_A(params, i, A)
      params$L[i] <- calculate_L(params, i, L)
      params$K[i] <- calculate_K(params, i)
      params$Y[i] <- calculate_Y(params, i)
    }
    
    params
  })
  
  output$resultsTable <- renderTable({
    results_df <- results()
    results_df
  }, rownames = FALSE)
  
  output$plot_K <- renderPlot({
    results_df <- results()
    ggplot(results_df, aes(x = Period, y = K)) +
      geom_line() +
      geom_point() +
      ggtitle("Capital (K) Over Time") +
      xlab("Period") +
      ylab("Capital (K)") +
      theme_minimal()
  })
  
  output$plot_Y <- renderPlot({
    results_df <- results()
    ggplot(results_df, aes(x = Period, y = Y)) +
      geom_line() +
      geom_point() +
      ggtitle("Output (Y) Over Time") +
      xlab("Period") +
      ylab("Output (Y)") +
      theme_minimal()
  })
}

# Run the application
shinyApp(ui = ui, server = server)


```


# spacer


```{r}
# chapter 6 solow model shiny app
# this is my latest version as of 2/6/25
library(shiny)
library(ggplot2)
library(DT)     # for interactive table
library(zip)    # to create ZIP files in download handler
library(bslib)


# Define UI
ui <- page_sidebar(
  title = "Solow-Romer Macro Simulation",
  sidebar = sidebar(  # Sidebar content: all the input controls
    width = 600, # edit sidebar width. This is not friendly with smaller screens
    h4("Simulation Parameters"),
    sliderInput("Simulation_Period", "Simulation Period (yrs)", 
                min = 20, max = 150, value = 50, step = 1),
    sliderInput("s", "Savings Rate (s)", min = 0, max = 1, value = 0.2, step = 0.01),
    sliderInput("delta", "Depreciation Rate (delta)", min = 0, max = .5, value = 0.15, step = 0.01),
    sliderInput("n", "n", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("z", "Parameter z", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("l", "Parameter l", min = 0, max = 1, value = 0.1, step = 0.01),
    selectInput("A", "Initial value for A", choices = c(1, 100, 1000), selected = 1), # 343
    selectInput("L", "Initial value for L", choices = c(1, 100, 1000), selected = 1), # 343
    h4("Experiments"),
    selectInput("param_name", "Quantitative exp (s, delta, n, z, l)", 
                choices = c("s", "delta", "n", "z", "l"),
                selected = "s"),
    numericInput("new_value", "New Value", value = 0, step = 0.01),
    numericInput("start_period", "Start Period", value = 5, step = 1),
    numericInput("length", "Length of Effect", value = 5, step = 1),
    actionButton("add_experiment", "Add Experiment"),
    actionButton("simulate", "Simulate"),
    h4("Download Results"),
    DTOutput("experimentsTable"), # Show experiments in a DT table so we can add Delete buttons
    downloadButton("downloadPlots", "Download All Plots as PNG (ZIP)"),
    downloadButton("downloadData", "Download Data as CSV")
  ),
  
  mainPanel(  # Use mainPanel for the content
    tabsetPanel( # use tabs to organize the outputs
      tabPanel("Plots",
               div(style = "width: 1800px; margin: auto;",  # Wrapping fluidrow's with fixed width
                   fluidRow(
                     column(6, plotOutput("plot_K", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_Y", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_delta_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_little_k", width = "900px", height = "600px"))
                   )
               ),
      ),
      tabPanel("Log/Ratio scale",
               div(style = "width: 1800px; margin: auto;",
                   fluidRow(
                     column(6, plotOutput("plot_log_L", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_K", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_delta_k_change1", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_log_Y", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_A", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_delta_k_change", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Table", tableOutput("resultsTable"))
    )
  )
)

# Define server logic
server <- function(input, output, session) {
  experiments <- reactiveVal(
    data.frame(
      param = character(0),
      new_value = numeric(0),
      start_period = integer(0),
      length = integer(0),
      stringsAsFactors = FALSE
    )
  )
  
  # Add experiment: simply append a new row
  # need to rename this so they take up less space in the sidebar
  observeEvent(input$add_experiment, {
    new_experiment <- data.frame(
      param        = input$param_name,
      new_value    = input$new_value,
      start_period = input$start_period,
      length       = input$length,
      stringsAsFactors = FALSE
    )
    experiments(rbind(experiments(), new_experiment))
  })
  
  # Render experiments table with Delete buttons
  output$experimentsTable <- renderDT({
    exps <- experiments()
    if (nrow(exps) == 0) return(NULL)
    
    # Create a column of actionButtons, each referencing its row index i
    deleteButtons <- sapply(seq_len(nrow(exps)), function(i) {
      as.character(
        actionButton(
          inputId = paste0("delete_row_", i),
          label = "Delete",
          class = "btn btn-danger btn-sm",
          # This sets the input$delete_row to something like "delete_row_3"
          onclick = 'Shiny.setInputValue(\"delete_row\", this.id, {priority: \"event\"})'
        )
      )
    })
    
    exps$Delete <- deleteButtons
    
    datatable(
      exps,
      escape = FALSE,        # Must be FALSE to render the HTML in the Delete column
      selection = "none",
      options = list(pageLength = 5)
    )
  }, server = FALSE)
  
  # Observe which row's Delete button was clicked
  observeEvent(input$delete_row, {
    # Extract row index from the ID string "delete_row_X"
    row_str <- gsub("delete_row_", "", input$delete_row)
    row_num <- as.numeric(row_str)
    
    exps <- experiments()
    # Check row_num validity, then remove that row
    if (!is.na(row_num) && row_num >= 1 && row_num <= nrow(exps)) {
      exps <- exps[-row_num, ]
      experiments(exps)
    }
  })
  
  # Main simulation (calculus-intensive) - structure unchanged
  results <- eventReactive(input$simulate, {
    
    # Ensure at least one experiment is added before simulating update 344
    if (nrow(experiments()) == 0) {
      showModal(modalDialog(
        title = "Error",
        "Please add at least one experiment to define parameter changes before running the simulation.",
        easyClose = TRUE,
        footer = NULL
      ))
      return(NULL)
    }
    
    # Convert inputs A and L to numeric update: 343
    A <- as.numeric(input$A) # 343
    L <- as.numeric(input$L) # 343
    
    # Initialize parameters
    num_periods <- input$Simulation_Period + 1
    s <- input$s
    delta <- input$delta
    n <- input$n
    z <- input$z
    l <- input$l
    
    # Calculate k_star_initial
    k_star_initial <- ((s / (delta + n + z * l)) ** 1.5) * (1 - l)
    
    params <- data.frame(
      Period = 0:(num_periods - 1),
      s = rep(s, num_periods),
      delta = rep(delta, num_periods),
      n = rep(n, num_periods),
      z = rep(z, num_periods),
      l = rep(l, num_periods),
      `delta_k` = rep(0.0, num_periods),
      
      # I'm changing k_star to little_k. little_k is capital efficiency units
      # this is doing little_k = delta_k + little_k_t-1.   
      `little_k` = rep(k_star_initial, num_periods), # so this is only k* for first period but it is just little k. k* is only when economy is at steady state. steady state is when s_bar * Y = d_bar * K or when investment minus depreciation equal zero. 
      A = rep(A, num_periods),
      L = rep(L, num_periods),
      K = rep(0.0, num_periods),
      Y = rep(0.0, num_periods)
    )
    
    # Apply quantitative experiments
    exps <- experiments()
    for (exp in 1:nrow(exps)) {
      start <- exps$start_period[exp] + 1
      end   <- min(start + exps$length[exp] - 1, num_periods - 1)
      # Overwrite that parameter in [start, end]
      params[start:end, exps$param[exp]] <- exps$new_value[exp]
    }
    
    # Calculation functions
    calculate_delta_k <- function(df, row_index) {
      if (row_index == 1) {
        return(0.0)
      } else {
        delta_k <- df[row_index, 's'] * ((1 - df[row_index, 'l']) ^ (2/3)) * 
          (df[row_index - 1, 'little_k'] ^ (1/3)) -
          (df[row_index, 'z'] * df[row_index, 'l'] + df[row_index, 'n'] + df[row_index, 'delta']) * 
          df[row_index - 1, 'little_k']
        return(delta_k)
      }
    }
    
    calculate_little_k <- function(df, row_index, k_star_initial) {
      if (row_index == 1) {
        little_k_value <- k_star_initial
      } else {
        little_k_value <- (df[row_index - 1, 'little_k'] + df[row_index, 'delta_k'])
      }
      return(little_k_value)
    }
    
    calculate_A <- function(df, row_index, initial_A) {
      if (row_index == 1) {
        return(initial_A)
      } else {
        A <- df[row_index - 1, 'A'] * (1 + df[row_index, 'z'] * df[row_index, 'l'])
        return(A)
      }
    }
    
    calculate_L <- function(df, row_index, initial_L) {
      if (row_index == 1) {
        return(initial_L)
      } else {
        L <- df[row_index - 1, 'L'] * (1 + df[row_index, 'n'])
        return(L)
      }
    }
    
    calculate_K <- function(df, row_index) {
      K <- df[row_index, 'little_k'] * df[row_index, 'L'] * df[row_index, 'A']
      return(K) # first variable that starts to give a floating-point rounding error compared to excel model
    }
    
    calculate_Y <- function(df, row_index) {
      Y <- (1 - df[row_index, 'l']) ^ (2/3) *
        df[row_index, 'K'] ^ (1/3) *
        (df[row_index, 'A'] * df[row_index, 'L']) ^ (2/3)
      return(Y)
    }
    
    
    # Apply calculations and the order matters so re arranging this randomly will lead to different calculations results and or errors
    for (i in 1:num_periods) {
      params$`delta_k`[i] <- calculate_delta_k(params, i)
      params$`little_k`[i]      <- calculate_little_k(params, i, k_star_initial)
      params$A[i]         <- calculate_A(params, i, A)
      params$L[i]         <- calculate_L(params, i, L)
      params$K[i]         <- calculate_K(params, i)
      params$Y[i]         <- calculate_Y(params, i)
      params$log_L <- log(params$L)  # Vectorized
      params$log_K <- log(params$K)  # this 3 log calculations don't need to be above like the rest. only the ones that are dependent on each other.
      params$log_Y <- log(params$Y)  # so Y does need to be above. giving the for i is all done in order which it should be or else the log calculations will return error.
      params$log_A <- log(params$A)  # when adding calc here, then add to tabpanel, and both plot codes.
      if (i > 1) {
        params$delta_k_change[i] <- ((params$`delta_k`[i] - params$`delta_k`[i - 1]) / params$`delta_k`[i - 1]) * 100
      } else {
        params$delta_k_change[i] <- 0 }
      
      if (i > 1) {
        delta_k_current_rounded <- round(params$`delta_k`[i], 3) # Round delta_k or it will return large initial shocks
        delta_k_previous_rounded <- round(params$`delta_k`[i - 1], 3) 
        
        params$delta_k_change1[i] <- ((delta_k_current_rounded - delta_k_previous_rounded) / delta_k_previous_rounded) * 100
      } else {
        params$delta_k_change1[i] <- 0 }
    }
    # so i did the percent change and it has some large initial shocks so I then rounded delta_k before
    # the calculation but the numbers are more off or its wrong way of doing
    # so do i keep the 1st percent change and log that? doing the logaritchmic looks more accurate
    params
  })
  
  # Render final results table
  output$resultsTable <- renderTable({
    results_df <- results()
    results_df
  }, rownames = FALSE)
  
  # Plot code
  plot_theme <- theme_bw() +  # theme_bw() = light theme
    theme(plot.title = element_text(hjust = 0.5),
          axis.title = element_text(size = 12),
          axis.text = element_text(size = 10),
          panel.grid.major = element_line(color = "grey80"), # Lighter grid lines
          panel.grid.minor = element_blank(),
          strip.background = element_rect(fill = "grey90", color = "grey90")) 
  
  make_plot <- function(data, y_var, title, y_label) {
    ggplot(data, aes(x = Period, y = !!sym(y_var))) +
      geom_line() +
      geom_point() +
      ggtitle(title) +
      xlab("Period") +
      ylab(y_label) +
      plot_theme
  }
  
  output$plot_K <- renderPlot({ make_plot(results(), "K", "Capital (K) Over Time", "Capital (K)") }, res = 100)
  output$plot_Y <- renderPlot({ make_plot(results(), "Y", "Output (Y) Over Time", "Output (Y)") }, res = 100)
  output$plot_delta_k <- renderPlot({ make_plot(results(), "delta_k", "Change in Capital (Δk) Over Time", "Change in Capital (Δk)") }, res = 100)
  output$plot_little_k <- renderPlot({ make_plot(results(), "little_k", "Capital Efficiency Units", "Capital Efficiency Units (little_k)") }, res = 100)
  
  output$plot_log_L <- renderPlot({ make_plot(results(), "log_L", "Log/ratio scale of Labor (L)", "Log of Labor (L)") }, res = 100)
  output$plot_log_K <- renderPlot({ make_plot(results(), "log_K", "Log/ratio scale of Capital (K)", "Log of Capital (K)") }, res = 100)
  output$plot_log_Y <- renderPlot({ make_plot(results(), "log_Y", "Log of Output (Y)", "Log of Output (Y)") }, res = 100)
  output$plot_log_A <- renderPlot({ make_plot(results(), "log_A", "Log/ratio scale of TFP (A)", "Log of TFP (A)") }, res = 100)
  output$plot_delta_k_change <- renderPlot({ make_plot(results(), "delta_k_change", "percent change of delta_k", "%change of delta_k") }, res = 100)
  
  
  # Download handler for CSV
  output$downloadData <- downloadHandler(
    filename = function() {
      paste0("results_", Sys.Date(), ".csv")
    },
    content = function(file) {
      write.csv(results(), file, row.names = FALSE)
    }
  )
  
  # Download handler for all plots
  output$downloadPlots <- downloadHandler(
    filename = function() {
      paste0("plots_", Sys.Date(), ".zip")
    },
    content = function(file) {
      # temp file storage but new shiny update change the way file donwloads happen so this might not be needed now
      temp_dir <- tempdir()
      file_paths <- c()
      
      # ggplot loop
      df <- results()
      plots <- list(
        plot_K = make_plot(df, "K", "Capital (K) Over Time", "Capital (K)"),
        plot_Y = make_plot(df, "Y", "Output (Y) Over Time", "Output (Y)"),
        plot_delta_k = make_plot(df, "delta_k", "Change in Capital (Δk) Over Time", "Change in Capital (Δk)"),
        plot_little_k = make_plot(df, "little_k", "Capital Efficiency Units", "Capital Efficiency Units (little_k)"),
        plot_log_L = make_plot(df, "log_L", "Log of Labor (L) Over Time", "Log of Labor (L)"),  # Add log plots
        plot_log_K = make_plot(df, "log_K", "Log of Capital (K) Over Time", "Log of Capital (K)"),
        plot_log_Y = make_plot(df, "log_Y", "Log of Output (Y) Over Time", "Log of Output (Y)"),
        plot_log_A = make_plot(df, "log_A", "Log/ratio scale of TFP (A)", "Log of TFP (A)"),
        plot_delta_k_change = make_plot(df, "delta_k_change", "% change of delta_k", "% change of delta_k")
      )
      
      # Save each plot to a PNG
      for (plot_name in names(plots)) {
        plot_file <- file.path(temp_dir, paste0(plot_name, ".png"))
        ggsave(plot_file, plots[[plot_name]], device = "png", width = 6, height = 4, dpi = 300, bg = "white")
        file_paths <- c(file_paths, plot_file)
      }
      
      # Zip all the png plots together
      zipr(zipfile = file, files = file_paths)
    }
  )
}

# Run the application
shinyApp(ui = ui, server = server)


```

# spacer

```{r}
# model 2/6/25

library(shiny)
library(ggplot2)
library(DT)     # for interactive table
library(zip)    # to create ZIP files in download handler
library(bslib)

# use reactive expressions to avoid re calculating or re fetching data when not needed.

# Define UI
ui <- page_sidebar(
  title = "Solow-Romer Macro Simulation",
  sidebar = sidebar(  # Sidebar content: all the input controls
    width = 600, # edit sidebar width. This is not friendly with smaller screens
    h4("Simulation Parameters"),
    sliderInput("Simulation_Period", "Simulation Period (yrs)", 
                min = 20, max = 150, value = 50, step = 1),
    sliderInput("s", "Savings Rate (s)", min = 0, max = 1, value = 0.2, step = 0.01),
    sliderInput("delta", "Depreciation Rate (delta)", min = 0, max = .5, value = 0.15, step = 0.01),
    sliderInput("n", "n", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("z", "Parameter z", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("l", "Parameter l", min = 0, max = 1, value = 0.1, step = 0.01),
    selectInput("A", "Initial value for A", choices = c(1, 100, 1000), selected = 1), # 343
    selectInput("L", "Initial value for L", choices = c(1, 100, 1000), selected = 1), # 343
    h4("Experiments"),
    selectInput("param_name", "Quantitative exp (s, delta, n, z, l)", 
                choices = c("s", "delta", "n", "z", "l"),
                selected = "s"),
    numericInput("new_value", "New Value", value = 0, step = 0.01),
    numericInput("start_period", "Start Period", value = 5, step = 1),
    numericInput("length", "Length of Effect", value = 5, step = 1),
    actionButton("add_experiment", "Add Experiment"),
    actionButton("simulate", "Simulate"),
    h4("Download Results"),
    DTOutput("experimentsTable"), # Show experiments in a DT table so we can add Delete buttons
    downloadButton("downloadPlots", "Download All Plots as PNG (ZIP)"),
    downloadButton("downloadData", "Download Data as CSV")
  ),
  
  mainPanel(  # Use mainPanel for the content
    tabsetPanel( # use tabs to organize the outputs
      tabPanel("Plots",
               div(style = "width: 1800px; margin: auto;",  # Wrapping fluidrow's with fixed width
                   fluidRow(
                     column(6, plotOutput("plot_K", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_Y", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_delta_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_little_k", width = "900px", height = "600px"))
                   )
               ),
      ),
      tabPanel("Log/Ratio scale",
               div(style = "width: 1800px; margin: auto;",
                   fluidRow(
                     column(6, plotOutput("plot_log_L", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_K", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_log_Y", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_A", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Table", tableOutput("resultsTable"))
    )
  )
)

# Define server logic
server <- function(input, output, session) {
  experiments <- reactiveVal(
    data.frame(
      param = character(0),
      new_value = numeric(0),
      start_period = integer(0),
      length = integer(0),
      stringsAsFactors = FALSE
    )
  )
  
  # Add experiment: simply append a new row
  # need to rename this so they take up less space in the sidebar
  observeEvent(input$add_experiment, {
    new_experiment <- data.frame(
      param        = input$param_name,
      new_value    = input$new_value,
      start_period = input$start_period,
      length       = input$length,
      stringsAsFactors = FALSE
    )
    experiments(rbind(experiments(), new_experiment))
  })
  
  # Render experiments table with Delete buttons
  output$experimentsTable <- renderDT({
    exps <- experiments()
    if (nrow(exps) == 0) return(NULL)
    
    # Create a column of actionButtons, each referencing its row index i
    deleteButtons <- sapply(seq_len(nrow(exps)), function(i) {
      as.character(
        actionButton(
          inputId = paste0("delete_row_", i),
          label = "Delete",
          class = "btn btn-danger btn-sm",
          # This sets the input$delete_row to something like "delete_row_3"
          onclick = 'Shiny.setInputValue(\"delete_row\", this.id, {priority: \"event\"})'
        )
      )
    })
    
    exps$Delete <- deleteButtons
    
    datatable(
      exps,
      escape = FALSE,        # Must be FALSE to render the HTML in the Delete column
      selection = "none",
      options = list(pageLength = 5)
    )
  }, server = FALSE)
  
  # Observe which row's Delete button was clicked
  observeEvent(input$delete_row, {
    # Extract row index from the ID string "delete_row_X"
    row_str <- gsub("delete_row_", "", input$delete_row)
    row_num <- as.numeric(row_str)
    
    exps <- experiments()
    # Check row_num validity, then remove that row
    if (!is.na(row_num) && row_num >= 1 && row_num <= nrow(exps)) {
      exps <- exps[-row_num, ]
      experiments(exps)
    }
  })
  
  # Main simulation (calculus-intensive) - structure unchanged
  results <- eventReactive(input$simulate, {
    
    # Ensure at least one experiment is added before simulating update 344
    if (nrow(experiments()) == 0) {
      showModal(modalDialog(
        title = "Error",
        "Please add at least one experiment to define parameter changes before running the simulation.",
        easyClose = TRUE,
        footer = NULL
      ))
      return(NULL)
    }
    
    # Convert inputs A and L to numeric update: 343
    A <- as.numeric(input$A) # 343
    L <- as.numeric(input$L) # 343
    
    # Initialize parameters
    num_periods <- input$Simulation_Period + 1
    s <- input$s
    delta <- input$delta
    n <- input$n
    z <- input$z
    l <- input$l
    
    # Calculate k_star_initial
    k_star_initial <- ((s / (delta + n + z * l)) ** 1.5) * (1 - l)
    
    params <- data.frame(
      Period = 0:(num_periods - 1),
      s = rep(s, num_periods),
      delta = rep(delta, num_periods),
      n = rep(n, num_periods),
      z = rep(z, num_periods),
      l = rep(l, num_periods),
      `delta_k` = rep(0.0, num_periods),
      
      # I'm changing k_star to little_k. little_k is capital efficiency units
      # this is doing little_k = delta_k + little_k_t-1.   
      `little_k` = rep(k_star_initial, num_periods), # so this is only k* for first period but it is just little k. k* is only when economy is at steady state. steady state is when s_bar * Y = d_bar * K or when investment minus depreciation equal zero. 
      A = rep(A, num_periods),
      L = rep(L, num_periods),
      K = rep(0.0, num_periods),
      Y = rep(0.0, num_periods)
    )
    
    # Apply quantitative experiments
    exps <- experiments()
    for (exp in 1:nrow(exps)) {
      start <- exps$start_period[exp] + 1
      end   <- min(start + exps$length[exp] - 1, num_periods - 1)
      # Overwrite that parameter in [start, end]
      params[start:end, exps$param[exp]] <- exps$new_value[exp]
    }
    
    # Calculation functions
    calculate_delta_k <- function(df, row_index) {
      if (row_index == 1) {
        return(0.0)
      } else {
        delta_k <- df[row_index, 's'] * ((1 - df[row_index, 'l']) ^ (2/3)) * 
          (df[row_index - 1, 'little_k'] ^ (1/3)) -
          (df[row_index, 'z'] * df[row_index, 'l'] + df[row_index, 'n'] + df[row_index, 'delta']) * 
          df[row_index - 1, 'little_k']
        return(delta_k)
      }
    }
    
    calculate_little_k <- function(df, row_index, k_star_initial) {
      if (row_index == 1) {
        little_k_value <- k_star_initial
      } else {
        little_k_value <- (df[row_index - 1, 'little_k'] + df[row_index, 'delta_k'])
      }
      return(little_k_value)
    }
    
    calculate_A <- function(df, row_index, initial_A) {
      if (row_index == 1) {
        return(initial_A)
      } else {
        A <- df[row_index - 1, 'A'] * (1 + df[row_index, 'z'] * df[row_index, 'l'])
        return(A)
      }
    }
    
    calculate_L <- function(df, row_index, initial_L) {
      if (row_index == 1) {
        return(initial_L)
      } else {
        L <- df[row_index - 1, 'L'] * (1 + df[row_index, 'n'])
        return(L)
      }
    }
    
    calculate_K <- function(df, row_index) {
      K <- df[row_index, 'little_k'] * df[row_index, 'L'] * df[row_index, 'A']
      return(K) # first variable that starts to give a floating-point rounding error compared to excel model
    }
    
    calculate_Y <- function(df, row_index) {
      Y <- (1 - df[row_index, 'l']) ^ (2/3) *
        df[row_index, 'K'] ^ (1/3) *
        (df[row_index, 'A'] * df[row_index, 'L']) ^ (2/3)
      return(Y)
    }
    
    
    # Apply calculations and the order matters so re arranging this randomly will lead to different calculations results and or errors
    for (i in 1:num_periods) {
      params$`delta_k`[i] <- calculate_delta_k(params, i)
      params$`little_k`[i]      <- calculate_little_k(params, i, k_star_initial)
      params$A[i]         <- calculate_A(params, i, A)
      params$L[i]         <- calculate_L(params, i, L)
      params$K[i]         <- calculate_K(params, i)
      params$Y[i]         <- calculate_Y(params, i)
    }
    
      params$log_L <- log(params$L)  # Vectorized
      params$log_K <- log(params$K)  # this 3 log calculations don't need to be above like the rest. only the ones that are dependent on each other.
      params$log_Y <- log(params$Y)  # so Y does need to be above. giving the for i is all done in order which it should be or else the log calculations will return error.
      params$log_A <- log(params$A)  # when adding calc here, then add to tabpanel, and both plot codes.

    params
  })
  
  # Render final results table
  output$resultsTable <- renderTable({
    results_df <- results()
    results_df
  }, rownames = FALSE)
  
  # Plot code
  plot_theme <- theme_bw() +  # theme_bw() = light theme
    theme(plot.title = element_text(hjust = 0.5),
          axis.title = element_text(size = 12),
          axis.text = element_text(size = 10),
          panel.grid.major = element_line(color = "grey80"), # Lighter grid lines
          panel.grid.minor = element_blank(),
          strip.background = element_rect(fill = "grey90", color = "grey90")) 
  
  make_plot <- function(data, y_var, title, y_label) {
    ggplot(data, aes(x = Period, y = !!sym(y_var))) +
      geom_line() +
      geom_point() +
      ggtitle(title) +
      xlab("Period") +
      ylab(y_label) +
      plot_theme
  }
  
  output$plot_K <- renderPlot({ make_plot(results(), "K", "Capital (K) Over Time", "Capital (K)") }, res = 100)
  output$plot_Y <- renderPlot({ make_plot(results(), "Y", "Output (Y) Over Time", "Output (Y)") }, res = 100)
  output$plot_delta_k <- renderPlot({ make_plot(results(), "delta_k", "Change in Capital (Δk) Over Time", "Change in Capital (Δk)") }, res = 100)
  output$plot_little_k <- renderPlot({ make_plot(results(), "little_k", "Capital Efficiency Units", "Capital Efficiency Units (little_k)") }, res = 100)
  
  output$plot_log_L <- renderPlot({ make_plot(results(), "log_L", "Log/ratio scale of Labor (L)", "Log of Labor (L)") }, res = 100)
  output$plot_log_K <- renderPlot({ make_plot(results(), "log_K", "Log/ratio scale of Capital (K)", "Log of Capital (K)") }, res = 100)
  output$plot_log_Y <- renderPlot({ make_plot(results(), "log_Y", "Log of Output (Y)", "Log of Output (Y)") }, res = 100)
  output$plot_log_A <- renderPlot({ make_plot(results(), "log_A", "Log/ratio scale of TFP (A)", "Log of TFP (A)") }, res = 100)
#  output$plot_delta_k_change <- renderPlot({ make_plot(results(), "delta_k_change", "percent change of delta_k", "%change of delta_k") }, res = 100)
  
  
  # Download handler for CSV
  output$downloadData <- downloadHandler(
    filename = function() {
      paste0("results_", Sys.Date(), ".csv")
    },
    content = function(file) {
      write.csv(results(), file, row.names = FALSE)
    }
  )
  
  # Download handler for all plots
  output$downloadPlots <- downloadHandler(
    filename = function() {
      paste0("plots_", Sys.Date(), ".zip")
    },
    content = function(file) {
      # temp file storage but new shiny update change the way file donwloads happen so this might not be needed now
      temp_dir <- tempdir()
      file_paths <- c()
      
      # ggplot loop
      df <- results()
      plots <- list(
        plot_K = make_plot(df, "K", "Capital (K) Over Time", "Capital (K)"),
        plot_Y = make_plot(df, "Y", "Output (Y) Over Time", "Output (Y)"),
        plot_delta_k = make_plot(df, "delta_k", "Change in Capital (Δk) Over Time", "Change in Capital (Δk)"),
        plot_little_k = make_plot(df, "little_k", "Capital Efficiency Units", "Capital Efficiency Units (little_k)"),
        plot_log_L = make_plot(df, "log_L", "Log of Labor (L) Over Time", "Log of Labor (L)"),  # Add log plots
        plot_log_K = make_plot(df, "log_K", "Log of Capital (K) Over Time", "Log of Capital (K)"),
        plot_log_Y = make_plot(df, "log_Y", "Log of Output (Y) Over Time", "Log of Output (Y)"),
        plot_log_A = make_plot(df, "log_A", "Log/ratio scale of TFP (A)", "Log of TFP (A)")
#        plot_delta_k_change = make_plot(df, "delta_k_change", "% change of delta_k", "% change of delta_k")
      )
      
      # Save each plot to a PNG
      for (plot_name in names(plots)) {
        plot_file <- file.path(temp_dir, paste0(plot_name, ".png"))
        ggsave(plot_file, plots[[plot_name]], device = "png", width = 6, height = 4, dpi = 300, bg = "white")
        file_paths <- c(file_paths, plot_file)
      }
      
      # Zip all the png plots together
      zipr(zipfile = file, files = file_paths)
    }
  )
}

# Run the application
shinyApp(ui = ui, server = server)


```


# idk if this is the same as above but just adding here since making small changes but adds large code sections


# spacer

```{r}
library(shiny)
library(ggplot2)
library(DT)     # for interactive table
library(zip)    # to create ZIP files in download handler
library(bslib)

# use reactive expressions to avoid re calculating or re fetching data when not needed.

# Define UI
ui <- page_sidebar(
  title = "Solow-Romer Macro Simulation",
  sidebar = sidebar(  # Sidebar content: all the input controls
    width = 600, # edit sidebar width. This is not friendly with smaller screens
    h4("Simulation Parameters"),
    sliderInput("Simulation_Period", "Simulation Period (yrs)", 
                min = 20, max = 150, value = 50, step = 1),
    sliderInput("s", "Savings Rate (s)", min = 0, max = 1, value = 0.2, step = 0.01),
    sliderInput("delta", "Depreciation Rate (delta)", min = 0, max = .5, value = 0.15, step = 0.01),
    sliderInput("n", "n", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("z", "Parameter z", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("l", "Parameter l", min = 0, max = 1, value = 0.1, step = 0.01),
    selectInput("A", "Initial value for A", choices = c(1, 100, 1000), selected = 1), # 343
    selectInput("L", "Initial value for L", choices = c(1, 100, 1000), selected = 1), # 343
    h4("Experiments"),
    selectInput("param_name", "Quantitative exp (s, delta, n, z, l)", 
                choices = c("s", "delta", "n", "z", "l"),
                selected = "s"),
    numericInput("new_value", "New Value", value = 0, step = 0.01),
    numericInput("start_period", "Start Period", value = 5, step = 1),
    numericInput("length", "Length of Effect", value = 5, step = 1),
    actionButton("add_experiment", "Add Experiment"),
    actionButton("simulate", "Simulate"),
    h4("Download Results"),
    DTOutput("experimentsTable"), # Show experiments in a DT table so we can add Delete buttons
    downloadButton("downloadPlots", "Download All Plots as PNG (ZIP)"),
    downloadButton("downloadData", "Download Data as CSV")
  ),
  
  mainPanel(  # Use mainPanel for the content
    tabsetPanel( # use tabs to organize the outputs
      tabPanel("Plots",
               div(style = "width: 1800px; margin: auto;",  # Wrapping fluidrow's with fixed width
                   fluidRow(
                     column(6, plotOutput("plot_K", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_Y", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_delta_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_little_k", width = "900px", height = "600px"))
                   )
               ),
      ),
      tabPanel("Log/Ratio scale",
               div(style = "width: 1800px; margin: auto;",
                   fluidRow(
                     column(6, plotOutput("plot_log_L", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_K", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_log_Y", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_A", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Table", tableOutput("resultsTable"))
    )
  )
)

# Define server logic
server <- function(input, output, session) {
  experiments <- reactiveVal(
    data.frame(
      param = character(0),
      new_value = numeric(0),
      start_period = integer(0),
      length = integer(0),
      stringsAsFactors = FALSE
    )
  )
  
  # Add experiment: simply append a new row
  # need to rename this so they take up less space in the sidebar
  observeEvent(input$add_experiment, {
    new_experiment <- data.frame(
      param        = input$param_name,
      new_value    = input$new_value,
      start_period = input$start_period,
      length       = input$length,
      stringsAsFactors = FALSE
    )
    experiments(rbind(experiments(), new_experiment))
  })
  
  # Render experiments table with Delete buttons
  output$experimentsTable <- renderDT({
    exps <- experiments()
    if (nrow(exps) == 0) return(NULL)
    
    # Create a column of actionButtons, each referencing its row index i
    deleteButtons <- sapply(seq_len(nrow(exps)), function(i) {
      as.character(
        actionButton(
          inputId = paste0("delete_row_", i),
          label = "Delete",
          class = "btn btn-danger btn-sm",
          # This sets the input$delete_row to something like "delete_row_3"
          onclick = 'Shiny.setInputValue(\"delete_row\", this.id, {priority: \"event\"})'
        )
      )
    })
    
    exps$Delete <- deleteButtons
    
    datatable(
      exps,
      escape = FALSE,        # Must be FALSE to render the HTML in the Delete column
      selection = "none",
      options = list(pageLength = 5)
    )
  }, server = FALSE)
  
  # Observe which row's Delete button was clicked
  observeEvent(input$delete_row, {
    # Extract row index from the ID string "delete_row_X"
    row_str <- gsub("delete_row_", "", input$delete_row)
    row_num <- as.numeric(row_str)
    
    exps <- experiments()
    # Check row_num validity, then remove that row
    if (!is.na(row_num) && row_num >= 1 && row_num <= nrow(exps)) {
      exps <- exps[-row_num, ]
      experiments(exps)
    }
  })
  
  # Main simulation (calculus-intensive) - structure unchanged
  results <- eventReactive(input$simulate, {
    
    # Ensure at least one experiment is added before simulating update 344
    if (nrow(experiments()) == 0) {
      showModal(modalDialog(
        title = "Error",
        "Please add at least one experiment to define parameter changes before running the simulation.",
        easyClose = TRUE,
        footer = NULL
      ))
      return(NULL)
    }
    
    # Convert inputs A and L to numeric update: 343
    A <- as.numeric(input$A) # 343
    L <- as.numeric(input$L) # 343
    
    # Initialize parameters
    num_periods <- input$Simulation_Period + 1
    s <- input$s
    delta <- input$delta
    n <- input$n
    z <- input$z
    l <- input$l
    
    # Calculate k_star_initial
    k_star_initial <- ((s / (delta + n + z * l)) ** 1.5) * (1 - l)
    
    params <- data.frame(
      Period = 0:(num_periods - 1),
      s = rep(s, num_periods),
      delta = rep(delta, num_periods),
      n = rep(n, num_periods),
      z = rep(z, num_periods),
      l = rep(l, num_periods),
      `delta_k` = rep(0.0, num_periods),
      
      # I'm changing k_star to little_k. little_k is capital efficiency units
      # this is doing little_k = delta_k + little_k_t-1.   
      `little_k` = rep(k_star_initial, num_periods), # so this is only k* for first period but it is just little k. k* is only when economy is at steady state. steady state is when s_bar * Y = d_bar * K or when investment minus depreciation equal zero. 
      A = rep(A, num_periods),
      L = rep(L, num_periods),
      K = rep(0.0, num_periods),
      Y = rep(0.0, num_periods)
    )
    
    # Apply quantitative experiments
    exps <- experiments()
    for (exp in 1:nrow(exps)) {
      start <- exps$start_period[exp] + 1
      end   <- min(start + exps$length[exp] - 1, num_periods - 1)
      # Overwrite that parameter in [start, end]
      params[start:end, exps$param[exp]] <- exps$new_value[exp]
    }
    
    # Calculation functions
    calculate_delta_k <- function(df, row_index) {
      if (row_index == 1) {
        return(0.0)
      } else {
        delta_k <- df[row_index, 's'] * ((1 - df[row_index, 'l']) ^ (2/3)) * 
          (df[row_index - 1, 'little_k'] ^ (1/3)) -
          (df[row_index, 'z'] * df[row_index, 'l'] + df[row_index, 'n'] + df[row_index, 'delta']) * 
          df[row_index - 1, 'little_k']
        return(delta_k)
      }
    }
    
    calculate_little_k <- function(df, row_index, k_star_initial) {
      if (row_index == 1) {
        little_k_value <- k_star_initial
      } else {
        little_k_value <- (df[row_index - 1, 'little_k'] + df[row_index, 'delta_k'])
      }
      return(little_k_value)
    }
    
    calculate_A <- function(df, row_index, initial_A) {
      if (row_index == 1) {
        return(initial_A)
      } else {
        A <- df[row_index - 1, 'A'] * (1 + df[row_index, 'z'] * df[row_index, 'l'])
        return(A)
      }
    }
    
    calculate_L <- function(df, row_index, initial_L) {
      if (row_index == 1) {
        return(initial_L)
      } else {
        L <- df[row_index - 1, 'L'] * (1 + df[row_index, 'n'])
        return(L)
      }
    }
    
    calculate_K <- function(df, row_index) {
      K <- df[row_index, 'little_k'] * df[row_index, 'L'] * df[row_index, 'A']
      return(K) # first variable that starts to give a floating-point rounding error compared to excel model
    }
    
    calculate_Y <- function(df, row_index) {
      Y <- (1 - df[row_index, 'l']) ^ (2/3) *
        df[row_index, 'K'] ^ (1/3) *
        (df[row_index, 'A'] * df[row_index, 'L']) ^ (2/3)
      return(Y)
    }
    
    
    # Apply calculations and the order matters so re arranging this randomly will lead to different calculations results and or errors
    # so i can get rid of my calculations up there and just do them down here
    # it will make r faster
    # concerns for the row index loop, and initial params. I mean this is the code that calculates them so either way this code is executing that calculation
    # so might as well have here to make it faster
    for (i in 1:num_periods) {
      params$`delta_k`[i] <- calculate_delta_k(params, i)
      params$`little_k`[i]      <- calculate_little_k(params, i, k_star_initial)
      params$A[i]         <- calculate_A(params, i, A)
      params$L[i]         <- calculate_L(params, i, L)
      params$K[i]         <- calculate_K(params, i)
      params$Y[i]         <- calculate_Y(params, i)
    }
    
    params$log_L <- log(params$L)  # Vectorized
    params$log_K <- log(params$K)  # this 3 log calculations don't need to be above like the rest. only the ones that are dependent on each other.
    params$log_Y <- log(params$Y)  # so Y does need to be above. giving the for i is all done in order which it should be or else the log calculations will return error.
    params$log_A <- log(params$A)  # when adding calc here, then add to tabpanel, and both plot codes.
    
    params
  })
  
  # Render final results table
  output$resultsTable <- renderTable({
    results_df <- results()
    results_df
  }, rownames = FALSE)
  
  # Plot code
  plot_theme <- theme_bw() +  # theme_bw() = light theme
    theme(plot.title = element_text(hjust = 0.5),
          axis.title = element_text(size = 12),
          axis.text = element_text(size = 10),
          panel.grid.major = element_line(color = "grey80"), # Lighter grid lines
          panel.grid.minor = element_blank(),
          strip.background = element_rect(fill = "grey90", color = "grey90")) 
  
  make_plot <- function(data, y_var, title, y_label) {
    ggplot(data, aes(x = Period, y = !!sym(y_var))) +
      geom_line() +
      geom_point() +
      ggtitle(title) +
      xlab("Period") +
      ylab(y_label) +
      plot_theme
  }
  
  output$plot_K <- renderPlot({ make_plot(results(), "K", "Capital (K) Over Time", "Capital (K)") }, res = 100)
  output$plot_Y <- renderPlot({ make_plot(results(), "Y", "Output (Y) Over Time", "Output (Y)") }, res = 100)
  output$plot_delta_k <- renderPlot({ make_plot(results(), "delta_k", "Change in Capital (Δk) Over Time", "Change in Capital (Δk)") }, res = 100)
  output$plot_little_k <- renderPlot({ make_plot(results(), "little_k", "Capital Efficiency Units", "Capital Efficiency Units (little_k)") }, res = 100)
  
  output$plot_log_L <- renderPlot({ make_plot(results(), "log_L", "Log/ratio scale of Labor (L)", "Log of Labor (L)") }, res = 100)
  output$plot_log_K <- renderPlot({ make_plot(results(), "log_K", "Log/ratio scale of Capital (K)", "Log of Capital (K)") }, res = 100)
  output$plot_log_Y <- renderPlot({ make_plot(results(), "log_Y", "Log of Output (Y)", "Log of Output (Y)") }, res = 100)
  output$plot_log_A <- renderPlot({ make_plot(results(), "log_A", "Log/ratio scale of TFP (A)", "Log of TFP (A)") }, res = 100)
  #  output$plot_delta_k_change <- renderPlot({ make_plot(results(), "delta_k_change", "percent change of delta_k", "%change of delta_k") }, res = 100)
  
  
  # Download handler for CSV
  output$downloadData <- downloadHandler(
    filename = function() {
      paste0("results_", Sys.Date(), ".csv")
    },
    content = function(file) {
      write.csv(results(), file, row.names = FALSE)
    }
  )
  
  # Download handler for all plots
  output$downloadPlots <- downloadHandler(
    filename = function() {
      paste0("plots_", Sys.Date(), ".zip")
    },
    content = function(file) {
      # temp file storage but new shiny update change the way file donwloads happen so this might not be needed now
      temp_dir <- tempdir()
      file_paths <- c()
      
      # ggplot loop
      df <- results()
      plots <- list(
        plot_K = make_plot(df, "K", "Capital (K) Over Time", "Capital (K)"),
        plot_Y = make_plot(df, "Y", "Output (Y) Over Time", "Output (Y)"),
        plot_delta_k = make_plot(df, "delta_k", "Change in Capital (Δk) Over Time", "Change in Capital (Δk)"),
        plot_little_k = make_plot(df, "little_k", "Capital Efficiency Units", "Capital Efficiency Units (little_k)"),
        plot_log_L = make_plot(df, "log_L", "Log of Labor (L) Over Time", "Log of Labor (L)"),  # Add log plots
        plot_log_K = make_plot(df, "log_K", "Log of Capital (K) Over Time", "Log of Capital (K)"),
        plot_log_Y = make_plot(df, "log_Y", "Log of Output (Y) Over Time", "Log of Output (Y)"),
        plot_log_A = make_plot(df, "log_A", "Log/ratio scale of TFP (A)", "Log of TFP (A)")
        #        plot_delta_k_change = make_plot(df, "delta_k_change", "% change of delta_k", "% change of delta_k")
      )
      
      # Save each plot to a PNG
      for (plot_name in names(plots)) {
        plot_file <- file.path(temp_dir, paste0(plot_name, ".png"))
        ggsave(plot_file, plots[[plot_name]], device = "png", width = 6, height = 4, dpi = 90, bg = "white")
        file_paths <- c(file_paths, plot_file)
      }
      
      # Zip all the png plots together
      zipr(zipfile = file, files = file_paths)
    }
  )
}

# Run the application
shinyApp(ui = ui, server = server)






```


This is a next model after making some updates and adding the new data frame

# spacer

```{r}
library(shiny)
library(ggplot2)
library(DT)     # for interactive table
library(zip)    # to create ZIP files in download handler
library(bslib)

# use reactive expressions to avoid re calculating or re fetching data when not needed.

# Define UI
ui <- page_sidebar(
  title = "Solow-Romer Macro Simulation",
  sidebar = sidebar(  # Sidebar content: all the input controls
    width = 600, # edit sidebar width. This is not friendly with smaller screens
    h4("Simulation Parameters"),
    sliderInput("Simulation_Period", "Simulation Period (yrs)", 
                min = 20, max = 150, value = 50, step = 1),
    sliderInput("s", "Savings Rate (s)", min = 0, max = 1, value = 0.2, step = 0.01),
    sliderInput("delta", "Depreciation Rate (delta)", min = 0, max = .5, value = 0.15, step = 0.01),
    sliderInput("n", "n", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("z", "Parameter z", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("l", "Parameter l", min = 0, max = 1, value = 0.1, step = 0.01),
    selectInput("A", "Initial value for A", choices = c(1, 100, 1000), selected = 1), # 343
    selectInput("L", "Initial value for L", choices = c(1, 100, 1000), selected = 1), # 343
    h4("Experiments"),
    selectInput("param_name", "Quantitative exp (s, delta, n, z, l)", 
                choices = c("s", "delta", "n", "z", "l"),
                selected = "s"),
    numericInput("new_value", "New Value", value = 0, step = 0.01),
    numericInput("start_period", "Start Period", value = 5, step = 1),
    numericInput("length", "Length of Effect", value = 5, step = 1),
    actionButton("add_experiment", "Add Experiment"),
    actionButton("simulate", "Simulate"),
    h4("Download Results"),
    DTOutput("experimentsTable"), # Show experiments in a DT table so we can add Delete buttons
    downloadButton("downloadPlots", "Download All Plots as PNG (ZIP)"),
    downloadButton("downloadData", "Download Data as CSV")
  ),
  
  mainPanel(  # Use mainPanel for the content
    tabsetPanel( # use tabs to organize the outputs
      tabPanel("Plots",
               div(style = "width: 1800px; margin: auto;",  # Wrapping fluidrow's with fixed width
                   fluidRow(
                     column(6, plotOutput("plot_K", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_Y", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_delta_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_little_k", width = "900px", height = "600px"))
                   )
               ),
      ),
      tabPanel("Log/Ratio scale",
               div(style = "width: 1800px; margin: auto;",
                   fluidRow(
                     column(6, plotOutput("plot_log_L", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_K", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_log_Y", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_A", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Table", tableOutput("resultsTable")),
      tabPanel("No Experiments", tableOutput("resultsNoExpTable")) # this adds inital data frame
    )
  )
)

# Define server logic
server <- function(input, output, session) {
  experiments <- reactiveVal(
    data.frame(
      param = character(0),
      new_value = numeric(0),
      start_period = integer(0),
      length = integer(0),
      stringsAsFactors = FALSE
    )
  )
  
  # Add experiment: simply append a new row
  # need to rename this so they take up less space in the sidebar
  observeEvent(input$add_experiment, {
    new_experiment <- data.frame(
      param        = input$param_name,
      new_value    = input$new_value,
      start_period = input$start_period,
      length       = input$length,
      stringsAsFactors = FALSE
    )
    experiments(rbind(experiments(), new_experiment))
  })
  
  # Render experiments table with Delete buttons
  output$experimentsTable <- renderDT({
    exps <- experiments()
    if (nrow(exps) == 0) return(NULL)
    
    # Create a column of actionButtons, each referencing its row index i
    deleteButtons <- sapply(seq_len(nrow(exps)), function(i) {
      as.character(
        actionButton(
          inputId = paste0("delete_row_", i),
          label = "Delete",
          class = "btn btn-danger btn-sm",
          # This sets the input$delete_row to something like "delete_row_3"
          onclick = 'Shiny.setInputValue(\"delete_row\", this.id, {priority: \"event\"})'
        )
      )
    })
    
    exps$Delete <- deleteButtons
    
    datatable(
      exps,
      escape = FALSE,        # Must be FALSE to render the HTML in the Delete column
      selection = "none",
      options = list(pageLength = 5)
    )
  }, server = FALSE)
  
  # Observe which row's Delete button was clicked
  observeEvent(input$delete_row, {
    # Extract row index from the ID string "delete_row_X"
    row_str <- gsub("delete_row_", "", input$delete_row)
    row_num <- as.numeric(row_str)
    
    exps <- experiments()
    # Check row_num validity, then remove that row
    if (!is.na(row_num) && row_num >= 1 && row_num <= nrow(exps)) {
      exps <- exps[-row_num, ]
      experiments(exps)
    }
  })
  
  # Main simulation (calculus-intensive) - structure unchanged
  results <- eventReactive(input$simulate, {
    
    # Ensure at least one experiment is added before simulating update 344
    if (nrow(experiments()) == 0) {
      showModal(modalDialog(
        title = "Error",
        "Please add at least one experiment to define parameter changes before running the simulation.",
        easyClose = TRUE,
        footer = NULL
      ))
      return(NULL)
    }
    
    # Convert inputs A and L to numeric update: 343
    A <- as.numeric(input$A) # 343
    L <- as.numeric(input$L) # 343
    
    # Initialize parameters
    num_periods <- input$Simulation_Period + 1
    s <- input$s
    delta <- input$delta
    n <- input$n
    z <- input$z
    l <- input$l
    
    # Calculate k_star_initial
    k_star_initial <- ((s / (delta + n + z * l)) ** 1.5) * (1 - l)
    
    params <- data.frame(
      Period = 0:(num_periods - 1),
      s = rep(s, num_periods),
      delta = rep(delta, num_periods),
      n = rep(n, num_periods),
      z = rep(z, num_periods),
      l = rep(l, num_periods),
      `delta_k` = rep(0.0, num_periods),
      
      # I'm changing k_star to little_k. little_k is capital efficiency units
      # this is doing little_k = delta_k + little_k_t-1.   
      `little_k` = rep(k_star_initial, num_periods), # so this is only k* for first period but it is just little k. k* is only when economy is at steady state. steady state is when s_bar * Y = d_bar * K or when investment minus depreciation equal zero. 
      A = rep(A, num_periods),
      L = rep(L, num_periods),
      K = rep(0.0, num_periods),
      Y = rep(0.0, num_periods)
    )
    
    # Apply quantitative experiments
    exps <- experiments()
    for (exp in 1:nrow(exps)) {
      start <- exps$start_period[exp] + 1
      end   <- min(start + exps$length[exp] - 1, num_periods - 1)
      # Overwrite that parameter in [start, end]
      params[start:end, exps$param[exp]] <- exps$new_value[exp]
    }
    
    # Calculation functions
    calculate_delta_k <- function(df, row_index) {
      if (row_index == 1) {
        return(0.0)
      } else {
        delta_k <- df[row_index, 's'] * ((1 - df[row_index, 'l']) ^ (2/3)) * 
          (df[row_index - 1, 'little_k'] ^ (1/3)) -
          (df[row_index, 'z'] * df[row_index, 'l'] + df[row_index, 'n'] + df[row_index, 'delta']) * 
          df[row_index - 1, 'little_k']
        return(delta_k)
      }
    }
    
    calculate_little_k <- function(df, row_index, k_star_initial) {
      if (row_index == 1) {
        little_k_value <- k_star_initial
      } else {
        little_k_value <- (df[row_index - 1, 'little_k'] + df[row_index, 'delta_k'])
      }
      return(little_k_value)
    }
    
    calculate_A <- function(df, row_index, initial_A) {
      if (row_index == 1) {
        return(initial_A)
      } else {
        A <- df[row_index - 1, 'A'] * (1 + df[row_index, 'z'] * df[row_index, 'l'])
        return(A)
      }
    }
    
    calculate_L <- function(df, row_index, initial_L) {
      if (row_index == 1) {
        return(initial_L)
      } else {
        L <- df[row_index - 1, 'L'] * (1 + df[row_index, 'n'])
        return(L)
      }
    }
    
    calculate_K <- function(df, row_index) {
      K <- df[row_index, 'little_k'] * df[row_index, 'L'] * df[row_index, 'A']
      return(K) # first variable that starts to give a floating-point rounding error compared to excel model
    }
    
    calculate_Y <- function(df, row_index) {
      Y <- (1 - df[row_index, 'l']) ^ (2/3) *
        df[row_index, 'K'] ^ (1/3) *
        (df[row_index, 'A'] * df[row_index, 'L']) ^ (2/3)
      return(Y)
    }
    
    
    # Apply calculations and the order matters so re arranging this randomly will lead to different calculations results and or errors
    # so i can get rid of my calculations up there and just do them down here
    # it will make r faster
    # concerns for the row index loop, and initial params. I mean this is the code that calculates them so either way this code is executing that calculation
    # so might as well have here to make it faster
    for (i in 1:num_periods) {
      params$`delta_k`[i] <- calculate_delta_k(params, i)
      params$`little_k`[i]      <- calculate_little_k(params, i, k_star_initial)
      params$A[i]         <- calculate_A(params, i, A)
      params$L[i]         <- calculate_L(params, i, L)
      params$K[i]         <- calculate_K(params, i)
      params$Y[i]         <- calculate_Y(params, i)
    }
    
    params$log_L <- log(params$L)  # Vectorized
    params$log_K <- log(params$K)  # this 3 log calculations don't need to be above like the rest. only the ones that are dependent on each other.
    params$log_Y <- log(params$Y)  # so Y does need to be above. giving the for i is all done in order which it should be or else the log calculations will return error.
    params$log_A <- log(params$A)  # when adding calc here, then add to tabpanel, and both plot codes.
    
    params
  })
  
# adding code for intial data frame -------------------------------
# this is long but it is avoiding making changes to my main code. I can later concise

  # New simulation reactive expression without applying experiments
  results_no_exp <- eventReactive(input$simulate, {
    
    # Convert inputs A and L to numeric (as in the original simulation)
    A <- as.numeric(input$A)
    L <- as.numeric(input$L)
    
    # Initialize parameters
    num_periods <- input$Simulation_Period + 1
    s <- input$s
    delta <- input$delta
    n <- input$n
    z <- input$z
    l <- input$l
    
    # Calculate k_star_initial
    k_star_initial <- ((s / (delta + n + z * l)) ** 1.5) * (1 - l)
    
    params_no_exp <- data.frame(
      Period = 0:(num_periods - 1),
      s = rep(s, num_periods),
      delta = rep(delta, num_periods),
      n = rep(n, num_periods),
      z = rep(z, num_periods),
      l = rep(l, num_periods),
      delta_k = rep(0.0, num_periods),
      
      # little_k is initialized to k_star_initial
      little_k = rep(k_star_initial, num_periods),
      A = rep(A, num_periods),
      L = rep(L, num_periods),
      K = rep(0.0, num_periods),
      Y = rep(0.0, num_periods)
    )
    
    # *** Note: No experiment modifications are applied here ***
    # (In your original "results", you apply experiments here:
    #  for (exp in 1:nrow(exps)) { ... } )
    
    # Define the calculation functions (same as in your original code)
    calculate_delta_k <- function(df, row_index) {
      if (row_index == 1) {
        return(0.0)
      } else {
        delta_k <- df[row_index, 's'] * ((1 - df[row_index, 'l']) ^ (2/3)) *
          (df[row_index - 1, 'little_k'] ^ (1/3)) -
          (df[row_index, 'z'] * df[row_index, 'l'] + df[row_index, 'n'] + df[row_index, 'delta']) *
          df[row_index - 1, 'little_k']
        return(delta_k)
      }
    }
    
    calculate_little_k <- function(df, row_index, k_star_initial) {
      if (row_index == 1) {
        little_k_value <- k_star_initial
      } else {
        little_k_value <- (df[row_index - 1, 'little_k'] + df[row_index, 'delta_k'])
      }
      return(little_k_value)
    }
    
    calculate_A <- function(df, row_index, initial_A) {
      if (row_index == 1) {
        return(initial_A)
      } else {
        A <- df[row_index - 1, 'A'] * (1 + df[row_index, 'z'] * df[row_index, 'l'])
        return(A)
      }
    }
    
    calculate_L <- function(df, row_index, initial_L) {
      if (row_index == 1) {
        return(initial_L)
      } else {
        L <- df[row_index - 1, 'L'] * (1 + df[row_index, 'n'])
        return(L)
      }
    }
    
    calculate_K <- function(df, row_index) {
      K <- df[row_index, 'little_k'] * df[row_index, 'L'] * df[row_index, 'A']
      return(K)
    }
    
    calculate_Y <- function(df, row_index) {
      Y <- (1 - df[row_index, 'l']) ^ (2/3) *
        df[row_index, 'K'] ^ (1/3) *
        (df[row_index, 'A'] * df[row_index, 'L']) ^ (2/3)
      return(Y)
    }
    
    # Loop through each period to perform the calculations
    for (i in 1:num_periods) {
      params_no_exp$delta_k[i] <- calculate_delta_k(params_no_exp, i)
      params_no_exp$little_k[i] <- calculate_little_k(params_no_exp, i, k_star_initial)
      params_no_exp$A[i] <- calculate_A(params_no_exp, i, A)
      params_no_exp$L[i] <- calculate_L(params_no_exp, i, L)
      params_no_exp$K[i] <- calculate_K(params_no_exp, i)
      params_no_exp$Y[i] <- calculate_Y(params_no_exp, i)
    }
    
    # Add log variables (as before)
    params_no_exp$log_L <- log(params_no_exp$L)
    params_no_exp$log_K <- log(params_no_exp$K)
    params_no_exp$log_Y <- log(params_no_exp$Y)
    params_no_exp$log_A <- log(params_no_exp$A)
    
    params_no_exp
  })
  
# end of code for inital data frame ---------------------------------------
  
  # Render final results table
  output$resultsTable <- renderTable({
    results_df <- results()
    results_df
  }, rownames = FALSE)

# this is part of making inital data frame -----------------
  output$resultsNoExpTable <- renderTable({
    results_no_exp()
  }, rownames = FALSE)
# end of code for intial data frame -------------------------------
  
  # Plot code
  plot_theme <- theme_bw() +  # theme_bw() = light theme
    theme(plot.title = element_text(hjust = 0.5),
          axis.title = element_text(size = 12),
          axis.text = element_text(size = 10),
          panel.grid.major = element_line(color = "grey80"), # Lighter grid lines
          panel.grid.minor = element_blank(),
          strip.background = element_rect(fill = "grey90", color = "grey90")) 
  
  make_plot <- function(data, y_var, title, y_label) {
    ggplot(data, aes(x = Period, y = !!sym(y_var))) +
      geom_line() +
      geom_point() +
      ggtitle(title) +
      xlab("Period") +
      ylab(y_label) +
      plot_theme
  }
  
  output$plot_K <- renderPlot({ make_plot(results(), "K", "Capital (K) Over Time", "Capital (K)") }, res = 100)
  output$plot_Y <- renderPlot({ make_plot(results(), "Y", "Output (Y) Over Time", "Output (Y)") }, res = 100)
  output$plot_delta_k <- renderPlot({ make_plot(results(), "delta_k", "Change in Capital (Δk) Over Time", "Change in Capital (Δk)") }, res = 100)
  output$plot_little_k <- renderPlot({ make_plot(results(), "little_k", "Capital Efficiency Units", "Capital Efficiency Units (little_k)") }, res = 100)
  
  output$plot_log_L <- renderPlot({ make_plot(results(), "log_L", "Log/ratio scale of Labor (L)", "Log of Labor (L)") }, res = 100)
  output$plot_log_K <- renderPlot({ make_plot(results(), "log_K", "Log/ratio scale of Capital (K)", "Log of Capital (K)") }, res = 100)
  output$plot_log_Y <- renderPlot({ make_plot(results(), "log_Y", "Log of Output (Y)", "Log of Output (Y)") }, res = 100)
  output$plot_log_A <- renderPlot({ make_plot(results(), "log_A", "Log/ratio scale of TFP (A)", "Log of TFP (A)") }, res = 100)
  #  output$plot_delta_k_change <- renderPlot({ make_plot(results(), "delta_k_change", "percent change of delta_k", "%change of delta_k") }, res = 100)
  
  
  # Download handler for CSV
  output$downloadData <- downloadHandler(
    filename = function() {
      paste0("results_", Sys.Date(), ".csv")
    },
    content = function(file) {
      write.csv(results(), file, row.names = FALSE)
    }
  )
  
  # Download handler for all plots
  output$downloadPlots <- downloadHandler(
    filename = function() {
      paste0("plots_", Sys.Date(), ".zip")
    },
    content = function(file) {
      # temp file storage but new shiny update change the way file donwloads happen so this might not be needed now
      temp_dir <- tempdir()
      file_paths <- c()
      
      # ggplot loop
      df <- results()
      plots <- list(
        plot_K = make_plot(df, "K", "Capital (K) Over Time", "Capital (K)"),
        plot_Y = make_plot(df, "Y", "Output (Y) Over Time", "Output (Y)"),
        plot_delta_k = make_plot(df, "delta_k", "Change in Capital (Δk) Over Time", "Change in Capital (Δk)"),
        plot_little_k = make_plot(df, "little_k", "Capital Efficiency Units", "Capital Efficiency Units (little_k)"),
        plot_log_L = make_plot(df, "log_L", "Log of Labor (L) Over Time", "Log of Labor (L)"),  # Add log plots
        plot_log_K = make_plot(df, "log_K", "Log of Capital (K) Over Time", "Log of Capital (K)"),
        plot_log_Y = make_plot(df, "log_Y", "Log of Output (Y) Over Time", "Log of Output (Y)"),
        plot_log_A = make_plot(df, "log_A", "Log/ratio scale of TFP (A)", "Log of TFP (A)")
        #        plot_delta_k_change = make_plot(df, "delta_k_change", "% change of delta_k", "% change of delta_k")
      )
      
      # Save each plot to a PNG
      for (plot_name in names(plots)) {
        plot_file <- file.path(temp_dir, paste0(plot_name, ".png"))
        ggsave(plot_file, plots[[plot_name]], device = "png", width = 6, height = 4, dpi = 90, bg = "white")
        file_paths <- c(file_paths, plot_file)
      }
      
      # Zip all the png plots together
      zipr(zipfile = file, files = file_paths)
    }
  )
}

# Run the application
shinyApp(ui = ui, server = server)

```


# version 1
I'm transitioning to using version numbers to differentiate between versions. 
version1 can also be v1. 

# spacer

```{r}
library(shiny)
library(ggplot2)
library(DT)     # for interactive table
library(zip)    # to create ZIP files in download handler
library(bslib)
# version1
# use reactive expressions to avoid re calculating or re fetching data when not needed.

# Define UI
ui <- page_sidebar(
  title = "Solow-Romer Macro Simulation",
  sidebar = sidebar(  # Sidebar content: all the input controls
    width = 600, # edit sidebar width. This is not friendly with smaller screens
    h4("Simulation Parameters"),
    sliderInput("Simulation_Period", "Simulation Period (yrs)", 
                min = 20, max = 150, value = 50, step = 1),
    sliderInput("s", "Savings Rate (s)", min = 0, max = 1, value = 0.2, step = 0.01),
    sliderInput("delta", "Depreciation Rate (delta)", min = 0, max = .5, value = 0.15, step = 0.01),
    sliderInput("n", "n", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("z", "Parameter z", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("l", "Parameter l", min = 0, max = 1, value = 0.1, step = 0.01),
    selectInput("A", "Initial value for A", choices = c(1, 100, 1000), selected = 1), # 343
    selectInput("L", "Initial value for L", choices = c(1, 100, 1000), selected = 1), # 343
    h4("Experiments"),
    selectInput("param_name", "Quantitative exp (s, delta, n, z, l)", 
                choices = c("s", "delta", "n", "z", "l"),
                selected = "s"),
    numericInput("new_value", "New Value", value = 0, step = 0.01),
    numericInput("start_period", "Start Period", value = 5, step = 1),
    numericInput("length", "Length of Effect", value = 5, step = 1),
    actionButton("add_experiment", "Add Experiment"),
    actionButton("simulate", "Simulate"),
    h4("Download Results"),
    DTOutput("experimentsTable"), # Show experiments in a DT table so we can add Delete buttons
    downloadButton("downloadPlots", "Download All Plots as PNG (ZIP)"),
    downloadButton("downloadData", "Download Data as CSV")
  ),
  
  mainPanel(  # Use mainPanel for the content
    tabsetPanel( # use tabs to organize the outputs
      tabPanel("Plots",
               div(style = "width: 1800px; margin: auto;",  # Wrapping fluidrow's with fixed width
                   fluidRow(
                     column(6, plotOutput("plot_K", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_Y", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_delta_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_little_k", width = "900px", height = "600px"))
                   )
               ),
      ),
      tabPanel("Log/Ratio scale",
               div(style = "width: 1800px; margin: auto;",
                   fluidRow(
                     column(6, plotOutput("plot_log_L", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_K", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_log_Y", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_A", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Table", tableOutput("resultsTable")),
      tabPanel("No Experiments", tableOutput("resultsNoExpTable")) # this adds inital data frame
    )
  )
)

# Define server logic
server <- function(input, output, session) {
  experiments <- reactiveVal(
    data.frame(
      param = character(0),
      new_value = numeric(0),
      start_period = integer(0),
      length = integer(0),
      stringsAsFactors = FALSE
    )
  )
  
  # Add experiment: simply append a new row
  # need to rename this so they take up less space in the sidebar
  observeEvent(input$add_experiment, {
    new_experiment <- data.frame(
      param        = input$param_name,
      new_value    = input$new_value,
      start_period = input$start_period,
      length       = input$length,
      stringsAsFactors = FALSE
    )
    experiments(rbind(experiments(), new_experiment))
  })
  
  # Render experiments table with Delete buttons
  output$experimentsTable <- renderDT({
    exps <- experiments()
    if (nrow(exps) == 0) return(NULL)
    
    # Create a column of actionButtons, each referencing its row index i
    deleteButtons <- sapply(seq_len(nrow(exps)), function(i) {
      as.character(
        actionButton(
          inputId = paste0("delete_row_", i),
          label = "Delete",
          class = "btn btn-danger btn-sm",
          # This sets the input$delete_row to something like "delete_row_3"
          onclick = 'Shiny.setInputValue(\"delete_row\", this.id, {priority: \"event\"})'
        )
      )
    })
    
    exps$Delete <- deleteButtons
    
    datatable(
      exps,
      escape = FALSE,        # Must be FALSE to render the HTML in the Delete column
      selection = "none",
      options = list(pageLength = 5)
    )
  }, server = FALSE)
  
  # Observe which row's Delete button was clicked
  observeEvent(input$delete_row, {
    # Extract row index from the ID string "delete_row_X"
    row_str <- gsub("delete_row_", "", input$delete_row)
    row_num <- as.numeric(row_str)
    
    exps <- experiments()
    # Check row_num validity, then remove that row
    if (!is.na(row_num) && row_num >= 1 && row_num <= nrow(exps)) {
      exps <- exps[-row_num, ]
      experiments(exps)
    }
  })
  
  # Main simulation (calculus-intensive) - structure unchanged
  results <- eventReactive(input$simulate, {
    
    # Ensure at least one experiment is added before simulating update 344
    if (nrow(experiments()) == 0) {
      showModal(modalDialog(
        title = "Error",
        "Please add at least one experiment to define parameter changes before running the simulation.",
        easyClose = TRUE,
        footer = NULL
      ))
      return(NULL)
    }
    
    # Convert inputs A and L to numeric update: 343
    A <- as.numeric(input$A) # 343
    L <- as.numeric(input$L) # 343
    
    # Initialize parameters
    num_periods <- input$Simulation_Period + 1
    s <- input$s
    delta <- input$delta
    n <- input$n
    z <- input$z
    l <- input$l
    
    # Calculate k_star_initial
    k_star_initial <- ((s / (delta + n + z * l)) ** 1.5) * (1 - l)
    
    params <- data.frame(
      Period = 0:(num_periods - 1),
      s = rep(s, num_periods),
      delta = rep(delta, num_periods),
      n = rep(n, num_periods),
      z = rep(z, num_periods),
      l = rep(l, num_periods),
      `delta_k` = rep(0.0, num_periods),
      
      # I'm changing k_star to little_k. little_k is capital efficiency units
      # this is doing little_k = delta_k + little_k_t-1.   
      `little_k` = rep(k_star_initial, num_periods), # so this is only k* for first period but it is just little k. k* is only when economy is at steady state. steady state is when s_bar * Y = d_bar * K or when investment minus depreciation equal zero. 
      A = rep(A, num_periods),
      L = rep(L, num_periods),
      K = rep(0.0, num_periods),
      Y = rep(0.0, num_periods)
    )
    
    # Apply quantitative experiments
    exps <- experiments()
    for (exp in 1:nrow(exps)) {
      start <- exps$start_period[exp] + 1
      end   <- min(start + exps$length[exp] - 1, num_periods) # i remove the -1 in version2 but did the same here.
      # Overwrite that parameter in [start, end]
      params[start:end, exps$param[exp]] <- exps$new_value[exp]
    }
    
    # Calculation functions
    calculate_delta_k <- function(df, row_index) {
      if (row_index == 1) {
        return(0.0)
      } else {
        delta_k <- df[row_index, 's'] * ((1 - df[row_index, 'l']) ^ (2/3)) * 
          (df[row_index - 1, 'little_k'] ^ (1/3)) -
          (df[row_index, 'z'] * df[row_index, 'l'] + df[row_index, 'n'] + df[row_index, 'delta']) * 
          df[row_index - 1, 'little_k']
        return(delta_k)
      }
    }
    
    calculate_little_k <- function(df, row_index, k_star_initial) {
      if (row_index == 1) {
        little_k_value <- k_star_initial
      } else {
        little_k_value <- (df[row_index - 1, 'little_k'] + df[row_index, 'delta_k'])
      }
      return(little_k_value)
    }
    
    calculate_A <- function(df, row_index, initial_A) {
      if (row_index == 1) {
        return(initial_A)
      } else {
        A <- df[row_index - 1, 'A'] * (1 + df[row_index, 'z'] * df[row_index, 'l'])
        return(A)
      }
    }
    
    calculate_L <- function(df, row_index, initial_L) {
      if (row_index == 1) {
        return(initial_L)
      } else {
        L <- df[row_index - 1, 'L'] * (1 + df[row_index, 'n'])
        return(L)
      }
    }
    
    calculate_K <- function(df, row_index) {
      K <- df[row_index, 'little_k'] * df[row_index, 'L'] * df[row_index, 'A']
      return(K) # first variable that starts to give a floating-point rounding error compared to excel model
    }
    
    calculate_Y <- function(df, row_index) {
      Y <- (1 - df[row_index, 'l']) ^ (2/3) *
        df[row_index, 'K'] ^ (1/3) *
        (df[row_index, 'A'] * df[row_index, 'L']) ^ (2/3)
      return(Y)
    }
    
    
    # Apply calculations and the order matters so re arranging this randomly will lead to different calculations results and or errors
    # so i can get rid of my calculations up there and just do them down here
    # it will make r faster
    # concerns for the row index loop, and initial params. I mean this is the code that calculates them so either way this code is executing that calculation
    # so might as well have here to make it faster
    for (i in 1:num_periods) {
      params$`delta_k`[i] <- calculate_delta_k(params, i)
      params$`little_k`[i]      <- calculate_little_k(params, i, k_star_initial)
      params$A[i]         <- calculate_A(params, i, A)
      params$L[i]         <- calculate_L(params, i, L)
      params$K[i]         <- calculate_K(params, i)
      params$Y[i]         <- calculate_Y(params, i)
    }
    
    params$log_L <- log(params$L)  # Vectorized
    params$log_K <- log(params$K)  # this 3 log calculations don't need to be above like the rest. only the ones that are dependent on each other.
    params$log_Y <- log(params$Y)  # so Y does need to be above. giving the for i is all done in order which it should be or else the log calculations will return error.
    params$log_A <- log(params$A)  # when adding calc here, then add to tabpanel, and both plot codes.
    
    params
  })
  
  # adding code for intial data frame -------------------------------
  # this is long but it is avoiding making changes to my main code. I can later concise
  
  # New simulation reactive expression without applying experiments
  results_no_exp <- eventReactive(input$simulate, {
    
    # Convert inputs A and L to numeric (as in the original simulation)
    A <- as.numeric(input$A)
    L <- as.numeric(input$L)
    
    # Initialize parameters
    num_periods <- input$Simulation_Period + 1
    s <- input$s
    delta <- input$delta
    n <- input$n
    z <- input$z
    l <- input$l
    
    # Calculate k_star_initial
    k_star_initial <- ((s / (delta + n + z * l)) ** 1.5) * (1 - l)
    
    params_no_exp <- data.frame(
      Period = 0:(num_periods - 1),
      s = rep(s, num_periods),
      delta = rep(delta, num_periods),
      n = rep(n, num_periods),
      z = rep(z, num_periods),
      l = rep(l, num_periods),
      delta_k = rep(0.0, num_periods),
      
      # little_k is initialized to k_star_initial
      little_k = rep(k_star_initial, num_periods),
      A = rep(A, num_periods),
      L = rep(L, num_periods),
      K = rep(0.0, num_periods),
      Y = rep(0.0, num_periods)
    )
    
    # *** Note: No experiment modifications are applied here ***
    # (In your original "results", you apply experiments here:
    #  for (exp in 1:nrow(exps)) { ... } )
    
    # Define the calculation functions (same as in your original code)
    calculate_delta_k <- function(df, row_index) {
      if (row_index == 1) {
        return(0.0)
      } else {
        delta_k <- df[row_index, 's'] * ((1 - df[row_index, 'l']) ^ (2/3)) *
          (df[row_index - 1, 'little_k'] ^ (1/3)) -
          (df[row_index, 'z'] * df[row_index, 'l'] + df[row_index, 'n'] + df[row_index, 'delta']) *
          df[row_index - 1, 'little_k']
        return(delta_k)
      }
    }
    
    calculate_little_k <- function(df, row_index, k_star_initial) {
      if (row_index == 1) {
        little_k_value <- k_star_initial
      } else {
        little_k_value <- (df[row_index - 1, 'little_k'] + df[row_index, 'delta_k'])
      }
      return(little_k_value)
    }
    
    calculate_A <- function(df, row_index, initial_A) {
      if (row_index == 1) {
        return(initial_A)
      } else {
        A <- df[row_index - 1, 'A'] * (1 + df[row_index, 'z'] * df[row_index, 'l'])
        return(A)
      }
    }
    
    calculate_L <- function(df, row_index, initial_L) {
      if (row_index == 1) {
        return(initial_L)
      } else {
        L <- df[row_index - 1, 'L'] * (1 + df[row_index, 'n'])
        return(L)
      }
    }
    
    calculate_K <- function(df, row_index) {
      K <- df[row_index, 'little_k'] * df[row_index, 'L'] * df[row_index, 'A']
      return(K)
    }
    
    calculate_Y <- function(df, row_index) {
      Y <- (1 - df[row_index, 'l']) ^ (2/3) *
        df[row_index, 'K'] ^ (1/3) *
        (df[row_index, 'A'] * df[row_index, 'L']) ^ (2/3)
      return(Y)
    }
    
    # Loop through each period to perform the calculations
    for (i in 1:num_periods) {
      params_no_exp$delta_k[i] <- calculate_delta_k(params_no_exp, i)
      params_no_exp$little_k[i] <- calculate_little_k(params_no_exp, i, k_star_initial)
      params_no_exp$A[i] <- calculate_A(params_no_exp, i, A)
      params_no_exp$L[i] <- calculate_L(params_no_exp, i, L)
      params_no_exp$K[i] <- calculate_K(params_no_exp, i)
      params_no_exp$Y[i] <- calculate_Y(params_no_exp, i)
    }
    
    # Add log variables (as before)
    params_no_exp$log_L <- log(params_no_exp$L)
    params_no_exp$log_K <- log(params_no_exp$K)
    params_no_exp$log_Y <- log(params_no_exp$Y)
    params_no_exp$log_A <- log(params_no_exp$A)
    
    params_no_exp
  })
  
  # end of code for inital data frame ---------------------------------------
  
  # Render final results table
  output$resultsTable <- renderTable({
    results_df <- results()
    results_df
  }, rownames = FALSE)
  
  # this is part of making inital data frame -----------------
  output$resultsNoExpTable <- renderTable({
    results_no_exp()
  }, rownames = FALSE)
  # end of code for intial data frame -------------------------------
  
  # Plot code
  plot_theme <- theme_bw() +  # theme_bw() = light theme
    theme(plot.title = element_text(hjust = 0.5),
          axis.title = element_text(size = 12),
          axis.text = element_text(size = 10),
          panel.grid.major = element_line(color = "grey80"), # Lighter grid lines
          panel.grid.minor = element_blank(),
          strip.background = element_rect(fill = "grey90", color = "grey90")) 
  
  make_plot <- function(data, y_var, title, y_label) {
    ggplot(data, aes(x = Period, y = !!sym(y_var))) +
      geom_line() +
      geom_point() +
      ggtitle(title) +
      xlab("Period") +
      ylab(y_label) +
      plot_theme
  }
  
  output$plot_K <- renderPlot({ make_plot(results(), "K", "Capital (K) Over Time", "Capital (K)") }, res = 100)
  output$plot_Y <- renderPlot({ make_plot(results(), "Y", "Output (Y) Over Time", "Output (Y)") }, res = 100)
  output$plot_delta_k <- renderPlot({ make_plot(results(), "delta_k", "Change in Capital (Δk) Over Time", "Change in Capital (Δk)") }, res = 100)
  output$plot_little_k <- renderPlot({ make_plot(results(), "little_k", "Capital Efficiency Units", "Capital Efficiency Units (little_k)") }, res = 100)
  
  output$plot_log_L <- renderPlot({ make_plot(results(), "log_L", "Log/ratio scale of Labor (L)", "Log of Labor (L)") }, res = 100)
  output$plot_log_K <- renderPlot({ make_plot(results(), "log_K", "Log/ratio scale of Capital (K)", "Log of Capital (K)") }, res = 100)
  output$plot_log_Y <- renderPlot({ make_plot(results(), "log_Y", "Log of Output (Y)", "Log of Output (Y)") }, res = 100)
  output$plot_log_A <- renderPlot({ make_plot(results(), "log_A", "Log/ratio scale of TFP (A)", "Log of TFP (A)") }, res = 100)
  #  output$plot_delta_k_change <- renderPlot({ make_plot(results(), "delta_k_change", "percent change of delta_k", "%change of delta_k") }, res = 100)
  
  
  # Download handler for CSV
  output$downloadData <- downloadHandler(
    filename = function() {
      paste0("results_", Sys.Date(), ".csv")
    },
    content = function(file) {
      write.csv(results(), file, row.names = FALSE)
    }
  )
  
  # Download handler for all plots
  output$downloadPlots <- downloadHandler(
    filename = function() {
      paste0("plots_", Sys.Date(), ".zip")
    },
    content = function(file) {
      # temp file storage but new shiny update change the way file donwloads happen so this might not be needed now
      temp_dir <- tempdir()
      file_paths <- c()
      
      # ggplot loop
      df <- results()
      plots <- list(
        plot_K = make_plot(df, "K", "Capital (K) Over Time", "Capital (K)"),
        plot_Y = make_plot(df, "Y", "Output (Y) Over Time", "Output (Y)"),
        plot_delta_k = make_plot(df, "delta_k", "Change in Capital (Δk) Over Time", "Change in Capital (Δk)"),
        plot_little_k = make_plot(df, "little_k", "Capital Efficiency Units", "Capital Efficiency Units (little_k)"),
        plot_log_L = make_plot(df, "log_L", "Log of Labor (L) Over Time", "Log of Labor (L)"),  # Add log plots
        plot_log_K = make_plot(df, "log_K", "Log of Capital (K) Over Time", "Log of Capital (K)"),
        plot_log_Y = make_plot(df, "log_Y", "Log of Output (Y) Over Time", "Log of Output (Y)"),
        plot_log_A = make_plot(df, "log_A", "Log/ratio scale of TFP (A)", "Log of TFP (A)")
        #        plot_delta_k_change = make_plot(df, "delta_k_change", "% change of delta_k", "% change of delta_k")
      )
      
      # Save each plot to a PNG
      for (plot_name in names(plots)) {
        plot_file <- file.path(temp_dir, paste0(plot_name, ".png"))
        ggsave(plot_file, plots[[plot_name]], device = "png", width = 6, height = 4, dpi = 90, bg = "white")
        file_paths <- c(file_paths, plot_file)
      }
      
      # Zip all the png plots together
      zipr(zipfile = file, files = file_paths)
    }
  )
}

# Run the application
shinyApp(ui = ui, server = server)

```


# Version2

# spacer

```{r}

library(shiny)
library(ggplot2)
library(DT)     # for interactive table
library(zip)    # to create ZIP files in download handler
library(bslib)

# version2 or v2
# use reactive expressions to avoid re calculating or re fetching data when not needed.

# Define UI version1
ui <- page_sidebar(
  title = "Solow-Romer Macro Simulation",
  sidebar = sidebar(  # Sidebar content: all the input controls
    width = 600, # edit sidebar width. This is not friendly with smaller screens
    h4("Simulation Parameters"),
    sliderInput("Simulation_Period", "Simulation Period (yrs)", 
                min = 20, max = 150, value = 50, step = 1),
    sliderInput("s", "Savings Rate (s)", min = 0, max = 1, value = 0.2, step = 0.01),
    sliderInput("delta", "Depreciation Rate (delta)", min = 0, max = .5, value = 0.15, step = 0.01),
    sliderInput("n", "n", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("z", "Parameter z", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("l", "Parameter l", min = 0, max = 1, value = 0.1, step = 0.01),
    selectInput("A", "Initial value for A", choices = c(1, 100, 1000), selected = 1), # 343
    selectInput("L", "Initial value for L", choices = c(1, 100, 1000), selected = 1), # 343
    h4("Experiments"),
    selectInput("param_name", "Quantitative exp (s, delta, n, z, l)", 
                choices = c("s", "delta", "n", "z", "l"),
                selected = "s"),
    numericInput("new_value", "New Value", value = 0, step = 0.01),
    numericInput("start_period", "Start Period", value = 5, step = 1),
    numericInput("length", "Length of Effect", value = 5, step = 1),
    actionButton("add_experiment", "Add Experiment"),
    checkboxInput("show_no_exp", "Show Counterfactual", value = TRUE), # updated version2
    actionButton("simulate", "Simulate"),
    h4("Download Results"),
    DTOutput("experimentsTable"), # Show experiments in a DT table so we can add Delete buttons 
    downloadButton("downloadPlots", "Download All Plots as PNG (ZIP)"),
    downloadButton("downloadData", "Download Data as CSV")
  ),
  
  mainPanel(  # Use mainPanel for the content version1
    tabsetPanel( # use tabs to organize the outputs
      tabPanel("Plots",
               div(style = "width: 1800px; margin: auto;",  # Wrapping fluidrow's with fixed width
                   fluidRow(
                     column(6, plotOutput("plot_K", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_Y", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_delta_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_little_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_change_k", width = "900px", height = "600px")) # version2
                   )
               ),
      ),
      tabPanel("Log/Ratio scale",
               div(style = "width: 1800px; margin: auto;",
                   fluidRow(
                     column(6, plotOutput("plot_log_L", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_K", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_log_Y", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_A", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Table", tableOutput("resultsTable")),
      tabPanel("No Experiments", tableOutput("resultsNoExpTable")) # this adds inital data frame
    )
  )
)

# Define server logic version1
server <- function(input, output, session) {
  experiments <- reactiveVal(
    data.frame(
      param = character(0),
      new_value = numeric(0),
      start_period = integer(0),
      length = integer(0),
      stringsAsFactors = FALSE
    )
  )
  
  # Add experiment: simply append a new row
  # need to rename this so they take up less space in the sidebar
  observeEvent(input$add_experiment, { # version1
    new_experiment <- data.frame(
      param        = input$param_name,
      new_value    = input$new_value,
      start_period = input$start_period,
      length       = input$length,
      stringsAsFactors = FALSE
    )
    experiments(rbind(experiments(), new_experiment))
  })
  
  # Render experiments table with Delete buttons version1
  output$experimentsTable <- renderDT({
    exps <- experiments()
    if (nrow(exps) == 0) return(NULL)
    
    # Create a column of actionButtons, each referencing its row index i version1
    deleteButtons <- sapply(seq_len(nrow(exps)), function(i) {
      as.character(
        actionButton(
          inputId = paste0("delete_row_", i),
          label = "Delete",
          class = "btn btn-danger btn-sm",
          # This sets the input$delete_row to something like "delete_row_3"
          onclick = 'Shiny.setInputValue(\"delete_row\", this.id, {priority: \"event\"})'
        )
      )
    })
    
    exps$Delete <- deleteButtons  # version1
    
    datatable( # version1
      exps,
      escape = FALSE,        # Must be FALSE to render the HTML in the Delete column
      selection = "none",
      options = list(pageLength = 5)
    )
  }, server = FALSE) 
  
  # Observe which row's Delete button was clicked version1
  observeEvent(input$delete_row, {
    # Extract row index from the ID string "delete_row_X"
    row_str <- gsub("delete_row_", "", input$delete_row)
    row_num <- as.numeric(row_str)
    
    exps <- experiments()
    # Check row_num validity, then remove that row
    if (!is.na(row_num) && row_num >= 1 && row_num <= nrow(exps)) {
      exps <- exps[-row_num, ]
      experiments(exps)
    }
  })
  
  # Main simulation version1
  results <- eventReactive(input$simulate, {
    
    # Ensure at least one experiment is added before simulating update 344 version1
    if (nrow(experiments()) == 0) {
      showModal(modalDialog(
        title = "Error",
        "Please add at least one experiment to define parameter changes before running the simulation.",
        easyClose = TRUE,
        footer = NULL
      ))
      return(NULL)
    }
    
    # Convert inputs A and L to numeric update: 343 version1
    A <- as.numeric(input$A) # 343
    L <- as.numeric(input$L) # 343
    
    # Initialize parameters version1
    num_periods <- input$Simulation_Period + 1
    s <- input$s
    delta <- input$delta
    n <- input$n
    z <- input$z
    l <- input$l
    
    # Calculate k_star_initial # version1
    k_star_initial <- ((s / (delta + n + z * l)) ** 1.5) * (1 - l)
    
    params <- data.frame( # version1
      Period = 0:(num_periods - 1),
      s = rep(s, num_periods),
      delta = rep(delta, num_periods),
      n = rep(n, num_periods),
      z = rep(z, num_periods),
      l = rep(l, num_periods),
      `delta_k` = rep(0.0, num_periods),
      
      # I'm changing k_star to little_k. little_k is capital efficiency units
      # this is doing little_k = delta_k + little_k_t-1.   
      `little_k` = rep(k_star_initial, num_periods), # so this is only k* for first period but it is just little k. k* is only when economy is at steady state. steady state is when s_bar * Y = d_bar * K or when investment minus depreciation equal zero. 
      A = rep(A, num_periods),
      L = rep(L, num_periods),
      K = rep(0.0, num_periods),
      Y = rep(0.0, num_periods)
    )
    
    # Apply quantitative experiments # version2. remove the -1 in exps$new_value[exp]
    exps <- experiments()
    for (exp in 1:nrow(exps)) {
      start <- exps$start_period[exp] + 1
      end   <- min(start + exps$length[exp] - 1, num_periods)
      # Overwrite that parameter in [start, end]
      params[start:end, exps$param[exp]] <- exps$new_value[exp]
    }
    
    # Calculation functions
    calculate_delta_k <- function(df, row_index) { # version1
      if (row_index == 1) {
        return(0.0)
      } else {
        delta_k <- df[row_index, 's'] * ((1 - df[row_index, 'l']) ^ (2/3)) * 
          (df[row_index - 1, 'little_k'] ^ (1/3)) -
          (df[row_index, 'z'] * df[row_index, 'l'] + df[row_index, 'n'] + df[row_index, 'delta']) * 
          df[row_index - 1, 'little_k']
        return(delta_k)
      }
    }
    
    calculate_little_k <- function(df, row_index, k_star_initial) { # version1
      if (row_index == 1) {
        little_k_value <- k_star_initial
      } else {
        little_k_value <- (df[row_index - 1, 'little_k'] + df[row_index, 'delta_k'])
      }
      return(little_k_value)
    }
    
    calculate_A <- function(df, row_index, initial_A) { # version1
      if (row_index == 1) {
        return(initial_A)
      } else {
        A <- df[row_index - 1, 'A'] * (1 + df[row_index, 'z'] * df[row_index, 'l'])
        return(A)
      }
    }
    
    calculate_L <- function(df, row_index, initial_L) { # version1
      if (row_index == 1) {
        return(initial_L)
      } else {
        L <- df[row_index - 1, 'L'] * (1 + df[row_index, 'n'])
        return(L)
      }
    }
    
    calculate_K <- function(df, row_index) { # version1
      K <- df[row_index, 'little_k'] * df[row_index, 'L'] * df[row_index, 'A']
      return(K) # first variable that starts to give a floating-point rounding error compared to excel model
    }
    
    calculate_Y <- function(df, row_index) { # version1
      Y <- (1 - df[row_index, 'l']) ^ (2/3) *
        df[row_index, 'K'] ^ (1/3) *
        (df[row_index, 'A'] * df[row_index, 'L']) ^ (2/3)
      return(Y)
    }
    
    
    # Apply calculations and the order matters so re arranging this randomly will lead to different calculations results and or errors
    # so i can get rid of my calculations up there and just do them down here
    # it will make r faster
    # concerns for the row index loop, and initial params. I mean this is the code that calculates them so either way this code is executing that calculation
    # so might as well have here to make it faster
    for (i in 1:num_periods) { # version1
      params$`delta_k`[i] <- calculate_delta_k(params, i)
      params$`little_k`[i]      <- calculate_little_k(params, i, k_star_initial)
      params$A[i]         <- calculate_A(params, i, A)
      params$L[i]         <- calculate_L(params, i, L)
      params$K[i]         <- calculate_K(params, i)
      params$Y[i]         <- calculate_Y(params, i)
    }
    
    params$log_L <- log(params$L)  # Vectorized version1
    params$log_K <- log(params$K)  # this 3 log calculations don't need to be above like the rest. only the ones that are dependent on each other. version1
    params$log_Y <- log(params$Y)  # so Y does need to be above. giving the for i is all done in order which it should be or else the log calculations will return error. version1
    params$log_A <- log(params$A)  # when adding calc here, then add to tabpanel, and both plot codes. version1
    params$change_k <- params$delta_k / params$K # version2 i'm still confused here. doing delta_k / little_k is same as just delta k. Maybe Moncayo wants big K.
    
    params
  })
  
  # adding code for intial data frame -----version2--------------------------
  # this is long but it is avoiding making changes to my main code. I can later concise
  results_no_exp <- eventReactive(input$simulate, { # version2
    
    # Convert inputs A and L to numeric
    A <- as.numeric(input$A)
    L <- as.numeric(input$L)
    
    # Initialize parameters
    num_periods <- input$Simulation_Period + 1
    s <- input$s
    delta <- input$delta
    n <- input$n
    z <- input$z
    l <- input$l
    
    # Calculate k_star_initial
    k_star_initial <- ((s / (delta + n + z * l)) ** 1.5) * (1 - l)
    
    params_no_exp <- data.frame(
      Period = 0:(num_periods - 1),
      s = rep(s, num_periods),
      delta = rep(delta, num_periods),
      n = rep(n, num_periods),
      z = rep(z, num_periods),
      l = rep(l, num_periods),
      delta_k = rep(0.0, num_periods),
      
      # little_k is initialized to k_star_initial
      little_k = rep(k_star_initial, num_periods),
      A = rep(A, num_periods),
      L = rep(L, num_periods),
      K = rep(0.0, num_periods),
      Y = rep(0.0, num_periods)
    )
    
    # this calculations can just be done in the for i loop. just need to check the calculus to make sure minor changes or errors
    calculate_delta_k <- function(df, row_index) {
      if (row_index == 1) {
        return(0.0)
      } else {
        delta_k <- df[row_index, 's'] * ((1 - df[row_index, 'l']) ^ (2/3)) *
          (df[row_index - 1, 'little_k'] ^ (1/3)) -
          (df[row_index, 'z'] * df[row_index, 'l'] + df[row_index, 'n'] + df[row_index, 'delta']) *
          df[row_index - 1, 'little_k']
        return(delta_k)
      }
    }
    
    calculate_little_k <- function(df, row_index, k_star_initial) {
      if (row_index == 1) {
        little_k_value <- k_star_initial
      } else {
        little_k_value <- (df[row_index - 1, 'little_k'] + df[row_index, 'delta_k'])
      }
      return(little_k_value)
    }
    
    calculate_A <- function(df, row_index, initial_A) {
      if (row_index == 1) {
        return(initial_A)
      } else {
        A <- df[row_index - 1, 'A'] * (1 + df[row_index, 'z'] * df[row_index, 'l'])
        return(A)
      }
    }
    
    calculate_L <- function(df, row_index, initial_L) {
      if (row_index == 1) {
        return(initial_L)
      } else {
        L <- df[row_index - 1, 'L'] * (1 + df[row_index, 'n'])
        return(L)
      }
    }
    
    calculate_K <- function(df, row_index) {
      K <- df[row_index, 'little_k'] * df[row_index, 'L'] * df[row_index, 'A']
      return(K)
    }
    
    calculate_Y <- function(df, row_index) {
      Y <- (1 - df[row_index, 'l']) ^ (2/3) *
        df[row_index, 'K'] ^ (1/3) *
        (df[row_index, 'A'] * df[row_index, 'L']) ^ (2/3)
      return(Y)
    }
    
    for (i in 1:num_periods) {
      params_no_exp$delta_k[i] <- calculate_delta_k(params_no_exp, i)
      params_no_exp$little_k[i] <- calculate_little_k(params_no_exp, i, k_star_initial)
      params_no_exp$A[i] <- calculate_A(params_no_exp, i, A)
      params_no_exp$L[i] <- calculate_L(params_no_exp, i, L)
      params_no_exp$K[i] <- calculate_K(params_no_exp, i)
      params_no_exp$Y[i] <- calculate_Y(params_no_exp, i)
    }
    
    params_no_exp$log_L <- log(params_no_exp$L)
    params_no_exp$log_K <- log(params_no_exp$K)
    params_no_exp$log_Y <- log(params_no_exp$Y)
    params_no_exp$log_A <- log(params_no_exp$A)
    params_no_exp$change_k <- params_no_exp$delta_k / params_no_exp$K
    
    params_no_exp
  }) # version2
  
  # end of code for inital data frame ----version2-----------------------------------
  
  # Render final results table
  output$resultsTable <- renderTable({
    results_df <- results()
    results_df
  }, rownames = FALSE)
  
  # this is part of making inital data frame ------version2-----------
  output$resultsNoExpTable <- renderTable({
    results_no_exp()
  }, rownames = FALSE)
  # end of code for intial data frame ----version2---------------------------
  
  # Plot aesthetics. version1
  plot_theme <- theme_bw() +  # theme_bw() = light theme
    theme(plot.title = element_text(hjust = 0.5),
          axis.title = element_text(size = 12),
          axis.text = element_text(size = 10),
          panel.grid.major = element_line(color = "grey80"), # Lighter grid lines
          panel.grid.minor = element_blank(),
          strip.background = element_rect(fill = "grey90", color = "grey90")) 
  
  # doing function for counterfactual plots version 2
  make_plot <- function(data_exp, data_no_exp, y_var, title, y_label, show_no_exp) { # Modified function
    p <- ggplot(data_exp, aes(x = Period, y = !!sym(y_var))) + # Base plot with experiment data
      geom_line(aes(color = "With Experiments")) +
      geom_point(aes(color = "With Experiments")) +
      scale_color_manual(values = c("With Experiments" = "blue", "Without Experiments" = "red")) +
      ggtitle(title) +
      xlab("Period") +
      ylab(y_label) +
      plot_theme
    
    if (show_no_exp) { # Conditionally add no experiment data
      p <- p +
        geom_line(data = data_no_exp, aes(x = Period, y = !!sym(y_var), color = "Without Experiments"), linetype = "dashed") +
        geom_point(data = data_no_exp, aes(x = Period, y = !!sym(y_var), color = "Without Experiments"), shape = 1, size = 3)
    }
    
    return(p)
  }
  # end of function code for plots version2
  
  # updated outputplot code w/ user input. version2
  output$plot_K <- renderPlot({
    p <- make_plot(results(), results_no_exp(), "K", "Capital (K) Over Time", "Capital (K)", input$show_no_exp)
    plot_objects$plot_K <- p # p is to store the plot
    p # Return the plot for display
  }, res = 100)
  output$plot_Y <- renderPlot({
    p <- make_plot(results(), results_no_exp(), "Y", "Output (Y) Over Time", "Output (Y)", input$show_no_exp)
    plot_objects$plot_Y <- p 
    p # Return the plot for display
  }, res = 100)
  
  output$plot_delta_k <- renderPlot({
    p <- make_plot(results(), results_no_exp(), "delta_k", "Change in Capital (Δk) Over Time", "Change in Capital (Δk)", input$show_no_exp)
    plot_objects$plot_delta_k <- p
    p
  }, res = 100)
  
  output$plot_little_k <- renderPlot({
    p <- make_plot(results(), results_no_exp(), "little_k", "Capital Efficiency Units", "Capital Efficiency Units (little_k)", input$show_no_exp)
    plot_objects$plot_little_k <- p
    p
  }, res = 100)
  
  output$plot_log_L <- renderPlot({
    p <- make_plot(results(), results_no_exp(), "log_L", "Log of Labor (L) Over Time", "Log of Labor (L)", input$show_no_exp)
    plot_objects$plot_log_L <- p
    p
  }, res = 100)
  
  output$plot_log_K <- renderPlot({
    p <- make_plot(results(), results_no_exp(), "log_K", "Log of Capital (K) Over Time", "Log of Capital (K)", input$show_no_exp)
    plot_objects$plot_log_K <- p # Store the plot object
    p # Return the plot for display
  }, res = 100)
  
  output$plot_log_Y <- renderPlot({
    p <- make_plot(results(), results_no_exp(), "log_Y", "Log of Output (Y) Over Time", "Log of Output (Y)", input$show_no_exp)
    plot_objects$plot_log_Y <- p
    p
  }, res = 100)
  
  output$plot_log_A <- renderPlot({
    p <- make_plot(results(), results_no_exp(), "log_A", "Log/ratio scale of TFP (A)", "Log of TFP (A)", input$show_no_exp)
    plot_objects$plot_log_A <- p
    p
  }, res = 100)
  
  output$plot_change_k <- renderPlot({
    p <- make_plot(results(), results_no_exp(), "change_k", "Change in Capital Over Time", "Change in k", input$show_no_exp) # was change in capital efficiency units 
    plot_objects$plot_change_k <- p
    p
  }, res = 100)
  # updated outputplot code w/ user input. version2
  
  
  # Download handler for CSV version1
  output$downloadData <- downloadHandler(
    filename = function() {
      paste0("results_", Sys.Date(), ".csv")
    },
    content = function(file) {
      write.csv(results(), file, row.names = FALSE)
    }
  )
  
  # Store plots in reactiveValues version2
  plot_objects <- reactiveValues(
    plot_K = NULL,
    plot_Y = NULL,
    plot_delta_k = NULL,
    plot_little_k = NULL,
    plot_log_L = NULL,
    plot_log_K = NULL,
    plot_log_Y = NULL,
    plot_log_A = NULL,
    plot_change_k = NULL
  ) # version2
  
  # Download handler for all plots version1
  output$downloadPlots <- downloadHandler(
    filename = function() { 
      paste0("plots_", Sys.Date(), ".zip")
    },
    content = function(file) {
      # temp file storage but new shiny update change the way file donwloads happen so this might not be needed now
      temp_dir <- tempdir()
      file_paths <- c()
      
      # Use the stored plot objects version2
      plots <- reactiveValuesToList(plot_objects)  # Convert plot_objects <- reactiveValues to a list. version2
      plots <- Filter(Negate(is.null), plots) # Remove NULL entries (in case a plot hasn't been generated yet) version2
      
      
      # Save each plot to a PNG version1
      for (plot_name in names(plots)) {
        plot_file <- file.path(temp_dir, paste0(plot_name, ".png"))
        ggsave(plot_file, plots[[plot_name]], device = "png") # version2 remove width, dpi etc. 
        file_paths <- c(file_paths, plot_file)
      }
      
      # Zip all the png plots together. version1
      zipr(zipfile = file, files = file_paths)
    }
  )
}

# Run the application version1
shinyApp(ui = ui, server = server)


# this added the new delta k divided little k. 
# I'm not sure i did the exact formula Bro. Moncayo wants.
# fixed experiment stop last period. 
# added counterfactual data frame, user option if they want counterfactual, and made the needed changes to plot code. 
```


## Version 2.1
# spacer

```{r}
library(shiny)
library(ggplot2)
library(DT) # for interactive table
library(zip) # to create ZIP files in download handler
library(bslib)

# version 2.1 or v2.1 

# app layout and input controls version1
ui <- page_sidebar( # version
  title = "Solow-Romer Macro Simulation",
  sidebar = sidebar( # all the input controls
    width = 600, # edit sidebar width. This is not friendly with smaller screens. I was having trouble with the sidebar overlapping with tabs so I add this to default a sidebar lenght.  
    h4("Simulation Parameters"),
    sliderInput("Simulation_Period", "Simulation Period (yrs)", 
                min = 20, max = 150, value = 50, step = 1),
    sliderInput("s", "Savings Rate (s)", min = 0, max = 1, value = 0.2, step = 0.01),
    sliderInput("delta", "Depreciation Rate (delta)", min = 0, max = .5, value = 0.15, step = 0.01),
    sliderInput("n", "n", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("z", "Parameter z", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("l", "Parameter l", min = 0, max = 0.99, value = 0.1, step = 0.01), #v2.1 l if l is one, initial k* will be zero or in other words result in invalid calculations.
    selectInput("A", "Initial value for A", choices = c(1, 100, 1000), selected = 1), # 343
    selectInput("L", "Initial value for L", choices = c(1, 100, 1000), selected = 1), # 343
    h4("Experiments"),
    selectInput("param_name", "Quantitative exp (s, delta, n, z, l)", 
                choices = c("s", "delta", "n", "z", "l"),
                selected = "s"),
    numericInput("new_value", "New Value", value = 0, step = 0.01),
    numericInput("start_period", "Start Period", value = 5, step = 1),
    numericInput("length", "Length of Effect", value = 5, step = 1),
    actionButton("add_experiment", "Add Experiment"),
    checkboxInput("show_no_exp", "Show Counterfactual", value = TRUE), # version2
    actionButton("simulate", "Simulate"),
    h4("Download Results"),
    DTOutput("experimentsTable"), # Show experiments in a DT table so we can add Delete buttons 
    downloadButton("downloadPlots", "Download All Plots as PNG (ZIP)"),
    downloadButton("downloadData", "Download Data as CSV")
  ),
  mainPanel( # tab controls. version1
    tabsetPanel(
      tabPanel("Plots",
               div(style = "width: 1800px; margin: auto;",  # Wrapping fluidrow's with fixed width
                   fluidRow(
                     column(6, plotOutput("plot_K", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_Y", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_delta_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_little_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_change_k", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Log/Ratio scale",
               div(style = "width: 1800px; margin: auto;",
                   fluidRow(
                     column(6, plotOutput("plot_log_L", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_K", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_log_Y", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_A", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Table", tableOutput("resultsTable")),
      tabPanel("No Experiments", tableOutput("resultsNoExpTable"))
    )
  )
)

# define server logic.  # version1
server <- function(input, output, session) {
  
  #----------------------------------
  # 1. EXPERIMENTS TABLE MANAGEMENT
  #----------------------------------
  experiments <- reactiveVal(
    data.frame(
      param = character(0),
      new_value = numeric(0),
      start_period = integer(0),
      length = integer(0),
      stringsAsFactors = FALSE
    )
  )
  
  # need to rename this so they take up less space in the sidebar
  observeEvent(input$add_experiment, { # version1
    new_experiment <- data.frame(
      param        = input$param_name,
      new_value    = input$new_value,
      start_period = input$start_period,
      length       = input$length,
      stringsAsFactors = FALSE
    )
    experiments(rbind(experiments(), new_experiment))
  })
  
  # Render experiments table with Delete buttons. version1
  output$experimentsTable <- renderDT({ # version1
    exps <- experiments()
    if (nrow(exps) == 0) return(NULL)
    
    deleteButtons <- sapply(seq_len(nrow(exps)), function(i) {
      as.character(
        actionButton(
          inputId = paste0("delete_row_", i),
          label = "Delete",
          class = "btn btn-danger btn-sm",
          onclick = 'Shiny.setInputValue(\"delete_row\", this.id, {priority: \"event\"})'
        )
      )
    })
    exps$Delete <- deleteButtons
    
    datatable(
      exps,
      escape = FALSE,
      selection = "none",
      options = list(pageLength = 5)
    )
  }, server = FALSE)
  
  observeEvent(input$delete_row, {
    row_str <- gsub("delete_row_", "", input$delete_row)
    row_num <- as.numeric(row_str)
    
    exps <- experiments()
    if (!is.na(row_num) && row_num >= 1 && row_num <= nrow(exps)) {
      exps <- exps[-row_num, ]
      experiments(exps)
    }
  }) # version1
  
  #----------------------------------
  # 2. HELPER: SOLOW SIMULATION
  #----------------------------------
  # version2.1 or v2.1. This is replacing the near identical code for the two dataframes. 
  simulate_solow <- function(num_periods, s, delta, n, z, l, A_init, L_init, experiments_df = NULL) {
    
    # Create a parameter data frame for all periods
    params <- data.frame( # v1
      Period   = 0:(num_periods - 1),
      s        = rep(s, num_periods),
      delta    = rep(delta, num_periods),
      n        = rep(n, num_periods),
      z        = rep(z, num_periods),
      l        = rep(l, num_periods),
      delta_k  = rep(0.0, num_periods), # v2.1
      little_k = rep(0.0, num_periods), # v2.1
      A        = rep(A_init, num_periods),
      L        = rep(L_init, num_periods),
      K        = rep(0.0, num_periods),
      Y        = rep(0.0, num_periods)
    )
    
    # Calculate initial Capital per Capita Steady state k* 
    k_star_initial <- (s / (delta + n + z*l))^(1.5) * (1 - l)
    params$little_k[1] <- k_star_initial
    
    # this does the quantitative experiments. version 2.1
    if (!is.null(experiments_df) && nrow(experiments_df) > 0) { # v2.1
      for (exp in seq_len(nrow(experiments_df))) {
        start <- experiments_df$start_period[exp] + 1  # +1 because Period 0 is the first row 
        end   <- min(start + experiments_df$length[exp] - 1, num_periods)
        param_name <- experiments_df$param[exp]
        new_value  <- experiments_df$new_value[exp]
        
        # Overwrite that parameter in [start, end]
        params[start:end, param_name] <- new_value
      }
    }
    
    # Calculation portion. # v2.1
    # the for (i in seq_len makes sure all calculations are done in that other once every period. If you need to ask why don't edit this portion. 
    for (i in seq_len(num_periods)) { 
      if (i == 1) { # i=1 corresponds to Period=0 in the df
        params$delta_k[i] <- 0
      } else {
        # i-1 used to look back one row
        params$delta_k[i] <- params$s[i] * ( (1 - params$l[i])^(2/3) ) * 
          (params$little_k[i-1]^(1/3)) - 
          (params$z[i] * params$l[i] + params$n[i] + params$delta[i]) * params$little_k[i-1]
        
        params$little_k[i] <- params$little_k[i-1] + params$delta_k[i]
      } # different calculation if period 0 or >0
      
      if (i > 1) {# cant be done till period 1. 
        params$A[i] <- params$A[i-1] * (1 + params$z[i]*params$l[i])
        params$L[i] <- params$L[i-1] * (1 + params$n[i])
      }
      
      # this calculations are done every period
      params$K[i] <- params$little_k[i] * params$A[i] * params$L[i]
      params$Y[i] <- (1 - params$l[i])^(2/3) *
        params$K[i]^(1/3) *
        (params$A[i] * params$L[i])^(2/3)
    }
    
    # this calculations are done once the for i loop is done for better app efficiency. 
    params$log_L <- log(params$L)
    params$log_K <- log(params$K)
    params$log_Y <- log(params$Y)
    params$log_A <- log(params$A)
    params$change_k <- params$delta_k / params$K
    
    return(params)
    # when adding calc that need plots = add to tabpanel, and both codes.
  }
  
  #----------------------------------
  # 3. EVENT-REACTIVE RESULTS
  #----------------------------------
  
  # With Experiments. version 2.1
  results <- eventReactive(input$simulate, { # v2.1
    # I need to add code, if no event is added then to just run the initial df. Having the app return an error is no bueno.
    if (nrow(experiments()) == 0) {
      showModal(modalDialog(
        title = "Error",
        "Please add at least one experiment before running the simulation.",
        easyClose = TRUE,
        footer = NULL
      ))
      return(NULL)
    }
    
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    
    simulate_solow(
      num_periods = num_periods,
      s      = input$s,
      delta  = input$delta,
      n      = input$n,
      z      = input$z,
      l      = input$l,
      A_init = A_init,
      L_init = L_init,
      experiments_df = experiments()
    )
  })
  
  # No experiments. room for improvement in both eventreactive. I need to always have the initial one, and add code to add more than one experiment dataframe.
  # this will come in handy when wanting to compare one or more quantitative experiments. 
  # I don't need more than one df if I just specify what i want display in the dfs. (so everything could be in one df and just specify the table variables for each df)
  # I guess I could add an option for the user to choose which df they want to see and download. 
  # Yeah this is a good idea for the future. 
  results_no_exp <- eventReactive(input$simulate, { # v2.1
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    
    # Provide an empty or NULL data frame
    simulate_solow(
      num_periods = num_periods,
      s      = input$s,
      delta  = input$delta,
      n      = input$n,
      z      = input$z,
      l      = input$l,
      A_init = A_init,
      L_init = L_init,
      experiments_df = NULL  # No changes
    )
  })
  
  #----------------------------------
  # 4. OUTPUT: TABLES
  #----------------------------------
  output$resultsTable <- renderTable({ # v2.1
    req(results())  # guard if NULL
    results()
  }, rownames = FALSE)
  
  output$resultsNoExpTable <- renderTable({ # v2.1
    req(results_no_exp())
    results_no_exp()
  }, rownames = FALSE)
  
  #----------------------------------
  # 5. PLOTS
  #----------------------------------
  
  # aesthetics for each plot
  plot_theme <- theme_bw() +   # version1
    theme(plot.title = element_text(hjust = 0.5),
          axis.title = element_text(size = 12),
          axis.text = element_text(size = 10),
          panel.grid.major = element_line(color = "grey80"),
          panel.grid.minor = element_blank(),
          strip.background = element_rect(fill = "grey90", color = "grey90"))
  
  # function to generate each plot. # v2
  make_plot <- function(data_exp, data_no_exp, y_var, title, y_label, show_no_exp) {
    p <- ggplot(data_exp, aes(x = Period, y = .data[[y_var]])) + # Base plot with experiment data
      geom_line(aes(color = "With Experiments")) +
      geom_point(aes(color = "With Experiments")) +
      scale_color_manual(values = c("With Experiments" = "blue", 
                                    "Without Experiments" = "red")) +
      ggtitle(title) +
      xlab("Period") +
      ylab(y_label) +
      plot_theme
    
    if (show_no_exp) {  # Conditionally add no experiment data. # v2.1
      p <- p +
        geom_line(data = data_no_exp, aes(x = Period, y = .data[[y_var]], color = "Without Experiments"), linetype = "dashed") +
        geom_point(data = data_no_exp, aes(x = Period, y = .data[[y_var]], color = "Without Experiments"), shape = 1, size = 3)
    }
    return(p)
  }
  
  
  plot_objects <- reactiveValues() # store plots for download. # v2.1
  
  output$plot_K <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "K", 
                   "Capital (K) Over Time", "Capital (K)", input$show_no_exp)
    plot_objects$plot_K <- p # Store the plot object
    p # Return the plot for display
  }, res = 100) # v2.1
  
  output$plot_Y <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "Y", 
                   "Output (Y) Over Time", "Output (Y)", input$show_no_exp)
    plot_objects$plot_Y <- p
    p
  }, res = 100) # v2.1
  
  output$plot_delta_k <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "delta_k", 
                   "Change in Capital (Δk) Over Time", "Δk", input$show_no_exp)
    plot_objects$plot_delta_k <- p
    p
  }, res = 100)  # v2.1
  
  output$plot_little_k <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "little_k", 
                   "Capital Efficiency Units", "k (Capital Efficiency Units)", input$show_no_exp)
    plot_objects$plot_little_k <- p
    p
  }, res = 100)  # v2.1
  
  output$plot_log_L <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "log_L", 
                   "Log of Labor (L) Over Time", "Log(L)", input$show_no_exp)
    plot_objects$plot_log_L <- p
    p
  }, res = 100) # v2.1
  
  output$plot_log_K <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "log_K", 
                   "Log of Capital (K) Over Time", "Log(K)", input$show_no_exp)
    plot_objects$plot_log_K <- p
    p
  }, res = 100) # v2.1
  
  output$plot_log_Y <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "log_Y", 
                   "Log of Output (Y) Over Time", "Log(Y)", input$show_no_exp)
    plot_objects$plot_log_Y <- p
    p
  }, res = 100) # v2.1
  
  output$plot_log_A <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "log_A", 
                   "Log of TFP (A) Over Time", "Log(A)", input$show_no_exp)
    plot_objects$plot_log_A <- p
    p
  }, res = 100) # v2.1
  
  output$plot_change_k <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "change_k", 
                   "Change in Capital Over Time", "Δk/K", input$show_no_exp)
    plot_objects$plot_change_k <- p
    p
  }, res = 100) # v2.1
  
  #----------------------------------
  # 6. DOWNLOAD HANDLERS
  #----------------------------------
  
  output$downloadData <- downloadHandler( # version1
    filename = function() {
      paste0("results_", Sys.Date(), ".csv")
    },
    content = function(file) {req(results()) # v2.1
      write.csv(results(), file, row.names = FALSE)
    }
  )
  
  output$downloadPlots <- downloadHandler( # version1
    filename = function() { 
      paste0("plots_", Sys.Date(), ".zip")
    },
    content = function(file) {
      temp_dir <- tempdir() # temp file storage but new shiny update change the way file donwloads happen so this might not be needed now
      file_paths <- c()
      
      # Use the stored plot objects version2
      plots <- reactiveValuesToList(plot_objects) # Convert reactiveValues to list
      plots <- Filter(Negate(is.null), plots) # Remove NULL entries
      
      for (plot_name in names(plots)) { # Save each plot to a PNG version1
        plot_file <- file.path(temp_dir, paste0(plot_name, ".png"))
        ggsave(plot_file, plots[[plot_name]], device = "png")
        file_paths <- c(file_paths, plot_file)
      }
      zipr(zipfile = file, files = file_paths) # zip em. v1
    }
  )
}

shinyApp(ui = ui, server = server)

# v2.1: limited l parameter to 0.99. I was at a max of 1, so l was 1 it would result in a zero value for initial k* star which would basically result in error for all calculations. 
# I organized my calculations.After successfully adding the 2nd data frame in version2 and everything check out I loop the calculations for both scenarios instead of having two sets of calculations. 
# this change a lot of the code, and although I use ai I check that it was what I wanted and nothing unrelated was change. 
# but I should stay in the look out for errors. 



```

# spacer


```{r}
# v2.2
library(shiny)
library(ggplot2)
library(DT) # for interactive table
library(zip) # to create ZIP files in download handler
library(bslib)
library(rio)  # to read the Excel file # v2.2

# app layout and input controls version1
ui <- page_sidebar( # version
  title = "Solow-Romer Macro Simulation",
  sidebar = sidebar( # all the input controls
    width = 600, # edit sidebar width. This is not friendly with smaller screens. I was having trouble with the sidebar overlapping with tabs so I add this to default a sidebar lenght.  
    h4("Simulation Parameters"),
    sliderInput("Simulation_Period", "Simulation Period (yrs)", 
                min = 20, max = 150, value = 50, step = 1),
    sliderInput("s", "Savings Rate (s)", min = 0.001, max = 1, value = 0.2, step = 0.01), # v2.3 change to min .001 due to div by zero error
    sliderInput("delta", "Depreciation Rate (delta)", min = 0, max = .5, value = 0.15, step = 0.01),
    sliderInput("n", "n", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("z", "Parameter z", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("l", "Parameter l", min = 0, max = 0.99, value = 0.1, step = 0.01), #v2.1 l if l is one, initial k* will be zero or in other words result in invalid calculations.
    selectInput("A", "Initial value for A", choices = c(1, 100, 1000), selected = 1), # 343
    selectInput("L", "Initial value for L", choices = c(1, 100, 1000), selected = 1), # 343
    h4("Experiments"),
    selectInput("param_name", "Quantitative exp (s, delta, n, z, l)", 
                choices = c("s", "delta", "n", "z", "l"),
                selected = "s"),
    numericInput("new_value", "New Value", value = 0, step = 0.01),
    numericInput("start_period", "Start Period", value = 5, step = 1),
    numericInput("length", "Length of Effect", value = 5, step = 1),
    actionButton("add_experiment", "Add Experiment"),
    checkboxInput("show_no_exp", "Show Counterfactual", value = TRUE), # version2
    actionButton("simulate", "Simulate"),
    h4("Download Results"),
    DTOutput("experimentsTable"), # Show experiments in a DT table so we can add Delete buttons 
    downloadButton("downloadPlots", "Download All Plots as PNG (ZIP)"),
    downloadButton("downloadData", "Download Data as CSV")
  ),
  mainPanel( # tab controls. version1
    tabsetPanel(
      tabPanel("World", # v 2.2
               # adding option to get average savings rate
               selectInput("selectedSheet", "Select Region", choices = NULL),
               selectInput("selectedColumn", "Select Country", choices = NULL),
               numericInput("startYear", "Start Year", value = 1960),
               numericInput("endYear",   "End Year",   value = 2023),
               actionButton("calculateAvg", "Get Avg Savings Rate 's'"),
               verbatimTextOutput("avgSavingsRate") # displays the avg s calculated
      ),
      tabPanel("Plots",
               div(style = "width: 1800px; margin: auto;",  # Wrapping fluidrow's with fixed width
                   fluidRow(
                     column(6, plotOutput("plot_K", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_Y", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_delta_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_little_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_change_k", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Log/Ratio scale",
               div(style = "width: 1800px; margin: auto;",
                   fluidRow(
                     column(6, plotOutput("plot_log_L", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_K", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_log_Y", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_A", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Table", tableOutput("resultsTable")),
      tabPanel("No Experiments", tableOutput("resultsNoExpTable"))
    )
  )
)

# define server logic.  # version1
server <- function(input, output, session) {
  
  # adding option for Savings rate average for list of countries. 
  excel_list <- import_list("data/savings_rate_y.xlsx") # v2.2
  
  # Populate region choices
  observe({  # v2.2
    updateSelectInput(session, "selectedSheet", choices = names(excel_list), selected = names(excel_list)[1])
  })
  observeEvent(input$selectedSheet, {  # Update column choices  # v2.2
    df <- excel_list[[input$selectedSheet]]
    updateSelectInput(session, "selectedColumn", choices = setdiff(names(df), "year"), selected = setdiff(names(df), "year")[1])
  })
  
  # find the available years
  observeEvent(input$selectedColumn, { # v2.2
    df <- excel_list[[input$selectedSheet]]
    yearVals <- df$year
    yVals <- as.numeric(df[[input$selectedColumn]])
    valid <- !is.na(yearVals) & !is.na(yVals)
    if (!any(valid)) return()
    validYears <- yearVals[valid]
    minY <- min(validYears)
    maxY <- max(validYears)
    updateNumericInput(session, "startYear", min = minY, max = maxY, value = minY)
    updateNumericInput(session, "endYear",   min = minY, max = maxY, value = maxY)
  })
  
  # Calculate average within the chosen year range
  observeEvent(input$calculateAvg, {
    df <- excel_list[[input$selectedSheet]]
    yearVals <- df$year
    yVals <- as.numeric(df[[input$selectedColumn]])
    valid <- !is.na(yearVals) & !is.na(yVals)
    dfValid <- df[valid, ]
    
    subsetData <- dfValid[dfValid$year >= input$startYear & dfValid$year <= input$endYear, ]
    if (nrow(subsetData) == 0) {  # Check if country has any data
      output$avgSavingsRate <- renderPrint("Country Data Not Available") 
      return()
    }
    
    avgVal <- (mean(subsetData[[input$selectedColumn]]))/100
    updateSliderInput(session, "s", value = avgVal)
    output$avgSavingsRate <- renderPrint(paste("Average Savings Rate:", avgVal)) # Display the average
  }) # v2.2
  
  #----------------------------------
  # 1. EXPERIMENTS TABLE MANAGEMENT
  #----------------------------------
  experiments <- reactiveVal(
    data.frame(
      param = character(0),
      new_value = numeric(0),
      start_period = integer(0),
      length = integer(0),
      stringsAsFactors = FALSE
    )
  )
  
  # need to rename this so they take up less space in the sidebar
  observeEvent(input$add_experiment, { # version1
    new_experiment <- data.frame(
      param        = input$param_name,
      new_value    = input$new_value,
      start_period = input$start_period,
      length       = input$length,
      stringsAsFactors = FALSE
    )
    experiments(rbind(experiments(), new_experiment))
  })
  
  # Render experiments table with Delete buttons. version1
  output$experimentsTable <- renderDT({ # version1
    exps <- experiments()
    if (nrow(exps) == 0) return(NULL)
    
    deleteButtons <- sapply(seq_len(nrow(exps)), function(i) {
      as.character(
        actionButton(
          inputId = paste0("delete_row_", i),
          label = "Delete",
          class = "btn btn-danger btn-sm",
          onclick = 'Shiny.setInputValue(\"delete_row\", this.id, {priority: \"event\"})'
        )
      )
    })
    exps$Delete <- deleteButtons
    
    datatable(
      exps,
      escape = FALSE,
      selection = "none",
      options = list(pageLength = 5)
    )
  }, server = FALSE)
  
  observeEvent(input$delete_row, {
    row_str <- gsub("delete_row_", "", input$delete_row)
    row_num <- as.numeric(row_str)
    
    exps <- experiments()
    if (!is.na(row_num) && row_num >= 1 && row_num <= nrow(exps)) {
      exps <- exps[-row_num, ]
      experiments(exps)
    }
  }) # version1
  
  #----------------------------------
  # 2. SOLOW SIMULATION
  #----------------------------------
  # version2.1 or v2.1. This is replacing the near identical code for the two dataframes. 
  simulate_solow <- function(num_periods, s, delta, n, z, l, A_init, L_init, experiments_df = NULL) {
    
    # Create a parameter data frame for all periods
    params <- data.frame( # v1
      Period   = 0:(num_periods - 1),
      s        = rep(s, num_periods),
      delta    = rep(delta, num_periods),
      n        = rep(n, num_periods),
      z        = rep(z, num_periods),
      l        = rep(l, num_periods),
      delta_k  = rep(0.0, num_periods), # v2.1
      little_k = rep(0.0, num_periods), # v2.1
      A        = rep(A_init, num_periods),
      L        = rep(L_init, num_periods),
      K        = rep(0.0, num_periods),
      Y        = rep(0.0, num_periods)
    )
    
    # Calculate initial Capital per Capita Steady state k* 
    k_star_initial <- (s / (delta + n + z*l))^(1.5) * (1 - l)
    params$little_k[1] <- k_star_initial
    
    # this does the quantitative experiments. version 2.1
    if (!is.null(experiments_df) && nrow(experiments_df) > 0) { # v2.1
      for (exp in seq_len(nrow(experiments_df))) {
        start <- experiments_df$start_period[exp] + 1  # +1 because Period 0 is the first row 
        end   <- min(start + experiments_df$length[exp] - 1, num_periods)
        param_name <- experiments_df$param[exp]
        new_value  <- experiments_df$new_value[exp]
        
        # Overwrite that parameter in [start, end]
        params[start:end, param_name] <- new_value
      }
    }
    
    # Calculation portion. # v2.1
    # the for (i in seq_len makes sure all calculations are done in that other once every period. If you need to ask why don't edit this portion. 
    for (i in seq_len(num_periods)) { 
      if (i == 1) { # i=1 corresponds to Period=0 in the df
        params$delta_k[i] <- 0
      } else {
        # i-1 used to look back one row
        params$delta_k[i] <- params$s[i] * ( (1 - params$l[i])^(2/3) ) * 
          (params$little_k[i-1]^(1/3)) - 
          (params$z[i] * params$l[i] + params$n[i] + params$delta[i]) * params$little_k[i-1]
        
        params$little_k[i] <- params$little_k[i-1] + params$delta_k[i]
      } # different calculation if period 0 or >0
      
      if (i > 1) {# cant be done till period 1. 
        params$A[i] <- params$A[i-1] * (1 + params$z[i]*params$l[i])
        params$L[i] <- params$L[i-1] * (1 + params$n[i])
      }
      
      # this calculations are done every period
      params$K[i] <- params$little_k[i] * params$A[i] * params$L[i]
      params$Y[i] <- (1 - params$l[i])^(2/3) *
        params$K[i]^(1/3) *
        (params$A[i] * params$L[i])^(2/3)
    }
    
    # this calculations are done once the for i loop is done for better app efficiency. 
    params$log_L <- log(params$L)
    params$log_K <- log(params$K)
    params$log_Y <- log(params$Y)
    params$log_A <- log(params$A)
    params$change_k <- params$delta_k / params$K
    
    return(params)
    # when adding calc that need plots = add to tabpanel, and both codes.
  }
  
  #----------------------------------
  # 3. EVENT-REACTIVE RESULTS
  #----------------------------------
  
  # With Experiments. version 2.1
  results <- eventReactive(input$simulate, { # v2.1
    # I need to add code, if no event is added then to just run the initial df. Having the app return an error is no bueno.
    if (nrow(experiments()) == 0) {
      showModal(modalDialog(
        title = "Error",
        "Please add at least one experiment before running the simulation.",
        easyClose = TRUE,
        footer = NULL
      ))
      return(NULL)
    }
    
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    
    simulate_solow(
      num_periods = num_periods,
      s      = input$s,
      delta  = input$delta,
      n      = input$n,
      z      = input$z,
      l      = input$l,
      A_init = A_init,
      L_init = L_init,
      experiments_df = experiments()
    )
  })
  
  # No experiments. room for improvement in both eventreactive. I need to always have the initial one, and add code to add more than one experiment dataframe.
  # this will come in handy when wanting to compare one or more quantitative experiments. 
  # I don't need more than one df if I just specify what i want display in the dfs. (so everything could be in one df and just specify the table variables for each df)
  # I guess I could add an option for the user to choose which df they want to see and download. 
  # Yeah this is a good idea for the future. 
  results_no_exp <- eventReactive(input$simulate, { # v2.1
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    
    # Provide an empty or NULL data frame
    simulate_solow(
      num_periods = num_periods,
      s      = input$s,
      delta  = input$delta,
      n      = input$n,
      z      = input$z,
      l      = input$l,
      A_init = A_init,
      L_init = L_init,
      experiments_df = NULL  # No changes
    )
  })
  
  #----------------------------------
  # 4. OUTPUT: TABLES
  #----------------------------------
  output$resultsTable <- renderTable({ # v2.1
    req(results())  # guard if NULL
    results()
  }, rownames = FALSE)
  
  output$resultsNoExpTable <- renderTable({ # v2.1
    req(results_no_exp())
    results_no_exp()
  }, rownames = FALSE)
  
  #----------------------------------
  # 5. PLOTS
  #----------------------------------
  
  # aesthetics for each plot
  plot_theme <- theme_bw() +   # version1
    theme(plot.title = element_text(hjust = 0.5),
          axis.title = element_text(size = 12),
          axis.text = element_text(size = 10),
          panel.grid.major = element_line(color = "grey80"),
          panel.grid.minor = element_blank(),
          strip.background = element_rect(fill = "grey90", color = "grey90"))
  
  # function to generate each plot. # v2
  make_plot <- function(data_exp, data_no_exp, y_var, title, y_label, show_no_exp) {
    p <- ggplot(data_exp, aes(x = Period, y = .data[[y_var]])) + # Base plot with experiment data
      geom_line(aes(color = "With Experiments")) +
      geom_point(aes(color = "With Experiments")) +
      scale_color_manual(values = c("With Experiments" = "blue", 
                                    "Without Experiments" = "red")) +
      ggtitle(title) +
      xlab("Period") +
      ylab(y_label) +
      plot_theme
    
    if (show_no_exp) {  # Conditionally add no experiment data. # v2.1
      p <- p +
        geom_line(data = data_no_exp, aes(x = Period, y = .data[[y_var]], color = "Without Experiments"), linetype = "dashed") +
        geom_point(data = data_no_exp, aes(x = Period, y = .data[[y_var]], color = "Without Experiments"), shape = 1, size = 3)
    }
    return(p)
  }
  
  
  plot_objects <- reactiveValues() # store plots for download. # v2.1
  
  output$plot_K <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "K", 
                   "Capital (K) Over Time", "Capital (K)", input$show_no_exp)
    plot_objects$plot_K <- p # Store the plot object
    p # Return the plot for display
  }, res = 100) # v2.1
  
  output$plot_Y <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "Y", 
                   "Output (Y) Over Time", "Output (Y)", input$show_no_exp)
    plot_objects$plot_Y <- p
    p
  }, res = 100) # v2.1
  
  output$plot_delta_k <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "delta_k", 
                   "Change in Capital (Δk) Over Time", "Δk", input$show_no_exp)
    plot_objects$plot_delta_k <- p
    p
  }, res = 100)  # v2.1
  
  output$plot_little_k <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "little_k", 
                   "Capital Efficiency Units", "k (Capital Efficiency Units)", input$show_no_exp)
    plot_objects$plot_little_k <- p
    p
  }, res = 100)  # v2.1
  
  output$plot_log_L <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "log_L", 
                   "Log of Labor (L) Over Time", "Log(L)", input$show_no_exp)
    plot_objects$plot_log_L <- p
    p
  }, res = 100) # v2.1
  
  output$plot_log_K <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "log_K", 
                   "Log of Capital (K) Over Time", "Log(K)", input$show_no_exp)
    plot_objects$plot_log_K <- p
    p
  }, res = 100) # v2.1
  
  output$plot_log_Y <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "log_Y", 
                   "Log of Output (Y) Over Time", "Log(Y)", input$show_no_exp)
    plot_objects$plot_log_Y <- p
    p
  }, res = 100) # v2.1
  
  output$plot_log_A <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "log_A", 
                   "Log of TFP (A) Over Time", "Log(A)", input$show_no_exp)
    plot_objects$plot_log_A <- p
    p
  }, res = 100) # v2.1
  
  output$plot_change_k <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "change_k", 
                   "Change in Capital Over Time", "Δk/K", input$show_no_exp)
    plot_objects$plot_change_k <- p
    p
  }, res = 100) # v2.1
  
  #----------------------------------
  # 6. DOWNLOAD HANDLERS
  #----------------------------------
  
  output$downloadData <- downloadHandler( # version1
    filename = function() {
      paste0("results_", Sys.Date(), ".csv")
    },
    content = function(file) {req(results()) # v2.1
      write.csv(results(), file, row.names = FALSE)
    }
  )
  
  output$downloadPlots <- downloadHandler( # version1
    filename = function() { 
      paste0("plots_", Sys.Date(), ".zip")
    },
    content = function(file) {
      temp_dir <- tempdir() # temp file storage but new shiny update change the way file donwloads happen so this might not be needed now
      file_paths <- c()
      
      # Use the stored plot objects version2
      plots <- reactiveValuesToList(plot_objects) # Convert reactiveValues to list
      plots <- Filter(Negate(is.null), plots) # Remove NULL entries
      
      for (plot_name in names(plots)) { # Save each plot to a PNG version1
        plot_file <- file.path(temp_dir, paste0(plot_name, ".png"))
        ggsave(plot_file, plots[[plot_name]], device = "png")
        file_paths <- c(file_paths, plot_file)
      }
      zipr(zipfile = file, files = file_paths) # zip em. v1
    }
  )
}

shinyApp(ui = ui, server = server)

# v2.2
# I added the savings rate average
# included data has regions and large amount of countries to select from.
# I also created the user inputs in a tab to avoid over filling the sidebar


```

# spacer

```{r}
# v2.3

library(shiny)
library(ggplot2)
library(DT) # for interactive table
library(zip) # to create ZIP files in download handler
library(bslib)
library(rio)  # to read the Excel file # v2.2

# app layout and input controls version1
ui <- page_sidebar( # version
  title = "Solow-Romer Macro Simulation",
  sidebar = sidebar( # all the input controls
    width = 600, # edit sidebar width. This is not friendly with smaller screens. I was having trouble with the sidebar overlapping with tabs so I add this to default a sidebar lenght.  
    h4("Simulation Parameters"),
    sliderInput("Simulation_Period", "Simulation Period (yrs)", 
                min = 20, max = 150, value = 50, step = 1),
    sliderInput("s", "Savings Rate (s)", min = 0.001, max = 1, value = 0.2, step = 0.01), # v2.3 change to min .001 due to div by zero error
    sliderInput("delta", "Depreciation Rate (delta)", min = 0, max = .5, value = 0.15, step = 0.01),
    sliderInput("n", "n", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("z", "Parameter z", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("l", "Parameter l", min = 0, max = 0.99, value = 0.1, step = 0.01), #v2.1 l if l is one, initial k* will be zero or in other words result in invalid calculations.
    selectInput("A", "Initial value for A", choices = c(1, 100, 1000), selected = 1), # 343
    selectInput("L", "Initial value for L", choices = c(1, 100, 1000), selected = 1), # 343
    h4("Experiments"),
    selectInput("param_name", "Quantitative exp (s, delta, n, z, l)", 
                choices = c("s", "delta", "n", "z", "l"),
                selected = "s"),
    numericInput("new_value", "New Value", value = 0, step = 0.01),
    numericInput("start_period", "Start Period", value = 5, step = 1),
    numericInput("length", "Length of Effect", value = 5, step = 1),
    actionButton("add_experiment", "Add Experiment"),
    checkboxInput("show_no_exp", "Show Counterfactual", value = TRUE), # version2
    actionButton("simulate", "Simulate"),
    h4("Download Results"),
    DTOutput("experimentsTable"), # Show experiments in a DT table so we can add Delete buttons 
    downloadButton("downloadPlots", "Download All Plots as PNG (ZIP)"),
    downloadButton("downloadData", "Download Data as CSV")
  ),
  mainPanel( # tab controls. version1
    tabsetPanel(
      tabPanel("World", # v 2.2
               # adding option to get average savings rate
               selectInput("selectedSheet", "Select Region", choices = NULL),
               selectInput("selectedColumn", "Select Country", choices = NULL),
               numericInput("startYear", "Start Year", value = 1960),
               numericInput("endYear",   "End Year",   value = 2023),
               actionButton("calculateAvg", "Get Avg Savings Rate 's'"),
               verbatimTextOutput("avgSavingsRate") # displays the avg s calculated
      ),
      tabPanel("Plots",
               div(style = "width: 1800px; margin: auto;",  # Wrapping fluidrow's with fixed width
                   fluidRow(
                     column(6, plotOutput("plot_K", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_Y", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_delta_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_little_k", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Log/Ratio scale",
               div(style = "width: 1800px; margin: auto;",
                   fluidRow(
                     column(6, plotOutput("plot_log_L", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_K", width = "900px", height = "600px"))
                     
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_log_Y", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_A", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Table", tableOutput("resultsTable")),
      tabPanel("No Experiments", tableOutput("resultsNoExpTable"))
    )
  )
)

# define server logic.  # version1
server <- function(input, output, session) {
  
  # adding option for Savings rate average for list of countries. 
  excel_list <- import_list("data/savings_rate_y.xlsx") # v2.2
  
  # Populate region choices
  observe({  # v2.2
    updateSelectInput(session, "selectedSheet", choices = names(excel_list), selected = names(excel_list)[1])
  })
  observeEvent(input$selectedSheet, {  # Update column choices  # v2.2
    df <- excel_list[[input$selectedSheet]]
    updateSelectInput(session, "selectedColumn", choices = setdiff(names(df), "year"), selected = setdiff(names(df), "year")[1])
  })
  
  # find the available years
  observeEvent(input$selectedColumn, { # v2.2
    df <- excel_list[[input$selectedSheet]]
    yearVals <- df$year
    yVals <- as.numeric(df[[input$selectedColumn]])
    valid <- !is.na(yearVals) & !is.na(yVals)
    if (!any(valid)) return()
    validYears <- yearVals[valid]
    minY <- min(validYears)
    maxY <- max(validYears)
    updateNumericInput(session, "startYear", min = minY, max = maxY, value = minY)
    updateNumericInput(session, "endYear",   min = minY, max = maxY, value = maxY)
  })
  
  # Calculate average within the chosen year range
  observeEvent(input$calculateAvg, {
    df <- excel_list[[input$selectedSheet]]
    yearVals <- df$year
    yVals <- as.numeric(df[[input$selectedColumn]])
    valid <- !is.na(yearVals) & !is.na(yVals)
    dfValid <- df[valid, ]
    
    subsetData <- dfValid[dfValid$year >= input$startYear & dfValid$year <= input$endYear, ]
    if (nrow(subsetData) == 0) {  # Check if country has any data
      output$avgSavingsRate <- renderPrint("Country Data Not Available") 
      return()
    }
    
    avgVal <- (mean(subsetData[[input$selectedColumn]]))/100
    updateSliderInput(session, "s", value = avgVal)
    output$avgSavingsRate <- renderPrint(paste("Average Savings Rate:", avgVal)) # Display the average
  }) # v2.2
  
  #----------------------------------
  # 1. EXPERIMENTS TABLE MANAGEMENT
  #----------------------------------
  experiments <- reactiveVal(
    data.frame(
      param = character(0),
      new_value = numeric(0),
      start_period = integer(0),
      length = integer(0),
      stringsAsFactors = FALSE
    )
  )
  
  # need to rename this so they take up less space in the sidebar
  observeEvent(input$add_experiment, { # version1
    new_experiment <- data.frame(
      param        = input$param_name,
      new_value    = input$new_value,
      start_period = input$start_period,
      length       = input$length,
      stringsAsFactors = FALSE
    )
    experiments(rbind(experiments(), new_experiment))
  })
  
  # Render experiments table with Delete buttons. version1
  output$experimentsTable <- renderDT({ # version1
    exps <- experiments()
    if (nrow(exps) == 0) return(NULL)
    
    deleteButtons <- sapply(seq_len(nrow(exps)), function(i) {
      as.character(
        actionButton(
          inputId = paste0("delete_row_", i),
          label = "Delete",
          class = "btn btn-danger btn-sm",
          onclick = 'Shiny.setInputValue(\"delete_row\", this.id, {priority: \"event\"})'
        )
      )
    })
    exps$Delete <- deleteButtons
    
    datatable(
      exps,
      escape = FALSE,
      selection = "none",
      options = list(pageLength = 5)
    )
  }, server = FALSE)
  
  observeEvent(input$delete_row, {
    row_str <- gsub("delete_row_", "", input$delete_row)
    row_num <- as.numeric(row_str)
    
    exps <- experiments()
    if (!is.na(row_num) && row_num >= 1 && row_num <= nrow(exps)) {
      exps <- exps[-row_num, ]
      experiments(exps)
    }
  }) # version1
  
  #----------------------------------
  # 2. SOLOW SIMULATION
  #----------------------------------
  # version2.1 or v2.1. This is replacing the near identical code for the two dataframes. 
  simulate_solow <- function(num_periods, s, delta, n, z, l, A_init, L_init, experiments_df = NULL) {
    
    # Create a parameter data frame for all periods
    params <- data.frame( # v1
      Period   = 0:(num_periods - 1),
      s        = rep(s, num_periods),
      delta    = rep(delta, num_periods),
      n        = rep(n, num_periods),
      z        = rep(z, num_periods),
      l        = rep(l, num_periods),
      delta_k  = rep(0.0, num_periods), # v2.1
      percent_delta_k = rep(0.0, num_periods),
      little_k = rep(0.0, num_periods), # v2.1
      A        = rep(A_init, num_periods),
      L        = rep(L_init, num_periods),
      K        = rep(0.0, num_periods),
      Y        = rep(0.0, num_periods)
    )
    
    # Calculate initial Capital per Capita Steady state k* 
    k_star_initial <- (s / (delta + n + z*l))^(1.5) * (1 - l)
    params$little_k[1] <- k_star_initial
    
    # this does the quantitative experiments. version 2.1
    if (!is.null(experiments_df) && nrow(experiments_df) > 0) { # v2.1
      for (exp in seq_len(nrow(experiments_df))) {
        start <- experiments_df$start_period[exp] + 1  # +1 because Period 0 is the first row 
        end   <- min(start + experiments_df$length[exp] - 1, num_periods)
        param_name <- experiments_df$param[exp]
        new_value  <- experiments_df$new_value[exp]
        
        # Overwrite that parameter in [start, end]
        params[start:end, param_name] <- new_value
      }
    }
    
    # Calculation portion. # v2.1
    # the "for (i in seq_len" makes sure all calculations are done in that order once every period. If you need to ask why don't edit this portion. 
    for (i in seq_len(num_periods)) { 
      if (i == 1) { # i=1 corresponds to Period=0 in the df
        params$delta_k[i] <- 0
      } else {
        # i-1 = t - 1
        params$delta_k[i] <- params$s[i] * ( (1 - params$l[i])^(2/3) ) * 
          (params$little_k[i-1]^(1/3)) - 
          (params$z[i] * params$l[i] + params$n[i] + params$delta[i]) * params$little_k[i-1]
        
        params$little_k[i] <- params$little_k[i-1] + params$delta_k[i]
      } # different calculation if period 0 or >0
      
      if (i > 1) {# cant be done till period 1. 
        params$A[i] <- params$A[i-1] * (1 + params$z[i]*params$l[i])
        params$L[i] <- params$L[i-1] * (1 + params$n[i])
      }
      
      # this calculations are done every period
      params$K[i] <- params$little_k[i] * params$A[i] * params$L[i]
      params$Y[i] <- (1 - params$l[i])^(2/3) * params$K[i]^(1/3) * (params$A[i] * params$L[i])^(2/3)
    }
    
    # this calculations are done once the for i loop is done for better app efficiency. 
    params$MPL <- (1 - params$l) * (1 - params$l)^(1 - (1/3)) * params$K^(1/3) * (params$A * params$L)^(1 - (1/3)) / params$L # v2.3 
    params$MPK <- (1/3) * (1 - params$l)^(1 - (1/3)) * params$K^(1/3) * (params$A * params$L)^(1 - (1/3)) / params$K # v2.3 
    params$log_L <- log(params$L)
    params$log_K <- log(params$K)
    params$log_Y <- log(params$Y)
    params$log_A <- log(params$A)
    params$percent_delta_k <- (params$delta_k / params$little_k) * 100

    
    return(params)
    # when adding calc that need plots = add to tabpanel, and both codes.
  }
  
  #----------------------------------
  # 3. EVENT-REACTIVE RESULTS
  #----------------------------------
  
  # With Experiments. version 2.1
  results <- eventReactive(input$simulate, { # v2.1
    # I need to add code, if no event is added then to just run the initial df. Having the app return an error is no bueno.
    if (nrow(experiments()) == 0) {
      showModal(modalDialog(
        title = "Error",
        "Please add at least one experiment before running the simulation.",
        easyClose = TRUE,
        footer = NULL
      ))
      return(NULL)
    }
    
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    
    simulate_solow(
      num_periods = num_periods,
      s      = input$s,
      delta  = input$delta,
      n      = input$n,
      z      = input$z,
      l      = input$l,
      A_init = A_init,
      L_init = L_init,
      experiments_df = experiments()
    )
  })
  
  # No experiments. room for improvement in both eventreactive. I need to always have the initial one, and add code to add more than one experiment dataframe.
  # this will come in handy when wanting to compare one or more quantitative experiments. 
  # I don't need more than one df if I just specify what i want display in the dfs. (so everything could be in one df and just specify the table variables for each df)
  # I guess I could add an option for the user to choose which df they want to see and download. 
  # Yeah this is a good idea for the future. 
  results_no_exp <- eventReactive(input$simulate, { # v2.1
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    
    # Provide an empty or NULL data frame
    simulate_solow(
      num_periods = num_periods,
      s      = input$s,
      delta  = input$delta,
      n      = input$n,
      z      = input$z,
      l      = input$l,
      A_init = A_init,
      L_init = L_init,
      experiments_df = NULL  # No changes
    )
  })
  
  #----------------------------------
  # 4. OUTPUT: TABLES
  #----------------------------------
  output$resultsTable <- renderTable({ # v2.1
    req(results())  # guard if NULL
    results()
  }, rownames = FALSE)
  
  output$resultsNoExpTable <- renderTable({ # v2.1
    req(results_no_exp())
    results_no_exp()
  }, rownames = FALSE)
  
  #----------------------------------
  # 5. PLOTS
  #----------------------------------
  
  # aesthetics for each plot
  plot_theme <- theme_bw() +   # version1
    theme(plot.title = element_text(hjust = 0.5),
          axis.title = element_text(size = 12),
          axis.text = element_text(size = 10),
          panel.grid.major = element_line(color = "grey80"),
          panel.grid.minor = element_blank(),
          strip.background = element_rect(fill = "grey90", color = "grey90"))
  
  # function to generate each plot. # v2
  make_plot <- function(data_exp, data_no_exp, y_var, title, y_label, show_no_exp) {
    p <- ggplot(data_exp, aes(x = Period, y = .data[[y_var]])) + # Base plot with experiment data
      geom_line(aes(color = "With Experiments")) +
      geom_point(aes(color = "With Experiments")) +
      scale_color_manual(values = c("With Experiments" = "blue", 
                                    "Without Experiments" = "red")) +
      ggtitle(title) +
      xlab("Period") +
      ylab(y_label) +
      plot_theme
    
    if (show_no_exp) {  # Conditionally add no experiment data. # v2.1
      p <- p +
        geom_line(data = data_no_exp, aes(x = Period, y = .data[[y_var]], color = "Without Experiments"), linetype = "dashed") +
        geom_point(data = data_no_exp, aes(x = Period, y = .data[[y_var]], color = "Without Experiments"), shape = 1, size = 3)
    }
    return(p)
  }
  
  
  plot_objects <- reactiveValues() # store plots for download. # v2.1
  
  output$plot_K <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "K", 
                   "Capital (K) Over Time", "Capital (K)", input$show_no_exp)
    plot_objects$plot_K <- p # Store the plot object
    p # Return the plot for display
  }, res = 100) # v2.1
  
  output$plot_Y <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "Y", 
                   "Output (Y) Over Time", "Output (Y)", input$show_no_exp)
    plot_objects$plot_Y <- p
    p
  }, res = 100) # v2.1
  
  output$plot_delta_k <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "delta_k", 
                   "Change in Capital (Δk) Over Time", "Δk", input$show_no_exp)
    plot_objects$plot_delta_k <- p
    p
  }, res = 100)  # v2.1
  
  output$plot_little_k <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "little_k", 
                   "Capital Efficiency Units", "k (Capital Efficiency Units)", input$show_no_exp)
    plot_objects$plot_little_k <- p
    p
  }, res = 100)  # v2.1
  
  output$plot_log_L <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "log_L", 
                   "Log of Labor (L) Over Time", "Log(L)", input$show_no_exp)
    plot_objects$plot_log_L <- p
    p
  }, res = 100) # v2.1
  
  output$plot_log_K <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "log_K", 
                   "Log of Capital (K) Over Time", "Log(K)", input$show_no_exp)
    plot_objects$plot_log_K <- p
    p
  }, res = 100) # v2.1
  
  output$plot_log_Y <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "log_Y", 
                   "Log of Output (Y) Over Time", "Log(Y)", input$show_no_exp)
    plot_objects$plot_log_Y <- p
    p
  }, res = 100) # v2.1
  
  output$plot_log_A <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "log_A", 
                   "Log of TFP (A) Over Time", "Log(A)", input$show_no_exp)
    plot_objects$plot_log_A <- p
    p
  }, res = 100) # v2.1
  
  output$plot_percent_delta_k <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "percent_delta_k", 
                   "Change in Capital Over Time", "Δk/k", input$show_no_exp)
    plot_objects$plot_percent_delta_k <- p
    p
  }, res = 100) # v2.1
  
  
  #----------------------------------
  # 6. DOWNLOAD HANDLERS
  #----------------------------------
  
  output$downloadData <- downloadHandler( # version1
    filename = function() {
      paste0("results_", Sys.Date(), ".csv")
    },
    content = function(file) {req(results()) # v2.1
      write.csv(results(), file, row.names = FALSE)
    }
  )
  
  output$downloadPlots <- downloadHandler( # version1
    filename = function() { 
      paste0("plots_", Sys.Date(), ".zip")
    },
    content = function(file) {
      temp_dir <- tempdir() # temp file storage but new shiny update change the way file donwloads happen so this might not be needed now
      file_paths <- c()
      
      # Use the stored plot objects version2
      plots <- reactiveValuesToList(plot_objects) # Convert reactiveValues to list
      plots <- Filter(Negate(is.null), plots) # Remove NULL entries
      
      for (plot_name in names(plots)) { # Save each plot to a PNG version1
        plot_file <- file.path(temp_dir, paste0(plot_name, ".png"))
        ggsave(plot_file, plots[[plot_name]], device = "png")
        file_paths <- c(file_paths, plot_file)
      }
      zipr(zipfile = file, files = file_paths) # zip em. v1
    }
  )
}

shinyApp(ui = ui, server = server)

# v2.3
# I added MPK and MPL using ch6 production function after inclduing research share
# adding percent delta k
# made a few changes to further dummy proof this model


```

# spacer

```{r}
# v3

library(shiny)
library(ggplot2)
library(DT)    # for interactive table
library(zip)   # to create ZIP files in download handler
library(bslib)
library(rio)   # to read the Excel file # v2.2

#--- Helper function to create each experiment set. ---
initializeExperimentSet <- function(
    expSuffix,         # label like "1", "2", "3", or "4"
    paramNameInput,    # e.g. "param_name", "param_name2"
    newValueInput,     # e.g. "new_value", "new_value2"
    startPeriodInput,  # e.g. "start_period", "start_period2"
    lengthInput,       # e.g. "length", "length2"
    addExpButton,      # e.g. "add_experiment", "add_experiment2"
    dtOutput,          # e.g. "experimentsTable", "experimentsTable2"
    deleteRowInput,    # internal ID prefix for deletion, e.g. "delete_1", "delete_2"
    input, output, session
) {
  
  # A reactiveVal to hold the table of experiments for this set
  rv <- reactiveVal(
    data.frame(
      param        = character(0),
      new_value    = numeric(0),
      start_period = integer(0),
      length       = integer(0),
      stringsAsFactors = FALSE
    )
  )
  
  # Add new experiment row when the user clicks
  observeEvent(input[[addExpButton]], {
    new_experiment <- data.frame(
      param        = input[[paramNameInput]],
      new_value    = input[[newValueInput]],
      start_period = input[[startPeriodInput]],
      length       = input[[lengthInput]],
      stringsAsFactors = FALSE
    )
    rv( rbind(rv(), new_experiment) )
  })
  
  # Render the experiments table with "Delete" buttons
  output[[dtOutput]] <- renderDT({
    exps <- rv()
    if (nrow(exps) == 0) return(NULL)
    
    deleteButtons <- sapply(seq_len(nrow(exps)), function(i) {
      as.character(
        actionButton(
          inputId = paste0("delete_", expSuffix, "_", i),
          label = "Delete",
          class = "btn btn-danger btn-sm",
          onclick = paste0(
            'Shiny.setInputValue("delete_', expSuffix, '", this.id, {priority: "event"})'
          )
        )
      )
    })
    
    exps$Delete <- deleteButtons
    
    datatable(
      exps,
      escape = FALSE,
      selection = "none",
      options   = list(pageLength = 5)
    )
  }, server = FALSE)
  
  # Handle row deletions
  observeEvent(input[[paste0("delete_", expSuffix)]], {
    row_str <- gsub(paste0("delete_", expSuffix, "_"), "", input[[paste0("delete_", expSuffix)]])
    row_num <- as.numeric(row_str)
    
    exps <- rv()
    if (!is.na(row_num) && row_num >= 1 && row_num <= nrow(exps)) {
      exps <- exps[-row_num, ]
      rv(exps)
    }
  })
  
  return(rv)
}

#--------------------------------------------------------
#     UI
#--------------------------------------------------------
# app layout and input controls version1
ui <- page_sidebar( # version
  title = "Solow-Romer Macro Simulation",
  sidebar = sidebar( # all the input controls
    width = 600, # edit sidebar width. This is not friendly with smaller screens. I was having trouble with the sidebar overlapping with tabs so I added this to default a sidebar lenght.
    h4("Simulation Parameters"),
    sliderInput("Simulation_Period", "Simulation Period (yrs)", 
                min = 20, max = 150, value = 50, step = 1),
    sliderInput("s", "Savings Rate (s)", min = 0.001, max = 1, value = 0.2, step = 0.01), # v2.3 change to min .001 due to div by zero error
    sliderInput("delta", "Depreciation Rate (delta)", min = 0, max = .5, value = 0.15, step = 0.01),
    sliderInput("n", "n", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("z", "Parameter z", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("l", "Parameter l", min = 0, max = 0.99, value = 0.1, step = 0.01), 
    selectInput("A", "Initial value for A", choices = c(1, 100, 1000), selected = 1), # 343
    selectInput("L", "Initial value for L", choices = c(1, 100, 1000), selected = 1), # 343
    
    h4("Experiments"),
    # v3 adding loop experiment code
    
    # New tabsetPanel to hold experiment tables # v3
    tabsetPanel(  # TabsetPanel for experiments
      tabPanel("Experiments Set 1",
               selectInput("param_name", "Quantitative exp (s, delta, n, z, l)",
                           choices = c("s", "delta", "n", "z", "l"),
                           selected = "s"),
               numericInput("new_value", "New Value", value = 0, step = 0.01),
               numericInput("start_period", "Start Period", value = 5, step = 1),
               numericInput("length", "Length of Effect", value = 5, step = 1),
               actionButton("add_experiment", "Add Exp 1"),
               DTOutput("experimentsTable")
      ),
      tabPanel("Experiments Set 2",
               selectInput("param_name2", "Quantitative exp (s, delta, n, z, l)",
                           choices = c("s", "delta", "n", "z", "l"),
                           selected = "s"),
               numericInput("new_value2", "New Value", value = 0, step = 0.01),
               numericInput("start_period2", "Start Period", value = 5, step = 1),
               numericInput("length2", "Length of Effect", value = 5, step = 1),
               actionButton("add_experiment2", "Add Exp 2"),
               DTOutput("experimentsTable2")
      ),
      tabPanel("Experiments Set 3",
               selectInput("param_name3", "Quantitative exp (s, delta, n, z, l)",
                           choices = c("s", "delta", "n", "z", "l"),
                           selected = "s"),
               numericInput("new_value3", "New Value", value = 0, step = 0.01),
               numericInput("start_period3", "Start Period", value = 5, step = 1),
               numericInput("length3", "Length of Effect", value = 5, step = 1),
               actionButton("add_experiment3", "Add Exp 3"),
               DTOutput("experimentsTable3")
      ),
      tabPanel("Experiments Set 4",
               selectInput("param_name4", "Quantitative exp (s, delta, n, z, l)",
                           choices = c("s", "delta", "n", "z", "l"),
                           selected = "s"),
               numericInput("new_value4", "New Value", value = 0, step = 0.01),
               numericInput("start_period4", "Start Period", value = 5, step = 1),
               numericInput("length4", "Length of Effect", value = 5, step = 1),
               actionButton("add_experiment4", "Add Exp 4"),
               DTOutput("experimentsTable4")
      )
    ),     # end tabsetPanel for experiments # v3
    
    checkboxInput("show_no_exp", "Show Counterfactual", value = TRUE),
    actionButton("simulate", "Simulate"),
    h4("Download Results"),
    DTOutput("experimentsTable"),  # This appears again but just to show in UI
    downloadButton("downloadPlots", "Download All Plots as PNG (ZIP)"),
    downloadButton("downloadData", "Download Data as CSV")
  ),
  mainPanel( # tab controls. v1
    tabsetPanel(
      tabPanel("World", # v 2.2
               # adding option to get average savings rate
               selectInput("selectedSheet", "Select Region", choices = NULL),
               selectInput("selectedColumn", "Select Country", choices = NULL),
               numericInput("startYear", "Start Year", value = 1960),
               numericInput("endYear",   "End Year",   value = 2023),
               actionButton("calculateAvg", "Get Avg Savings Rate 's'"),
               verbatimTextOutput("avgSavingsRate")  # displays the avg s calculated
      ),
      tabPanel("Plots",
               div(style = "width: 1800px; margin: auto;",
                   fluidRow(
                     column(6, plotOutput("plot_K", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_Y", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_little_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_percent_delta_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_MPK", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_MPL", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Log/Ratio scale",
               div(style = "width: 1800px; margin: auto;",
                   fluidRow(
                     column(6, plotOutput("plot_log_L", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_K", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_log_Y", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_A", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Table", tableOutput("resultsTable")),
      tabPanel("No Experiments", tableOutput("resultsNoExpTable")),
      tabPanel("Third Scenario", tableOutput("resultsThirdDfTable")),  # v3: 2nd experiment df
      tabPanel("Fourth Scenario", tableOutput("resultsFourthDfTable")), # v3 
      tabPanel("Fifth Scenario", tableOutput("resultsFifthDfTable"))  # v3
    )
  )
)

#--------------------------------------------------------
#     SERVER # version1
#--------------------------------------------------------
server <- function(input, output, session) {
  
  # adding option for Savings rate average for list of countries. 
  excel_list <- import_list("data/savings_rate_y.xlsx") # v2.2
  
  # Populate region choices
  observe({  # v2.2
    updateSelectInput(session, "selectedSheet", choices = names(excel_list), selected = names(excel_list)[1])
  })
  observeEvent(input$selectedSheet, {  # Update column choices  # v2.2
    df <- excel_list[[input$selectedSheet]]
    updateSelectInput(session, "selectedColumn", choices = setdiff(names(df), "year"), selected = setdiff(names(df), "year")[1])
  })
  
  # find the available years
  observeEvent(input$selectedColumn, { # v2.2
    df <- excel_list[[input$selectedSheet]]
    yearVals <- df$year
    yVals <- as.numeric(df[[input$selectedColumn]])
    valid <- !is.na(yearVals) & !is.na(yVals)
    if (!any(valid)) return()
    validYears <- yearVals[valid]
    minY <- min(validYears)
    maxY <- max(validYears)
    updateNumericInput(session, "startYear", min = minY, max = maxY, value = minY)
    updateNumericInput(session, "endYear",   min = minY, max = maxY, value = maxY)
  })
  
  # Calculate average within the chosen year range
  observeEvent(input$calculateAvg, {
    df <- excel_list[[input$selectedSheet]]
    yearVals <- df$year
    yVals <- as.numeric(df[[input$selectedColumn]])
    valid <- !is.na(yearVals) & !is.na(yVals)
    dfValid <- df[valid, ]
    
    subsetData <- dfValid[dfValid$year >= input$startYear & dfValid$year <= input$endYear, ]
    if (nrow(subsetData) == 0) {  # Check if country has any data
      output$avgSavingsRate <- renderPrint("Country Data Not Available") 
      return()
    }
    
    avgVal <- (mean(subsetData[[input$selectedColumn]]))/100
    updateSliderInput(session, "s", value = avgVal)
    output$avgSavingsRate <- renderPrint(paste("Average Savings Rate:", avgVal)) # Display the average
  }) # v2.2
  
  #----------------------------------
  # EXPERIMENTS TABLE MANAGEMENT # v3 
  #----------------------------------
  # This code along w/ the initializeExperiment function help loop in experiment simulations. 
  
  experiments  <- initializeExperimentSet("1", "param_name",  "new_value",  "start_period",  "length",
                                          "add_experiment",  "experimentsTable",  "delete_1", input, output, session)
  experiments2 <- initializeExperimentSet("2", "param_name2", "new_value2", "start_period2", "length2",
                                          "add_experiment2", "experimentsTable2", "delete_2", input, output, session)
  experiments3 <- initializeExperimentSet("3", "param_name3", "new_value3", "start_period3", "length3",
                                          "add_experiment3", "experimentsTable3", "delete_3", input, output, session)
  experiments4 <- initializeExperimentSet("4", "param_name4", "new_value4", "start_period4", "length4",
                                          "add_experiment4", "experimentsTable4", "delete_4", input, output, session)
  
  
  
  
  #----------------------------------
  # 2. SOLOW SIMULATION
  #----------------------------------
  
  simulate_solow <- function(num_periods, s, delta, n, z, l, A_init, L_init, experiments_df = NULL) {
    params <- data.frame(
      Period   = 0:(num_periods - 1),
      s        = rep(s, num_periods),
      delta    = rep(delta, num_periods),
      n        = rep(n, num_periods),
      z        = rep(z, num_periods),
      l        = rep(l, num_periods),
      delta_k  = rep(0.0, num_periods),
      percent_delta_k = rep(0.0, num_periods),
      little_k = rep(0.0, num_periods),
      A        = rep(A_init, num_periods),
      L        = rep(L_init, num_periods),
      K        = rep(0.0, num_periods),
      Y        = rep(0.0, num_periods)
    )
    
    # Calculate initial Capital per Capita Steady state k* 
    k_star_initial <- (s / (delta + n + z*l))^(1.5)*(1 - l)
    params$little_k[1] <- k_star_initial
    
    # this does the quantitative experiments. version 2.1
    if (!is.null(experiments_df) && nrow(experiments_df) > 0) { # v2.1
      for (exp in seq_len(nrow(experiments_df))) {
        start <- experiments_df$start_period[exp] + 1
        end   <- min(start + experiments_df$length[exp] - 1, num_periods)
        param_name <- experiments_df$param[exp]
        new_value  <- experiments_df$new_value[exp]
        params[start:end, param_name] <- new_value
      }
    }
    
    # Calculation portion. # v2.1
    # the "for (i in seq_len" makes sure all calculations are done in that order once every period. If you need to ask why don't edit this portion. 
    for (i in seq_len(num_periods)) { 
      if (i == 1) { # i=1 corresponds to Period=0 in the df
        params$delta_k[i] <- 0
      } else {
        # i-1 = t - 1
        params$delta_k[i] <- params$s[i] * ( (1 - params$l[i])^(2/3) ) * 
          (params$little_k[i-1]^(1/3)) - 
          (params$z[i] * params$l[i] + params$n[i] + params$delta[i]) * params$little_k[i-1]
        
        params$little_k[i] <- params$little_k[i-1] + params$delta_k[i]
      } # different calculation if period 0 or >0
      
      if (i > 1) {# cant be done till period 1. 
        params$A[i] <- params$A[i-1] * (1 + params$z[i]*params$l[i])
        params$L[i] <- params$L[i-1] * (1 + params$n[i])
      }
      
      # this calculations are done every period
      params$K[i] <- params$little_k[i] * params$A[i] * params$L[i]
      params$Y[i] <- (1 - params$l[i])^(2/3) * params$K[i]^(1/3) * (params$A[i] * params$L[i])^(2/3)
    }
    
    # this calculations are done once the for i loop is done for better app efficiency. 
    params$MPL <- (1 - params$l) * (1 - params$l)^(1 - (1/3)) * params$K^(1/3) * (params$A * params$L)^(1 - (1/3)) / params$L # v2.3 
    params$MPK <- (1/3) * (1 - params$l)^(1 - (1/3)) * params$K^(1/3) * (params$A * params$L)^(1 - (1/3)) / params$K # v2.3 
    params$log_L <- log(params$L)
    params$log_K <- log(params$K)
    params$log_Y <- log(params$Y)
    params$log_A <- log(params$A)
    params$percent_delta_k <- (params$delta_k / params$little_k) * 100 # v2.3
    
    params # v3. before v3, this was return(params)
    # when adding calc that need plots = add to tabpanel, and both codes.
  }
  
  #----------------------------------
  # EVENT-REACTIVE RESULTS
  #----------------------------------
  # v3: this code  is the simulation code. 
  # this made some changes to my results, and results_no_exp, and the 3 new df
  
  results <- eventReactive(input$simulate, { # v2.1
    # If first set is empty, show a modal (original logic)
    if (nrow(experiments()) == 0) {
      showModal(modalDialog(
        title = "Error",
        "Please add at least one experiment in Set 1 before running the simulation.",
        easyClose = TRUE,
        footer = NULL
      ))
      return(NULL)
    }
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    
    # v3: streamline this section of the simulate_solow.
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l, 
                   A_init, L_init, experiments_df = experiments()) # v3
  })
  
  results_no_exp <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l, 
                   A_init, L_init, experiments_df = NULL) # v3
  })
  
  # v3: adding the 3 extra experiment simulations
  results_third_df <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    if (nrow(experiments2()) == 0) {
      showModal(modalDialog(
        title = "Warning",
        "Experiments Set 2 is empty. Using no experiments in the third scenario.",
        easyClose = TRUE,
        footer = NULL
      ))
      return(simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                            A_init, L_init, experiments_df = NULL))
    }
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l, 
                   A_init, L_init, experiments_df = experiments2())
  })
  
  results_fourth_df <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    experiments_df_to_use <- if (nrow(experiments3()) == 0) NULL else experiments3()
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiments_df_to_use)
  })
  
  results_fifth_df <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    experiments_df_to_use <- if (nrow(experiments4()) == 0) NULL else experiments4()
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiments_df_to_use)
  })
  
  # v3: end of 2nd experiment simulation code
  
  
  #----------------------------------
  # 4. OUTPUT: TABLES
  #----------------------------------
  
  # v3 not much change from before v3c for results, and results_no_exp, but
  # added the 3 results tables for the other experiments
  output$resultsTable <- renderTable({req(results()); 
    results()}, rownames = FALSE) # v3
  output$resultsNoExpTable <- renderTable({ req(results_no_exp()) ; 
    results_no_exp() }, rownames = FALSE) # v3
  output$resultsThirdDfTable <- renderTable({ req(results_third_df()); 
    results_third_df() }, rownames = FALSE) # v3
  output$resultsFourthDfTable<- renderTable({ req(results_fourth_df()); 
    results_fourth_df() }, rownames = FALSE) # v3
  output$resultsFifthDfTable <- renderTable({ req(results_fifth_df()); 
    results_fifth_df() }, rownames = FALSE) # v3
  
  #----------------------------------
  # PLOTS
  #----------------------------------
  
  # aesthetics for each plot
  plot_theme <- theme_bw() + 
    theme(plot.title   = element_text(hjust = 0.5),
          axis.title   = element_text(size = 12),
          axis.text    = element_text(size = 10),
          panel.grid.major = element_line(color = "grey80"),
          panel.grid.minor = element_blank(),
          strip.background = element_rect(fill = "grey90", color = "grey90"))
  
  # function to generate each plot. # v2
  make_plot <- function(data_exp, data_no_exp, y_var, title, y_label, show_no_exp) {
    p <- ggplot(data_exp, aes(x = Period, y = .data[[y_var]])) + # Base plot with experiment data
      geom_line(aes(color = "With Experiments")) +
      geom_point(aes(color = "With Experiments")) +
      scale_color_manual(values = c("With Experiments" = "blue", 
                                    "Without Experiments" = "red")) +
      ggtitle(title) +
      xlab("Period") +
      ylab(y_label) +
      plot_theme
    
    if (show_no_exp) {  # Conditionally add no experiment data. # v2.1
      p <- p +
        geom_line(data = data_no_exp, aes(x = Period, y = .data[[y_var]], color = "Without Experiments"), linetype = "dashed") +
        geom_point(data = data_no_exp, aes(x = Period, y = .data[[y_var]], color = "Without Experiments"), shape = 1, size = 3)
    }
    p # v3: before v3 it was this: return(p)
  }
  
  
  plot_objects <- reactiveValues() # store plots for download. # v2.1
  
  output$plot_K <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "K", 
                   "Capital (K) Over Time", "Capital (K)", input$show_no_exp)
    plot_objects$plot_K <- p # Store the plot object
    p # Return the plot for display
  }, res = 100) # v2.1
  
  output$plot_Y <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "Y", 
                   "Output (Y) Over Time", "Output (Y)", input$show_no_exp)
    plot_objects$plot_Y <- p
    p
  }, res = 100) # v2.1
  
  output$plot_delta_k <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "delta_k", 
                   "Change in Capital (Δk) Over Time", "Δk", input$show_no_exp)
    plot_objects$plot_delta_k <- p
    p
  }, res = 100)  # v2.1
  
  output$plot_little_k <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "little_k", 
                   "Capital Efficiency Units", "k (Capital Efficiency Units)", input$show_no_exp)
    plot_objects$plot_little_k <- p
    p
  }, res = 100)  # v2.1
  
  output$plot_log_L <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "log_L", 
                   "Log of Labor (L) Over Time", "Log(L)", input$show_no_exp)
    plot_objects$plot_log_L <- p
    p
  }, res = 100) # v2.1
  
  output$plot_log_K <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "log_K", 
                   "Log of Capital (K) Over Time", "Log(K)", input$show_no_exp)
    plot_objects$plot_log_K <- p
    p
  }, res = 100) # v2.1
  
  output$plot_log_Y <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "log_Y", 
                   "Log of Output (Y) Over Time", "Log(Y)", input$show_no_exp)
    plot_objects$plot_log_Y <- p
    p
  }, res = 100) # v2.1
  
  output$plot_log_A <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "log_A", 
                   "Log of TFP (A) Over Time", "Log(A)", input$show_no_exp)
    plot_objects$plot_log_A <- p
    p
  }, res = 100) # v2.1
  
  output$plot_percent_delta_k <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "percent_delta_k", 
                   "Percent Change in Capital Over Time", "Δk/k", input$show_no_exp)
    plot_objects$plot_percent_delta_k <- p
    p
  }, res = 100) # v2.3
  
  output$plot_MPL <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "MPL", 
                   "Marginal Product of Labor Over Time", "MPL", input$show_no_exp)
    plot_objects$plot_MPL <- p
    p
  }, res = 100) # v2.3.1
  
  output$plot_MPK <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "MPK", 
                   "Marginal Product of Capital Over Time", "MPK", input$show_no_exp)
    plot_objects$plot_MPK <- p
    p
  }, res = 100) # v2.3.1
  
  
  
  #----------------------------------
  # DOWNLOAD HANDLERS
  #----------------------------------
  output$downloadData <- downloadHandler( # version1
    filename = function() {
      paste0("results_", Sys.Date(), ".csv")
    },
    content = function(file) {req(results()) # v2.1
      write.csv(results(), file, row.names = FALSE)
    }
  )
  
  output$downloadPlots <- downloadHandler( # version1
    filename = function() { 
      paste0("plots_", Sys.Date(), ".zip")
    },
    content = function(file) {
      temp_dir <- tempdir() # temp file storage but new shiny update change the way file downloads happen so this might not be needed now
      file_paths <- c()
      
      # Use the stored plot objects version2
      plots <- reactiveValuesToList(plot_objects) # Convert reactiveValues to list
      plots <- Filter(Negate(is.null), plots) # Remove NULL entries
      
      for (plot_name in names(plots)) { # Save each plot to a PNG version1
        plot_file <- file.path(temp_dir, paste0(plot_name, ".png"))
        ggsave(plot_file, plots[[plot_name]], device = "png")
        file_paths <- c(file_paths, plot_file)
      }
      zipr(zipfile = file, files = file_paths) # zip em. v1
    }
  )
}

shinyApp(ui = ui, server = server)

# v3

# adding multiple data frames.
# Added 3 New Data Simulations.
# Streamlined Experiment Table Management.
# Expanded UI for New Simulations.





```

# spacer

```{r}
# v3.1
library(shiny)
library(ggplot2)
library(DT)    # for interactive table
library(zip)   # to create ZIP files in download handler
library(bslib)
library(rio)   # to read the Excel file # v2.2

#--- Helper function to create each experiment set. ---
initializeExperimentSet <- function(
    expSuffix,         # label like "1", "2", "3", or "4"
    paramNameInput,    # e.g. "param_name", "param_name2"
    newValueInput,     # e.g. "new_value", "new_value2"
    startPeriodInput,  # e.g. "start_period", "start_period2"
    lengthInput,       # e.g. "length", "length2"
    addExpButton,      # e.g. "add_experiment", "add_experiment2"
    dtOutput,          # e.g. "experimentsTable", "experimentsTable2"
    deleteRowInput,    # internal ID prefix for deletion, e.g. "delete_1", "delete_2"
    input, output, session
) {
  
  # A reactiveVal to hold the table of experiments for this set
  rv <- reactiveVal(
    data.frame(
      param        = character(0),
      new_value    = numeric(0),
      start_period = integer(0),
      length       = integer(0),
      stringsAsFactors = FALSE
    )
  )
  
  # Add new experiment row when the user clicks
  observeEvent(input[[addExpButton]], {
    new_experiment <- data.frame(
      param        = input[[paramNameInput]],
      new_value    = input[[newValueInput]],
      start_period = input[[startPeriodInput]],
      length       = input[[lengthInput]],
      stringsAsFactors = FALSE
    )
    rv( rbind(rv(), new_experiment) )
  })
  
  # Render the experiments table with "Delete" buttons
  output[[dtOutput]] <- renderDT({
    exps <- rv()
    if (nrow(exps) == 0) return(NULL)
    
    deleteButtons <- sapply(seq_len(nrow(exps)), function(i) {
      as.character(
        actionButton(
          inputId = paste0("delete_", expSuffix, "_", i),
          label = "Delete",
          class = "btn btn-danger btn-sm",
          onclick = paste0(
            'Shiny.setInputValue("delete_', expSuffix, '", this.id, {priority: "event"})'
          )
        )
      )
    })
    
    exps$Delete <- deleteButtons
    
    datatable(
      exps,
      escape = FALSE,
      selection = "none",
      options   = list(pageLength = 5)
    )
  }, server = FALSE)
  
  # Handle row deletions
  observeEvent(input[[paste0("delete_", expSuffix)]], {
    row_str <- gsub(paste0("delete_", expSuffix, "_"), "", input[[paste0("delete_", expSuffix)]])
    row_num <- as.numeric(row_str)
    
    exps <- rv()
    if (!is.na(row_num) && row_num >= 1 && row_num <= nrow(exps)) {
      exps <- exps[-row_num, ]
      rv(exps)
    }
  })
  
  return(rv)
}

#--------------------------------------------------------
#     UI
#--------------------------------------------------------
# app layout and input controls version1
ui <- page_sidebar( # version
  title = "Solow-Romer Macro Simulation",
  sidebar = sidebar( # all the input controls
    width = 600, # edit sidebar width. This is not friendly with smaller screens. I was having trouble with the sidebar overlapping with tabs so I added this to default a sidebar lenght.
    h4("Simulation Parameters"),
    sliderInput("Simulation_Period", "Simulation Period (yrs)", 
                min = 20, max = 150, value = 50, step = 1),
    sliderInput("s", "Savings Rate (s)", min = 0.001, max = 1, value = 0.2, step = 0.01), # v2.3 change to min .001 due to div by zero error
    sliderInput("delta", "Depreciation Rate (delta)", min = 0, max = .5, value = 0.15, step = 0.01),
    sliderInput("n", "n", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("z", "Parameter z", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("l", "Parameter l", min = 0, max = 0.99, value = 0.1, step = 0.01), 
    selectInput("A", "Initial value for A", choices = c(1, 100, 1000), selected = 1), # 343
    selectInput("L", "Initial value for L", choices = c(1, 100, 1000), selected = 1), # 343
    
    h4("Experiments"),
    # v3 move experiment loop to its own tab
    
    checkboxInput("show_no_exp", "Show Counterfactual", value = TRUE),
    actionButton("simulate", "Simulate"),
    h4("Download Results"),
    downloadButton("downloadPlots", "Download All Plots as PNG (ZIP)"),
    downloadButton("downloadData", "Download Data as CSV")
  ),
  mainPanel( # tab controls. v1
    tabsetPanel(
      tabPanel("World", # v 2.2
               # adding option to get average savings rate
               selectInput("selectedSheet", "Select Region", choices = NULL),
               selectInput("selectedColumn", "Select Country", choices = NULL),
               numericInput("startYear", "Start Year", value = 1960),
               numericInput("endYear",   "End Year",   value = 2023),
               actionButton("calculateAvg", "Get Avg Savings Rate 's'"),
               verbatimTextOutput("avgSavingsRate")  # displays the avg s calculated
      ),
      
      # v3.1: adding experiment to mainpanel
      tabPanel("Experiments", # Experiments Tab Panel - NEW
               fluidRow(
                 column(width = 6, # First column for Experiment Set 1 and 2
                        tabsetPanel( # TabsetPanel for experiments - MOVED FROM SIDEBAR
                          tabPanel("Experiments Set 1",
                                   selectInput("param_name", "Quantitative exp (s, delta, n, z, l)",
                                               choices = c("s", "delta", "n", "z", "l"),
                                               selected = "s"),
                                   numericInput("new_value", "New Value", value = 0, step = 0.01),
                                   numericInput("start_period", "Start Period", value = 5, step = 1),
                                   numericInput("length", "Length of Effect", value = 5, step = 1),
                                   actionButton("add_experiment", "Add Exp 1"),
                                   fileInput("upload_file_1", "Upload Excel for Exp 1", accept = c(".xlsx", ".xls")),
                                   div(style = "width: 400px;", DTOutput("experimentsTable")) # Fixed width
                          ),
                          tabPanel("Experiments Set 2",
                                   selectInput("param_name2", "Quantitative exp (s, delta, n, z, l)",
                                               choices = c("s", "delta", "n", "z", "l"),
                                               selected = "s"),
                                   numericInput("new_value2", "New Value", value = 0, step = 0.01),
                                   numericInput("start_period2", "Start Period", value = 5, step = 1),
                                   numericInput("length2", "Length of Effect", value = 5, step = 1),
                                   actionButton("add_experiment2", "Add Exp 2"),
                                   fileInput("upload_file_2", "Upload Excel for Exp 2", accept = c(".xlsx", ".xls")),
                                   div(style = "width: 400px;", DTOutput("experimentsTable2")) # Fixed width
                          )
                        )
                 ),
                 column(width = 6, # Second column for Experiment Set 3 and 4
                        tabsetPanel( # TabsetPanel for experiments - MOVED FROM SIDEBAR
                          tabPanel("Experiments Set 3",
                                   selectInput("param_name3", "Quantitative exp (s, delta, n, z, l)",
                                               choices = c("s", "delta", "n", "z", "l"),
                                               selected = "s"),
                                   numericInput("new_value3", "New Value", value = 0, step = 0.01),
                                   numericInput("start_period3", "Start Period", value = 5, step = 1),
                                   numericInput("length3", "Length of Effect", value = 5, step = 1),
                                   actionButton("add_experiment3", "Add Exp 3"),
                                   fileInput("upload_file_3", "Upload Excel for Exp 3", accept = c(".xlsx", ".xls")),
                                   div(style = "width: 400px;", DTOutput("experimentsTable3")) # Fixed width
                          ),
                          tabPanel("Experiments Set 4",
                                   selectInput("param_name4", "Quantitative exp (s, delta, n, z, l)",
                                               choices = c("s", "delta", "n", "z", "l"),
                                               selected = "s"),
                                   numericInput("new_value4", "New Value", value = 0, step = 0.01),
                                   numericInput("start_period4", "Start Period", value = 5, step = 1),
                                   numericInput("length4", "Length of Effect", value = 5, step = 1),
                                   actionButton("add_experiment4", "Add Exp 4"),
                                   fileInput("upload_file_3", "Upload Excel for Exp 3", accept = c(".xlsx", ".xls")),
                                   div(style = "width: 400px;", DTOutput("experimentsTable4")) # Fixed width
                          )
                        )
                 )
               )
      ),
      tabPanel("Plots",
               div(style = "width: 1800px; margin: auto;",
                   fluidRow(
                     column(6, plotOutput("plot_K", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_Y", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_little_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_percent_delta_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_MPK", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_MPL", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Log/Ratio scale",
               div(style = "width: 1800px; margin: auto;",
                   fluidRow(
                     column(6, plotOutput("plot_log_L", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_K", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_log_Y", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_A", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Table", tableOutput("resultsTable")),
      tabPanel("No Experiments", tableOutput("resultsNoExpTable")),
      tabPanel("Third Scenario", tableOutput("resultsThirdDfTable")),  # v3: 2nd experiment df
      tabPanel("Fourth Scenario", tableOutput("resultsFourthDfTable")), # v3 
      tabPanel("Fifth Scenario", tableOutput("resultsFifthDfTable"))  # v3
    )
  )
)

#--------------------------------------------------------
#     SERVER # version1
#--------------------------------------------------------
server <- function(input, output, session) {
  
  # adding option for Savings rate average for list of countries. 
  excel_list <- import_list("data/savings_rate_y.xlsx") # v2.2
  
  # Populate region choices
  observe({  # v2.2
    updateSelectInput(session, "selectedSheet", choices = names(excel_list), selected = names(excel_list)[1])
  })
  observeEvent(input$selectedSheet, {  # Update column choices  # v2.2
    df <- excel_list[[input$selectedSheet]]
    updateSelectInput(session, "selectedColumn", choices = setdiff(names(df), "year"), selected = setdiff(names(df), "year")[1])
  })
  
  # find the available years
  observeEvent(input$selectedColumn, { # v2.2
    df <- excel_list[[input$selectedSheet]]
    yearVals <- df$year
    yVals <- as.numeric(df[[input$selectedColumn]])
    valid <- !is.na(yearVals) & !is.na(yVals)
    if (!any(valid)) return()
    validYears <- yearVals[valid]
    minY <- min(validYears)
    maxY <- max(validYears)
    updateNumericInput(session, "startYear", min = minY, max = maxY, value = minY)
    updateNumericInput(session, "endYear",   min = minY, max = maxY, value = maxY)
  })
  
  # Calculate average within the chosen year range
  observeEvent(input$calculateAvg, {
    df <- excel_list[[input$selectedSheet]]
    yearVals <- df$year
    yVals <- as.numeric(df[[input$selectedColumn]])
    valid <- !is.na(yearVals) & !is.na(yVals)
    dfValid <- df[valid, ]
    
    subsetData <- dfValid[dfValid$year >= input$startYear & dfValid$year <= input$endYear, ]
    if (nrow(subsetData) == 0) {  # Check if country has any data
      output$avgSavingsRate <- renderPrint("Country Data Not Available") 
      return()
    }
    
    avgVal <- (mean(subsetData[[input$selectedColumn]]))/100
    updateSliderInput(session, "s", value = avgVal)
    output$avgSavingsRate <- renderPrint(paste("Average Savings Rate:", avgVal)) # Display the average
  }) # v2.2
  
  #----------------------------------
  # EXPERIMENTS TABLE MANAGEMENT # v3 
  #----------------------------------
  # This code along w/ the initializeExperiment function help loop in experiment simulations. 
  
  experiments  <- initializeExperimentSet("1", "param_name",  "new_value",  "start_period",  "length",
                                          "add_experiment",  "experimentsTable",  "delete_1", input, output, session)
  experiments2 <- initializeExperimentSet("2", "param_name2", "new_value2", "start_period2", "length2",
                                          "add_experiment2", "experimentsTable2", "delete_2", input, output, session)
  experiments3 <- initializeExperimentSet("3", "param_name3", "new_value3", "start_period3", "length3",
                                          "add_experiment3", "experimentsTable3", "delete_3", input, output, session)
  experiments4 <- initializeExperimentSet("4", "param_name4", "new_value4", "start_period4", "length4",
                                          "add_experiment4", "experimentsTable4", "delete_4", input, output, session)
  
  
  # v3.1: adding excel upload for faster param inputs
  observeEvent(input$upload_file_1, {
    req(input$upload_file_1)
    df_uploaded <- import(input$upload_file_1$datapath)
    
    # Optional: validate that the required columns exist
    required_cols <- c("param", "new_value", "start_period", "length")
    if (!all(required_cols %in% names(df_uploaded))) {
      showModal(modalDialog(
        title = "Error",
        "The uploaded file must contain columns: param, new_value, start_period, length.",
        easyClose = TRUE
      ))
      return(NULL)
    }
    
    # Append the uploaded rows to the existing experiment data
    current_data <- experiments()
    updated_data <- rbind(current_data, df_uploaded)
    experiments(updated_data)
  }) # v3.1 end 
  
  
  #----------------------------------
  # 2. SOLOW SIMULATION
  #----------------------------------
  
  simulate_solow <- function(num_periods, s, delta, n, z, l, A_init, L_init, experiments_df = NULL) {
    params <- data.frame(
      Period   = 0:(num_periods - 1),
      s        = rep(s, num_periods),
      delta    = rep(delta, num_periods),
      n        = rep(n, num_periods),
      z        = rep(z, num_periods),
      l        = rep(l, num_periods),
      delta_k  = rep(0.0, num_periods),
      percent_delta_k = rep(0.0, num_periods),
      little_k = rep(0.0, num_periods),
      A        = rep(A_init, num_periods),
      L        = rep(L_init, num_periods),
      K        = rep(0.0, num_periods),
      Y        = rep(0.0, num_periods)
    )
    
    # Calculate initial Capital per Capita Steady state k* 
    k_star_initial <- (s / (delta + n + z*l))^(1.5)*(1 - l)
    params$little_k[1] <- k_star_initial
    
    # this does the quantitative experiments. version 2.1
    if (!is.null(experiments_df) && nrow(experiments_df) > 0) { # v2.1
      for (exp in seq_len(nrow(experiments_df))) {
        start <- experiments_df$start_period[exp] + 1
        end   <- min(start + experiments_df$length[exp] - 1, num_periods)
        param_name <- experiments_df$param[exp]
        new_value  <- experiments_df$new_value[exp]
        params[start:end, param_name] <- new_value
      }
    }
    
    # Calculation portion. # v2.1
    # the "for (i in seq_len" makes sure all calculations are done in that order once every period. If you need to ask why don't edit this portion. 
    for (i in seq_len(num_periods)) { 
      if (i == 1) { # i=1 corresponds to Period=0 in the df
        params$delta_k[i] <- 0
      } else {
        # i-1 = t - 1
        params$delta_k[i] <- params$s[i] * ( (1 - params$l[i])^(2/3) ) * 
          (params$little_k[i-1]^(1/3)) - 
          (params$z[i] * params$l[i] + params$n[i] + params$delta[i]) * params$little_k[i-1]
        
        params$little_k[i] <- params$little_k[i-1] + params$delta_k[i]
      } # different calculation if period 0 or >0
      
      if (i > 1) {# cant be done till period 1. 
        params$A[i] <- params$A[i-1] * (1 + params$z[i]*params$l[i])
        params$L[i] <- params$L[i-1] * (1 + params$n[i])
      }
      
      # this calculations are done every period
      params$K[i] <- params$little_k[i] * params$A[i] * params$L[i]
      params$Y[i] <- (1 - params$l[i])^(2/3) * params$K[i]^(1/3) * (params$A[i] * params$L[i])^(2/3)
    }
    
    # this calculations are done once the for i loop is done for better app efficiency. 
    params$MPL <- (1 - params$l) * (1 - params$l)^(1 - (1/3)) * params$K^(1/3) * (params$A * params$L)^(1 - (1/3)) / params$L # v2.3 
    params$MPK <- (1/3) * (1 - params$l)^(1 - (1/3)) * params$K^(1/3) * (params$A * params$L)^(1 - (1/3)) / params$K # v2.3 
    params$log_L <- log(params$L)
    params$log_K <- log(params$K)
    params$log_Y <- log(params$Y)
    params$log_A <- log(params$A)
    params$percent_delta_k <- (params$delta_k / params$little_k) * 100 # v2.3
    
    params # v3. before v3, this was return(params)
    # when adding calc that need plots = add to tabpanel, and both codes.
  }
  
  #----------------------------------
  # EVENT-REACTIVE RESULTS
  #----------------------------------
  # v3: this code  is the simulation code. 
  # this made some changes to my results, and results_no_exp, and the 3 new df
  
  results <- eventReactive(input$simulate, { # v2.1
    # If first set is empty, show a modal (original logic)
    if (nrow(experiments()) == 0) {
      showModal(modalDialog(
        title = "Error",
        "Please add at least one experiment in Set 1 before running the simulation.",
        easyClose = TRUE,
        footer = NULL
      ))
      return(NULL)
    }
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    
    # v3: streamline this section of the simulate_solow.
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l, 
                   A_init, L_init, experiments_df = experiments()) # v3
  })
  
  results_no_exp <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l, 
                   A_init, L_init, experiments_df = NULL) # v3
  })
  
  # v3: adding the 3 extra experiment simulations
  results_third_df <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    if (nrow(experiments2()) == 0) {
      showModal(modalDialog(
        title = "Warning",
        "Experiments Set 2 is empty. Using no experiments in the third scenario.",
        easyClose = TRUE,
        footer = NULL
      ))
      return(simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                            A_init, L_init, experiments_df = NULL))
    }
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l, 
                   A_init, L_init, experiments_df = experiments2())
  })
  
  results_fourth_df <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    experiments_df_to_use <- if (nrow(experiments3()) == 0) NULL else experiments3()
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiments_df_to_use)
  })
  
  results_fifth_df <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    experiments_df_to_use <- if (nrow(experiments4()) == 0) NULL else experiments4()
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiments_df_to_use)
  })
  
  # v3: end of 2nd experiment simulation code
  
  
  #----------------------------------
  # 4. OUTPUT: TABLES
  #----------------------------------
  
  # v3 not much change from before v3c for results, and results_no_exp, but
  # added the 3 results tables for the other experiments
  output$resultsTable <- renderTable({req(results()); 
    results()}, rownames = FALSE) # v3
  output$resultsNoExpTable <- renderTable({ req(results_no_exp()) ; 
    results_no_exp() }, rownames = FALSE) # v3
  output$resultsThirdDfTable <- renderTable({ req(results_third_df()); 
    results_third_df() }, rownames = FALSE) # v3
  output$resultsFourthDfTable<- renderTable({ req(results_fourth_df()); 
    results_fourth_df() }, rownames = FALSE) # v3
  output$resultsFifthDfTable <- renderTable({ req(results_fifth_df()); 
    results_fifth_df() }, rownames = FALSE) # v3
  
  #----------------------------------
  # PLOTS
  #----------------------------------
  
  # aesthetics for each plot
  plot_theme <- theme_bw() + 
    theme(plot.title   = element_text(hjust = 0.5),
          axis.title   = element_text(size = 12),
          axis.text    = element_text(size = 10),
          panel.grid.major = element_line(color = "grey80"),
          panel.grid.minor = element_blank(),
          strip.background = element_rect(fill = "grey90", color = "grey90"))
  
  # function to generate each plot. # v2
  make_plot <- function(data_exp, data_no_exp, y_var, title, y_label, show_no_exp) {
    p <- ggplot(data_exp, aes(x = Period, y = .data[[y_var]])) + # Base plot with experiment data
      geom_line(aes(color = "With Experiments")) +
      geom_point(aes(color = "With Experiments")) +
      scale_color_manual(values = c("With Experiments" = "blue", 
                                    "Without Experiments" = "red")) +
      ggtitle(title) +
      xlab("Period") +
      ylab(y_label) +
      plot_theme
    
    if (show_no_exp) {  # Conditionally add no experiment data. # v2.1
      p <- p +
        geom_line(data = data_no_exp, aes(x = Period, y = .data[[y_var]], color = "Without Experiments"), linetype = "dashed") +
        geom_point(data = data_no_exp, aes(x = Period, y = .data[[y_var]], color = "Without Experiments"), shape = 1, size = 3)
    }
    p # v3: before v3 it was this: return(p)
  }
  
  
  plot_objects <- reactiveValues() # store plots for download. # v2.1
  
  output$plot_K <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "K", 
                   "Capital (K) Over Time", "Capital (K)", input$show_no_exp)
    plot_objects$plot_K <- p # Store the plot object
    p # Return the plot for display
  }, res = 100) # v2.1
  
  output$plot_Y <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "Y", 
                   "Output (Y) Over Time", "Output (Y)", input$show_no_exp)
    plot_objects$plot_Y <- p
    p
  }, res = 100) # v2.1
  
  output$plot_delta_k <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "delta_k", 
                   "Change in Capital (Δk) Over Time", "Δk", input$show_no_exp)
    plot_objects$plot_delta_k <- p
    p
  }, res = 100)  # v2.1
  
  output$plot_little_k <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "little_k", 
                   "Capital Efficiency Units", "k (Capital Efficiency Units)", input$show_no_exp)
    plot_objects$plot_little_k <- p
    p
  }, res = 100)  # v2.1
  
  output$plot_log_L <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "log_L", 
                   "Log of Labor (L) Over Time", "Log(L)", input$show_no_exp)
    plot_objects$plot_log_L <- p
    p
  }, res = 100) # v2.1
  
  output$plot_log_K <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "log_K", 
                   "Log of Capital (K) Over Time", "Log(K)", input$show_no_exp)
    plot_objects$plot_log_K <- p
    p
  }, res = 100) # v2.1
  
  output$plot_log_Y <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "log_Y", 
                   "Log of Output (Y) Over Time", "Log(Y)", input$show_no_exp)
    plot_objects$plot_log_Y <- p
    p
  }, res = 100) # v2.1
  
  output$plot_log_A <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "log_A", 
                   "Log of TFP (A) Over Time", "Log(A)", input$show_no_exp)
    plot_objects$plot_log_A <- p
    p
  }, res = 100) # v2.1
  
  output$plot_percent_delta_k <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "percent_delta_k", 
                   "Percent Change in Capital Over Time", "Δk/k", input$show_no_exp)
    plot_objects$plot_percent_delta_k <- p
    p
  }, res = 100) # v2.3
  
  output$plot_MPL <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "MPL", 
                   "Marginal Product of Labor Over Time", "MPL", input$show_no_exp)
    plot_objects$plot_MPL <- p
    p
  }, res = 100) # v2.3.1
  
  output$plot_MPK <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "MPK", 
                   "Marginal Product of Capital Over Time", "MPK", input$show_no_exp)
    plot_objects$plot_MPK <- p
    p
  }, res = 100) # v2.3.1
  
  
  
  #----------------------------------
  # DOWNLOAD HANDLERS
  #----------------------------------
  output$downloadData <- downloadHandler( # version1
    filename = function() {
      paste0("results_", Sys.Date(), ".csv")
    },
    content = function(file) {req(results()) # v2.1
      write.csv(results(), file, row.names = FALSE)
    }
  )
  
  output$downloadPlots <- downloadHandler( # version1
    filename = function() { 
      paste0("plots_", Sys.Date(), ".zip")
    },
    content = function(file) {
      temp_dir <- tempdir() # temp file storage but new shiny update change the way file downloads happen so this might not be needed now
      file_paths <- c()
      
      # Use the stored plot objects version2
      plots <- reactiveValuesToList(plot_objects) # Convert reactiveValues to list
      plots <- Filter(Negate(is.null), plots) # Remove NULL entries
      
      for (plot_name in names(plots)) { # Save each plot to a PNG version1
        plot_file <- file.path(temp_dir, paste0(plot_name, ".png"))
        ggsave(plot_file, plots[[plot_name]], device = "png")
        file_paths <- c(file_paths, plot_file)
      }
      zipr(zipfile = file, files = file_paths) # zip em. v1
    }
  )
}

shinyApp(ui = ui, server = server)

# v3.1

# move experiment tables to new data frame
# added option to upload excel file with experiments!!!
# This is great but I need to make it an option for the user to select how many experiments they want to do, and now have them automatically come up.
```

# spacer

```{r}
# v3.2
library(shiny)
library(ggplot2)
library(DT)    # for interactive table
library(zip)   # to create ZIP files in download handler
library(bslib)
library(rio)   # to read the Excel file # v2.2

#--- Helper function to create each experiment set. ---
initializeExperimentSet <- function(
    expSuffix,         # label like "1", "2", "3", or "4"
    paramNameInput,    # e.g. "param_name", "param_name2"
    newValueInput,     # e.g. "new_value", "new_value2"
    startPeriodInput,  # e.g. "start_period", "start_period2"
    lengthInput,       # e.g. "length", "length2"
    addExpButton,      # e.g. "add_experiment", "add_experiment2"
    dtOutput,          # e.g. "experimentsTable", "experimentsTable2"
    deleteRowInput,    # internal ID prefix for deletion, e.g. "delete_1", "delete_2"
    input, output, session
) {
  
  # A reactiveVal to hold the table of experiments for this set
  rv <- reactiveVal(
    data.frame(
      param        = character(0),
      new_value    = numeric(0),
      start_period = integer(0),
      length       = integer(0),
      stringsAsFactors = FALSE
    )
  )
  
  # Add new experiment row when the user clicks
  observeEvent(input[[addExpButton]], {
    new_experiment <- data.frame(
      param        = input[[paramNameInput]],
      new_value    = input[[newValueInput]],
      start_period = input[[startPeriodInput]],
      length       = input[[lengthInput]],
      stringsAsFactors = FALSE
    )
    rv( rbind(rv(), new_experiment) )
  })
  
  # Render the experiments table with "Delete" buttons
  output[[dtOutput]] <- renderDT({
    exps <- rv()
    if (nrow(exps) == 0) return(NULL)
    
    deleteButtons <- sapply(seq_len(nrow(exps)), function(i) {
      as.character(
        actionButton(
          inputId = paste0("delete_", expSuffix, "_", i),
          label = "Delete",
          class = "btn btn-danger btn-sm",
          onclick = paste0(
            'Shiny.setInputValue("delete_', expSuffix, '", this.id, {priority: "event"})'
          )
        )
      )
    })
    
    exps$Delete <- deleteButtons
    
    datatable(
      exps,
      escape = FALSE,
      selection = "none",
      options   = list(pageLength = 5)
    )
  }, server = FALSE)
  
  # Handle row deletions
  observeEvent(input[[paste0("delete_", expSuffix)]], {
    row_str <- gsub(paste0("delete_", expSuffix, "_"), "", input[[paste0("delete_", expSuffix)]])
    row_num <- as.numeric(row_str)
    
    exps <- rv()
    if (!is.na(row_num) && row_num >= 1 && row_num <= nrow(exps)) {
      exps <- exps[-row_num, ]
      rv(exps)
    }
  })
  
  return(rv)
}

#--------------------------------------------------------
#     UI
#--------------------------------------------------------
# app layout and input controls version1
ui <- page_sidebar( # version
  title = "Solow-Romer Macro Simulation",
  sidebar = sidebar( # all the input controls
    width = 600, # edit sidebar width. This is not friendly with smaller screens. I was having trouble with the sidebar overlapping with tabs so I added this to default a sidebar lenght.
    h4("Simulation Parameters"),
    sliderInput("Simulation_Period", "Simulation Period (yrs)", 
                min = 20, max = 150, value = 50, step = 1),
    sliderInput("s", "Savings Rate (s)", min = 0.001, max = 1, value = 0.2, step = 0.01), # v2.3 change to min .001 due to div by zero error
    sliderInput("delta", "Depreciation Rate (delta)", min = 0, max = .5, value = 0.15, step = 0.01),
    sliderInput("n", "n", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("z", "Parameter z", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("l", "Parameter l", min = 0, max = 0.99, value = 0.1, step = 0.01), 
    selectInput("A", "Initial value for A", choices = c(1, 100, 1000), selected = 1), # 343
    selectInput("L", "Initial value for L", choices = c(1, 100, 1000), selected = 1), # 343
    
    h4("Experiments"),
    # v3 move experiment loop to its own tab
    
    checkboxInput("show_no_exp", "Show Counterfactual", value = TRUE),
    actionButton("simulate", "Simulate"),
    h4("Download Results"),
    downloadButton("downloadPlots", "Download All Plots as PNG (ZIP)"),
    downloadButton("downloadData", "Download Data as CSV")
  ),
  mainPanel( # tab controls. v1
    tabsetPanel(
      tabPanel("World", # v 2.2
               # adding option to get average savings rate
               selectInput("selectedSheet", "Select Region", choices = NULL),
               selectInput("selectedColumn", "Select Country", choices = NULL),
               numericInput("startYear", "Start Year", value = 1960),
               numericInput("endYear",   "End Year",   value = 2023),
               actionButton("calculateAvg", "Get Avg Savings Rate 's'"),
               verbatimTextOutput("avgSavingsRate")  # displays the avg s calculated
      ),
      
      # v3.1: adding experiment to mainpanel # v3.2 fixing layout
      tabPanel("Experiments",
               fluidRow(
                 lapply(1:4, function(i) {
                   column(width = 3,
                          h4(paste0("Experiments Set ", i)),
                          selectInput(paste0("param_name", i), paste0("Quantitative exp (s, delta, n, z, l) Set ", i),
                                      choices = c("s", "delta", "n", "z", "l"),
                                      selected = "s"),
                          numericInput(paste0("new_value", i), paste0("New Value Set ", i), value = 0, step = 0.01),
                          numericInput(paste0("start_period", i), paste0("Start Period Set ", i), value = 5, step = 1),
                          numericInput(paste0("length", i), paste0("Length of Effect Set ", i), value = 5, step = 1),
                          actionButton(paste0("add_experiment", i), paste0("Add Exp ", i)),
                          fileInput(paste0("upload_file_", i), paste0("Upload Excel for Exp ", i), accept = c(".xlsx", ".xls")),
                          div(style = "width: 400px;", DTOutput(paste0("experimentsTable", i))))
                 })
               )
      ), # v3.2 fixing layout
      tabPanel("Plots",
               div(style = "width: 1800px; margin: auto;",
                   fluidRow(
                     column(6, plotOutput("plot_K", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_Y", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_little_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_percent_delta_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_MPK", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_MPL", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Log/Ratio scale",
               div(style = "width: 1800px; margin: auto;",
                   fluidRow(
                     column(6, plotOutput("plot_log_L", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_K", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_log_Y", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_A", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Table", tableOutput("resultsTable")),
      tabPanel("No Experiments", tableOutput("resultsNoExpTable")),
      tabPanel("Third Scenario", tableOutput("resultsThirdDfTable")),  # v3: 2nd experiment df
      tabPanel("Fourth Scenario", tableOutput("resultsFourthDfTable")), # v3 
      tabPanel("Fifth Scenario", tableOutput("resultsFifthDfTable"))  # v3
    )
  )
)

#--------------------------------------------------------
#     SERVER # version1
#--------------------------------------------------------
server <- function(input, output, session) {
  
  # adding option for Savings rate average for list of countries. 
  excel_list <- import_list("data/savings_rate_y.xlsx") # v2.2
  
  # Populate region choices
  observe({  # v2.2
    updateSelectInput(session, "selectedSheet", choices = names(excel_list), selected = names(excel_list)[1])
  })
  observeEvent(input$selectedSheet, {  # Update column choices  # v2.2
    df <- excel_list[[input$selectedSheet]]
    updateSelectInput(session, "selectedColumn", choices = setdiff(names(df), "year"), selected = setdiff(names(df), "year")[1])
  })
  
  # find the available years
  observeEvent(input$selectedColumn, { # v2.2
    df <- excel_list[[input$selectedSheet]]
    yearVals <- df$year
    yVals <- as.numeric(df[[input$selectedColumn]])
    valid <- !is.na(yearVals) & !is.na(yVals)
    if (!any(valid)) return()
    validYears <- yearVals[valid]
    minY <- min(validYears)
    maxY <- max(validYears)
    updateNumericInput(session, "startYear", min = minY, max = maxY, value = minY)
    updateNumericInput(session, "endYear",   min = minY, max = maxY, value = maxY)
  })
  
  # Calculate average within the chosen year range
  observeEvent(input$calculateAvg, {
    df <- excel_list[[input$selectedSheet]]
    yearVals <- df$year
    yVals <- as.numeric(df[[input$selectedColumn]])
    valid <- !is.na(yearVals) & !is.na(yVals)
    dfValid <- df[valid, ]
    
    subsetData <- dfValid[dfValid$year >= input$startYear & dfValid$year <= input$endYear, ]
    if (nrow(subsetData) == 0) {  # Check if country has any data
      output$avgSavingsRate <- renderPrint("Country Data Not Available") 
      return()
    }
    
    avgVal <- (mean(subsetData[[input$selectedColumn]]))/100
    updateSliderInput(session, "s", value = avgVal)
    output$avgSavingsRate <- renderPrint(paste("Average Savings Rate:", avgVal)) # Display the average
  }) # v2.2
  
  #----------------------------------
  # EXPERIMENTS TABLE MANAGEMENT # v3 
  #----------------------------------
  # This code along w/ the initializeExperiment function help loop in experiment simulations. 
  
  experiment_sets <- lapply(1:4, function(i) { # v3.2 looping exp tables
    initializeExperimentSet(expSuffix = as.character(i),
                            paramNameInput = paste0("param_name", i),
                            newValueInput = paste0("new_value", i),
                            startPeriodInput = paste0("start_period", i),
                            lengthInput = paste0("length", i),
                            addExpButton = paste0("add_experiment", i),
                            dtOutput = paste0("experimentsTable", i),
                            deleteRowInput = paste0("delete_", i),
                            input = input, output = output, session = session)
  })
  names(experiment_sets) <- paste0("experiments", 1:4)  # v3.2 looping exp tables
  
  
  # v3.1: adding excel upload for faster param inputs
  # v3.2: loop this to match expe loop code
  for (i in 1:4) {
    local({
      set_index <- i
      observeEvent(input[[paste0("upload_file_", set_index)]], {
        req(input[[paste0("upload_file_", set_index)]])
        df_uploaded <- import(input[[paste0("upload_file_", set_index)]]$datapath)
        
        # Optional: validate that the required columns exist
        required_cols <- c("param", "new_value", "start_period", "length")
        if (!all(required_cols %in% names(df_uploaded))) {
          showModal(modalDialog(
            title = "Error",
            "The uploaded file must contain columns: param, new_value, start_period, length.",
            easyClose = TRUE
          ))
          return(NULL)
        }
        
        # Append the uploaded rows to the existing experiment data
        current_data <- experiment_sets[[paste0("experiments", set_index)]]()
        updated_data <- rbind(current_data, df_uploaded)
        experiment_sets[[paste0("experiments", set_index)]](updated_data)
      }) # v3.1 and v3.2 end
    })
  }
  
  #----------------------------------
  # 2. SOLOW SIMULATION
  #----------------------------------
  
  simulate_solow <- function(num_periods, s, delta, n, z, l, A_init, L_init, experiments_df = NULL) {
    params <- data.frame(
      Period   = 0:(num_periods - 1),
      s        = rep(s, num_periods),
      delta    = rep(delta, num_periods),
      n        = rep(n, num_periods),
      z        = rep(z, num_periods),
      l        = rep(l, num_periods),
      delta_k  = rep(0.0, num_periods),
      percent_delta_k = rep(0.0, num_periods),
      little_k = rep(0.0, num_periods),
      A        = rep(A_init, num_periods),
      L        = rep(L_init, num_periods),
      K        = rep(0.0, num_periods),
      Y        = rep(0.0, num_periods)
    )
    
    # Calculate initial Capital per Capita Steady state k* 
    k_star_initial <- (s / (delta + n + z*l))^(1.5)*(1 - l)
    params$little_k[1] <- k_star_initial
    
    # this does the quantitative experiments. version 2.1
    if (!is.null(experiments_df) && nrow(experiments_df) > 0) { # v2.1
      for (exp in seq_len(nrow(experiments_df))) {
        start <- experiments_df$start_period[exp] + 1
        end   <- min(start + experiments_df$length[exp] - 1, num_periods)
        param_name <- experiments_df$param[exp]
        new_value  <- experiments_df$new_value[exp]
        params[start:end, param_name] <- new_value
      }
    }
    
    # Calculation portion. # v2.1
    # the "for (i in seq_len" makes sure all calculations are done in that order once every period. If you need to ask why don't edit this portion. 
    for (i in seq_len(num_periods)) { 
      if (i == 1) { # i=1 corresponds to Period=0 in the df
        params$delta_k[i] <- 0
      } else {
        # i-1 = t - 1
        params$delta_k[i] <- params$s[i] * ( (1 - params$l[i])^(2/3) ) * 
          (params$little_k[i-1]^(1/3)) - 
          (params$z[i] * params$l[i] + params$n[i] + params$delta[i]) * params$little_k[i-1]
        
        params$little_k[i] <- params$little_k[i-1] + params$delta_k[i]
      } # different calculation if period 0 or >0
      
      if (i > 1) {# cant be done till period 1. 
        params$A[i] <- params$A[i-1] * (1 + params$z[i]*params$l[i])
        params$L[i] <- params$L[i-1] * (1 + params$n[i])
      }
      
      # this calculations are done every period
      params$K[i] <- params$little_k[i] * params$A[i] * params$L[i]
      params$Y[i] <- (1 - params$l[i])^(2/3) * params$K[i]^(1/3) * (params$A[i] * params$L[i])^(2/3)
    }
    
    # this calculations are done once the for i loop is done for better app efficiency. 
    params$MPL <- (1 - params$l) * (1 - params$l)^(1 - (1/3)) * params$K^(1/3) * (params$A * params$L)^(1 - (1/3)) / params$L # v2.3 
    params$MPK <- (1/3) * (1 - params$l)^(1 - (1/3)) * params$K^(1/3) * (params$A * params$L)^(1 - (1/3)) / params$K # v2.3 
    params$log_L <- log(params$L)
    params$log_K <- log(params$K)
    params$log_Y <- log(params$Y)
    params$log_A <- log(params$A)
    params$percent_delta_k <- (params$delta_k / params$little_k) * 100 # v2.3
    
    params # v3. before v3, this was return(params)
    # when adding calc that need plots = add to tabpanel, and both codes.
  }
  
  #----------------------------------
  # EVENT-REACTIVE RESULTS
  #----------------------------------
  # v3.2 edit to loop with lapply exp tables
  
  results <- eventReactive(input$simulate, { # v2.1
    # If first set is empty, show a modal (original logic)
    if (nrow(experiment_sets$experiments1()) == 0) {
      showModal(modalDialog(
        title = "Error",
        "Please add at least one experiment in Set 1 before running the simulation.",
        easyClose = TRUE,
        footer = NULL
      ))
      return(NULL)
    }
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    
    # v3: streamline this section of the simulate_solow.
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiment_sets$experiments1()) # v3
  })
  
  results_no_exp <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = NULL) # v3
  })
  
  # v3: adding the 3 extra experiment simulations
  results_third_df <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    experiments_df_to_use <- if (nrow(experiment_sets$experiments2()) == 0) NULL else experiment_sets$experiments2()
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiments_df_to_use)
  })
  
  results_fourth_df <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    experiments_df_to_use <- if (nrow(experiment_sets$experiments3()) == 0) NULL else experiment_sets$experiments3()
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiments_df_to_use)
  })
  
  results_fifth_df <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    experiments_df_to_use <- if (nrow(experiment_sets$experiments4()) == 0) NULL else experiment_sets$experiments4()
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiments_df_to_use)
  }) 
  
  # v3.2 updated to be loop with exp tables
  
  
  #----------------------------------
  # 4. OUTPUT: TABLES
  #----------------------------------
  
  # v3 not much change from before v3c for results, and results_no_exp, but
  # added the 3 results tables for the other experiments
  output$resultsTable <- renderTable({req(results()); 
    results()}, rownames = FALSE) # v3
  output$resultsNoExpTable <- renderTable({ req(results_no_exp()) ; 
    results_no_exp() }, rownames = FALSE) # v3
  output$resultsThirdDfTable <- renderTable({ req(results_third_df()); 
    results_third_df() }, rownames = FALSE) # v3
  output$resultsFourthDfTable<- renderTable({ req(results_fourth_df()); 
    results_fourth_df() }, rownames = FALSE) # v3
  output$resultsFifthDfTable <- renderTable({ req(results_fifth_df()); 
    results_fifth_df() }, rownames = FALSE) # v3
  
  #----------------------------------
  # PLOTS
  #----------------------------------
  
  # aesthetics for each plot
  plot_theme <- theme_bw() + 
    theme(plot.title   = element_text(hjust = 0.5),
          axis.title   = element_text(size = 12),
          axis.text    = element_text(size = 10),
          panel.grid.major = element_line(color = "grey80"),
          panel.grid.minor = element_blank(),
          strip.background = element_rect(fill = "grey90", color = "grey90"))
  
  # function to generate each plot. # v2
  make_plot <- function(data_exp, data_no_exp, y_var, title, y_label, show_no_exp) {
    p <- ggplot(data_exp, aes(x = Period, y = .data[[y_var]])) + # Base plot with experiment data
      geom_line(aes(color = "With Experiments")) +
      geom_point(aes(color = "With Experiments")) +
      scale_color_manual(values = c("With Experiments" = "blue", 
                                    "Without Experiments" = "red")) +
      ggtitle(title) +
      xlab("Period") +
      ylab(y_label) +
      plot_theme
    
    if (show_no_exp) {  # Conditionally add no experiment data. # v2.1
      p <- p +
        geom_line(data = data_no_exp, aes(x = Period, y = .data[[y_var]], color = "Without Experiments"), linetype = "dashed") +
        geom_point(data = data_no_exp, aes(x = Period, y = .data[[y_var]], color = "Without Experiments"), shape = 1, size = 3)
    }
    p # v3: before v3 it was this: return(p)
  }
  
  
  plot_objects <- reactiveValues() # store plots for download. # v2.1
  
  output$plot_K <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "K", 
                   "Capital (K) Over Time", "Capital (K)", input$show_no_exp)
    plot_objects$plot_K <- p # Store the plot object
    p # Return the plot for display
  }, res = 100) # v2.1
  
  output$plot_Y <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "Y", 
                   "Output (Y) Over Time", "Output (Y)", input$show_no_exp)
    plot_objects$plot_Y <- p
    p
  }, res = 100) # v2.1
  
  output$plot_delta_k <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "delta_k", 
                   "Change in Capital (Δk) Over Time", "Δk", input$show_no_exp)
    plot_objects$plot_delta_k <- p
    p
  }, res = 100)  # v2.1
  
  output$plot_little_k <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "little_k", 
                   "Capital Efficiency Units", "k (Capital Efficiency Units)", input$show_no_exp)
    plot_objects$plot_little_k <- p
    p
  }, res = 100)  # v2.1
  
  output$plot_log_L <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "log_L", 
                   "Log of Labor (L) Over Time", "Log(L)", input$show_no_exp)
    plot_objects$plot_log_L <- p
    p
  }, res = 100) # v2.1
  
  output$plot_log_K <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "log_K", 
                   "Log of Capital (K) Over Time", "Log(K)", input$show_no_exp)
    plot_objects$plot_log_K <- p
    p
  }, res = 100) # v2.1
  
  output$plot_log_Y <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "log_Y", 
                   "Log of Output (Y) Over Time", "Log(Y)", input$show_no_exp)
    plot_objects$plot_log_Y <- p
    p
  }, res = 100) # v2.1
  
  output$plot_log_A <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "log_A", 
                   "Log of TFP (A) Over Time", "Log(A)", input$show_no_exp)
    plot_objects$plot_log_A <- p
    p
  }, res = 100) # v2.1
  
  output$plot_percent_delta_k <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "percent_delta_k", 
                   "Percent Change in Capital Over Time", "Δk/k", input$show_no_exp)
    plot_objects$plot_percent_delta_k <- p
    p
  }, res = 100) # v2.3
  
  output$plot_MPL <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "MPL", 
                   "Marginal Product of Labor Over Time", "MPL", input$show_no_exp)
    plot_objects$plot_MPL <- p
    p
  }, res = 100) # v2.3.1
  
  output$plot_MPK <- renderPlot({req(results(), results_no_exp())
    p <- make_plot(results(), results_no_exp(), "MPK", 
                   "Marginal Product of Capital Over Time", "MPK", input$show_no_exp)
    plot_objects$plot_MPK <- p
    p
  }, res = 100) # v2.3.1
  
  
  
  #----------------------------------
  # DOWNLOAD HANDLERS
  #----------------------------------
  output$downloadData <- downloadHandler( # version1
    filename = function() {
      paste0("results_", Sys.Date(), ".csv")
    },
    content = function(file) {req(results()) # v2.1
      write.csv(results(), file, row.names = FALSE)
    }
  )
  
  output$downloadPlots <- downloadHandler( # version1
    filename = function() { 
      paste0("plots_", Sys.Date(), ".zip")
    },
    content = function(file) {
      temp_dir <- tempdir() # temp file storage but new shiny update change the way file downloads happen so this might not be needed now
      file_paths <- c()
      
      # Use the stored plot objects version2
      plots <- reactiveValuesToList(plot_objects) # Convert reactiveValues to list
      plots <- Filter(Negate(is.null), plots) # Remove NULL entries
      
      for (plot_name in names(plots)) { # Save each plot to a PNG version1
        plot_file <- file.path(temp_dir, paste0(plot_name, ".png"))
        ggsave(plot_file, plots[[plot_name]], device = "png")
        file_paths <- c(file_paths, plot_file)
      }
      zipr(zipfile = file, files = file_paths) # zip em. v1
    }
  )
}

shinyApp(ui = ui, server = server)

# v3.2


# loop the experiments table
# this is in preparation to add experiments as need and not have them always display

# v3.2

```

# spacer

```{r}


# v3.3
library(shiny)
library(ggplot2)
library(DT)    # for interactive table
library(zip)   # to create ZIP files in download handler
library(bslib)
library(rio)   # to read the Excel file # v2.2

#--- Helper function to create each experiment set. ---
initializeExperimentSet <- function(
    expSuffix,         # label like "1", "2", "3", or "4"
    paramNameInput,    # e.g. "param_name", "param_name2"
    newValueInput,     # e.g. "value", "value2"
    startPeriodInput,  # e.g. "start_period", "start_period2"
    lengthInput,       # e.g. "length", "length2"
    addExpButton,      # e.g. "add_experiment", "add_experiment2"
    dtOutput,          # e.g. "experimentsTable", "experimentsTable2"
    deleteRowInput,    # internal ID prefix for deletion, e.g. "delete_1", "delete_2"
    input, output, session
) {
  
  # A reactiveVal to hold the table of experiments for this set
  rv <- reactiveVal(
    data.frame(
      param        = character(0),
      value    = numeric(0),
      start_period = integer(0),
      length       = integer(0),
      stringsAsFactors = FALSE
    )
  )
  
  # Add new experiment row when the user clicks
  observeEvent(input[[addExpButton]], {
    new_experiment <- data.frame(
      param        = input[[paramNameInput]],
      value    = input[[newValueInput]],
      start_period = input[[startPeriodInput]],
      length       = input[[lengthInput]],
      stringsAsFactors = FALSE
    )
    rv( rbind(rv(), new_experiment) )
  })
  
  # Render the experiments table with "Delete" buttons
  output[[dtOutput]] <- renderDT({
    exps <- rv()
    if (nrow(exps) == 0) return(NULL)
    
    deleteButtons <- sapply(seq_len(nrow(exps)), function(i) {
      as.character(
        actionButton(
          inputId = paste0("delete_", expSuffix, "_", i),
          label = "Delete",
          class = "btn btn-danger btn-sm",
          onclick = paste0(
            'Shiny.setInputValue("delete_', expSuffix, '", this.id, {priority: "event"})'
          )
        )
      )
    })
    
    exps$Delete <- deleteButtons
    
    datatable(
      exps,
      escape = FALSE,
      selection = "none",
      options   = list(pageLength = 5)
    )
  }, server = FALSE)
  
  # Handle row deletions
  observeEvent(input[[paste0("delete_", expSuffix)]], {
    row_str <- gsub(paste0("delete_", expSuffix, "_"), "", input[[paste0("delete_", expSuffix)]])
    row_num <- as.numeric(row_str)
    
    exps <- rv()
    if (!is.na(row_num) && row_num >= 1 && row_num <= nrow(exps)) {
      exps <- exps[-row_num, ]
      rv(exps)
    }
  })
  
  return(rv)
}

#--------------------------------------------------------
#     UI
#--------------------------------------------------------
# app layout and input controls version1
ui <- page_sidebar( # version
  title = "Solow-Romer Macro Simulation",
  sidebar = sidebar( # all the input controls
    width = 600, # edit sidebar width. This is not friendly with smaller screens. I was having trouble with the sidebar overlapping with tabs so I added this to default a sidebar lenght.
    h4("Simulation Parameters"),
    sliderInput("Simulation_Period", "Simulation Period (yrs)", 
                min = 20, max = 150, value = 50, step = 1),
    sliderInput("s", "Savings Rate (s)", min = 0.001, max = 1, value = 0.2, step = 0.01), # v2.3 change to min .001 due to div by zero error
    sliderInput("delta", "Depreciation Rate (delta)", min = 0, max = .5, value = 0.15, step = 0.01),
    sliderInput("n", "n", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("z", "Parameter z", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("l", "Parameter l", min = 0, max = 0.99, value = 0.1, step = 0.01), 
    selectInput("A", "Initial value for A", choices = c(1, 100, 1000), selected = 1), # 343
    selectInput("L", "Initial value for L", choices = c(1, 100, 1000), selected = 1), # 343
    
    h4("Experiments"),
    checkboxInput("show_no_exp",    "Show Counterfactual",       value = TRUE),
    checkboxInput("show_third_exp", "Show Third Experiment",     value = FALSE), # v3.3
    checkboxInput("show_fourth_exp","Show Fourth Experiment",    value = FALSE), # v3.3
    checkboxInput("show_fifth_exp", "Show Fifth Experiment",     value = FALSE), # v3.3
    
    actionButton("simulate", "Simulate"),
    h4("Download Results"),
    downloadButton("downloadPlots", "Download All Plots as PNG (ZIP)"),
    downloadButton("downloadData", "Download Data as CSV")
  ),
  mainPanel( # tab controls. v1
    tabsetPanel(
      tabPanel("World", # v 2.2
               # adding option to get average savings rate
               selectInput("selectedSheet", "Select Region", choices = NULL),
               selectInput("selectedColumn", "Select Country", choices = NULL),
               numericInput("startYear", "Start Year", value = 1960),
               numericInput("endYear",   "End Year",   value = 2023),
               actionButton("calculateAvg", "Get Avg Savings Rate 's'"),
               verbatimTextOutput("avgSavingsRate")  # displays the avg s calculated
      ),
      
      # v3.1: adding experiment to mainpanel # v3.2 fixing layout
      tabPanel("Experiments",
               fluidRow(
                 lapply(1:4, function(i) {
                   column(width = 3,
                          h4(paste0("Experiments Set ", i)),
                          selectInput(paste0("param_name", i), paste0("Quantitative exp (s, delta, n, z, l) Set ", i),
                                      choices = c("s", "delta", "n", "z", "l"),
                                      selected = "s"),
                          numericInput(paste0("value", i), paste0("New Value Set ", i), value = 0, step = 0.01),
                          numericInput(paste0("start_period", i), paste0("Start Period Set ", i), value = 5, step = 1),
                          numericInput(paste0("length", i), paste0("Length of Effect Set ", i), value = 5, step = 1),
                          actionButton(paste0("add_experiment", i), paste0("Add Exp ", i)),
                          fileInput(paste0("upload_file_", i), paste0("Upload Excel for Exp ", i), accept = c(".xlsx", ".xls")),
                          div(style = "width: 400px;", DTOutput(paste0("experimentsTable", i))))
                 })
               )
      ), # v3.2 fixing layout
      tabPanel("Plots",
               div(style = "width: 1800px; margin: auto;",
                   fluidRow(
                     column(6, plotOutput("plot_K", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_Y", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_little_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_percent_delta_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_MPK", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_MPL", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Log/Ratio scale",
               div(style = "width: 1800px; margin: auto;",
                   fluidRow(
                     column(6, plotOutput("plot_log_L", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_K", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_log_Y", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_A", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Table", tableOutput("resultsTable")),
      tabPanel("No Experiments", tableOutput("resultsNoExpTable")),
      tabPanel("Third Scenario", tableOutput("resultsThirdDfTable")),  # v3: 2nd experiment df
      tabPanel("Fourth Scenario", tableOutput("resultsFourthDfTable")), # v3 
      tabPanel("Fifth Scenario", tableOutput("resultsFifthDfTable"))  # v3
    )
  )
)

#--------------------------------------------------------
#     SERVER # version1
#--------------------------------------------------------
server <- function(input, output, session) {
  
  # adding option for Savings rate average for list of countries. 
  excel_list <- import_list("data/savings_rate_y.xlsx") # v2.2
  
  # Populate region choices
  observe({  # v2.2
    updateSelectInput(session, "selectedSheet", choices = names(excel_list), selected = names(excel_list)[1])
  })
  observeEvent(input$selectedSheet, {  # Update column choices  # v2.2
    df <- excel_list[[input$selectedSheet]]
    updateSelectInput(session, "selectedColumn", choices = setdiff(names(df), "year"), selected = setdiff(names(df), "year")[1])
  })
  
  # find the available years
  observeEvent(input$selectedColumn, { # v2.2
    df <- excel_list[[input$selectedSheet]]
    yearVals <- df$year
    yVals <- as.numeric(df[[input$selectedColumn]])
    valid <- !is.na(yearVals) & !is.na(yVals)
    if (!any(valid)) return()
    validYears <- yearVals[valid]
    minY <- min(validYears)
    maxY <- max(validYears)
    updateNumericInput(session, "startYear", min = minY, max = maxY, value = minY)
    updateNumericInput(session, "endYear",   min = minY, max = maxY, value = maxY)
  })
  
  # Calculate average within the chosen year range
  observeEvent(input$calculateAvg, {
    df <- excel_list[[input$selectedSheet]]
    yearVals <- df$year
    yVals <- as.numeric(df[[input$selectedColumn]])
    valid <- !is.na(yearVals) & !is.na(yVals)
    dfValid <- df[valid, ]
    
    subsetData <- dfValid[dfValid$year >= input$startYear & dfValid$year <= input$endYear, ]
    if (nrow(subsetData) == 0) {  # Check if country has any data
      output$avgSavingsRate <- renderPrint("Country Data Not Available") 
      return()
    }
    
    avgVal <- (mean(subsetData[[input$selectedColumn]]))/100
    updateSliderInput(session, "s", value = avgVal)
    output$avgSavingsRate <- renderPrint(paste("Average Savings Rate:", avgVal)) # Display the average
  }) # v2.2
  
  #----------------------------------
  # EXPERIMENTS TABLE MANAGEMENT # v3 
  #----------------------------------
  # This code along w/ the initializeExperiment function help loop in experiment simulations. 
  experiment_sets <- lapply(1:4, function(i) { # v3.2 looping exp tables
    initializeExperimentSet(
      expSuffix        = as.character(i),
      paramNameInput   = paste0("param_name", i),
      newValueInput    = paste0("value", i),
      startPeriodInput = paste0("start_period", i),
      lengthInput      = paste0("length", i),
      addExpButton     = paste0("add_experiment", i),
      dtOutput         = paste0("experimentsTable", i),
      deleteRowInput   = paste0("delete_", i),
      input = input, output = output, session = session
    )
  })
  names(experiment_sets) <- paste0("experiments", 1:4)  # v3.2 looping exp tables
  
  
  # v3.1: adding excel upload for faster param inputs
  # v3.2: loop this to match expe loop code
  for (i in 1:4) {
    local({
      set_index <- i
      observeEvent(input[[paste0("upload_file_", set_index)]], {
        req(input[[paste0("upload_file_", set_index)]])
        df_uploaded <- import(input[[paste0("upload_file_", set_index)]]$datapath)
        
        # Validate columns
        required_cols <- c("param", "value", "start_period", "length")
        if (!all(required_cols %in% names(df_uploaded))) {
          showModal(modalDialog(
            title = "Error",
            "The uploaded file must contain columns: param, value, start_period, length.",
            easyClose = TRUE
          ))
          return(NULL)
        }
        
        # Append
        current_data <- experiment_sets[[paste0("experiments", set_index)]]()
        updated_data <- rbind(current_data, df_uploaded)
        experiment_sets[[paste0("experiments", set_index)]](updated_data)
      }) # v3.1 and v3.2 end
    })
  }
  
  #----------------------------------
  # 2. SOLOW SIMULATION
  #----------------------------------
  
  simulate_solow <- function(num_periods, s, delta, n, z, l, A_init, L_init, experiments_df = NULL) {
    params <- data.frame(
      Period   = 0:(num_periods - 1),
      s        = rep(s, num_periods),
      delta    = rep(delta, num_periods),
      n        = rep(n, num_periods),
      z        = rep(z, num_periods),
      l        = rep(l, num_periods),
      delta_k  = rep(0.0, num_periods),
      percent_delta_k = rep(0.0, num_periods),
      little_k = rep(0.0, num_periods),
      A        = rep(A_init, num_periods),
      L        = rep(L_init, num_periods),
      K        = rep(0.0, num_periods),
      Y        = rep(0.0, num_periods)
    )
    
    # Calculate initial Capital per Capita Steady state k* 
    k_star_initial <- (s / (delta + n + z*l))^(1.5)*(1 - l)
    params$little_k[1] <- k_star_initial
    
    # this does the quantitative experiments. version 2.1
    if (!is.null(experiments_df) && nrow(experiments_df) > 0) { # v2.1
      for (exp in seq_len(nrow(experiments_df))) {
        start <- experiments_df$start_period[exp] + 1
        end   <- min(start + experiments_df$length[exp] - 1, num_periods)
        param_name <- experiments_df$param[exp]
        value  <- experiments_df$value[exp]
        params[start:end, param_name] <- value
      }
    }
    
    # Calculation portion. # v2.1
    # the "for (i in seq_len" makes sure all calculations are done in that order once every period. If you need to ask why don't edit this portion. 
    for (i in seq_len(num_periods)) { 
      if (i == 1) { # i=1 corresponds to Period=0 in the df
        params$delta_k[i] <- 0
      } else {
        # i-1 = t - 1
        params$delta_k[i] <- params$s[i] * ( (1 - params$l[i])^(2/3) ) * 
          (params$little_k[i-1]^(1/3)) - 
          (params$z[i] * params$l[i] + params$n[i] + params$delta[i]) * params$little_k[i-1]
        
        params$little_k[i] <- params$little_k[i-1] + params$delta_k[i]
      } # different calculation if period 0 or >0
      
      if (i > 1) {# cant be done till period 1. 
        params$A[i] <- params$A[i-1] * (1 + params$z[i]*params$l[i])
        params$L[i] <- params$L[i-1] * (1 + params$n[i])
      }
      
      # this calculations are done every period
      params$K[i] <- params$little_k[i] * params$A[i] * params$L[i]
      params$Y[i] <- (1 - params$l[i])^(2/3) * params$K[i]^(1/3) * (params$A[i] * params$L[i])^(2/3)
    }
    
    # this calculations are done once the for i loop is done for better app efficiency. 
    params$MPL <- (1 - params$l) * (1 - params$l)^(1 - (1/3)) * params$K^(1/3) * (params$A * params$L)^(1 - (1/3)) / params$L # v2.3 
    params$MPK <- (1/3) * (1 - params$l)^(1 - (1/3)) * params$K^(1/3) * (params$A * params$L)^(1 - (1/3)) / params$K # v2.3 
    params$log_L <- log(params$L)
    params$log_K <- log(params$K)
    params$log_Y <- log(params$Y)
    params$log_A <- log(params$A)
    params$percent_delta_k <- (params$delta_k / params$little_k) * 100 # v2.3
    
    params # v3. before v3, this was return(params)
    # when adding calc that need plots = add to tabpanel, and both codes.
  }
  
  #----------------------------------
  # EVENT-REACTIVE RESULTS
  #----------------------------------
  # v3.2 edit to loop with lapply exp tables
  
  results <- eventReactive(input$simulate, { # v2.1
    # If first set is empty, show a modal (original logic)
    if (nrow(experiment_sets$experiments1()) == 0) {
      showModal(modalDialog(
        title = "Error",
        "Please add at least one experiment in Set 1 before running the simulation.",
        easyClose = TRUE,
        footer = NULL
      ))
      return(NULL)
    }
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    
    # v3: streamline this section of the simulate_solow.
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiment_sets$experiments1()) # v3
  })
  
  results_no_exp <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = NULL) # v3
  })
  
  # v3: adding the 3 extra experiment simulations
  results_third_df <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    experiments_df_to_use <- if (nrow(experiment_sets$experiments2()) == 0) NULL else experiment_sets$experiments2()
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiments_df_to_use)
  })
  
  results_fourth_df <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    experiments_df_to_use <- if (nrow(experiment_sets$experiments3()) == 0) NULL else experiment_sets$experiments3()
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiments_df_to_use)
  })
  
  results_fifth_df <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    experiments_df_to_use <- if (nrow(experiment_sets$experiments4()) == 0) NULL else experiment_sets$experiments4()
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiments_df_to_use)
  }) 
  
  # v3.2 updated to be loop with exp tables
  
  
  #----------------------------------
  # 4. OUTPUT: TABLES
  #----------------------------------
  
  # v3 not much change from before v3c for results, and results_no_exp, but
  # added the 3 results tables for the other experiments
  output$resultsTable <- renderTable({req(results()); 
    results()}, rownames = FALSE) # v3
  output$resultsNoExpTable <- renderTable({ req(results_no_exp()) ; 
    results_no_exp() }, rownames = FALSE) # v3
  output$resultsThirdDfTable <- renderTable({ req(results_third_df()); 
    results_third_df() }, rownames = FALSE) # v3
  output$resultsFourthDfTable<- renderTable({ req(results_fourth_df()); 
    results_fourth_df() }, rownames = FALSE) # v3
  output$resultsFifthDfTable <- renderTable({ req(results_fifth_df()); 
    results_fifth_df() }, rownames = FALSE) # v3
  
  #---------------------------
  # 5. PLOTS # v3.3
  #---------------------------
  plot_theme <- theme_bw() + 
    theme(
      plot.title        = element_text(hjust = 0.5),
      axis.title        = element_text(size = 12),
      axis.text         = element_text(size = 10),
      panel.grid.major  = element_line(color = "grey80"),
      panel.grid.minor  = element_blank(),
      strip.background  = element_rect(fill = "grey90", color = "grey90")
    )
  
  # Extended make_plot to include optional 3rd,4th,5th data
  make_plot <- function(
    data_exp,      # "With Experiments" (the main one from Set 1)
    data_no_exp,   # "Without Experiments" (counterfactual)
    data_third = NULL,
    data_fourth = NULL,
    data_fifth = NULL,
    y_var, title, y_label,
    show_no_exp = TRUE,
    show_third_exp = FALSE,
    show_fourth_exp = FALSE,
    show_fifth_exp = FALSE
  ) {
    
    # Base plot with the main experiment data
    p <- ggplot(data_exp, aes(x = Period, y = .data[[y_var]])) +
      geom_line(aes(color = "With Experiments")) +
      geom_point(aes(color = "With Experiments")) +
      scale_color_manual(values = c("With Experiments" = "blue",
                                    "Without Experiments" = "red",
                                    "Third Scenario"  = "green",
                                    "Fourth Scenario" = "purple",
                                    "Fifth Scenario"  = "orange")) +
      ggtitle(title) + xlab("Period") + ylab(y_label) +
      plot_theme
    
    # Optionally add no-exp line
    if (show_no_exp && !is.null(data_no_exp)) {
      p <- p +
        geom_line(data = data_no_exp, 
                  aes(x = Period, y = .data[[y_var]], color = "Without Experiments"), 
                  linetype = "dashed") +
        geom_point(data = data_no_exp, 
                   aes(x = Period, y = .data[[y_var]], color = "Without Experiments"), 
                   shape = 1, size = 3)
    }
    
    # Optionally add third scenario
    if (show_third_exp && !is.null(data_third)) {
      p <- p +
        geom_line(data = data_third,
                  aes(x = Period, y = .data[[y_var]], color = "Third Scenario")) +
        geom_point(data = data_third,
                   aes(x = Period, y = .data[[y_var]], color = "Third Scenario"), size = 2)
    }
    
    # Optionally add fourth scenario
    if (show_fourth_exp && !is.null(data_fourth)) {
      p <- p +
        geom_line(data = data_fourth,
                  aes(x = Period, y = .data[[y_var]], color = "Fourth Scenario")) +
        geom_point(data = data_fourth,
                   aes(x = Period, y = .data[[y_var]], color = "Fourth Scenario"), size = 2)
    }
    
    # Optionally add fifth scenario
    if (show_fifth_exp && !is.null(data_fifth)) {
      p <- p +
        geom_line(data = data_fifth,
                  aes(x = Period, y = .data[[y_var]], color = "Fifth Scenario")) +
        geom_point(data = data_fifth,
                   aes(x = Period, y = .data[[y_var]], color = "Fifth Scenario"), size = 2)
    }
    
    p
  }
  
  # Store plots for download
  plot_objects <- reactiveValues()
  
  output$plot_K <- renderPlot({
    req(results(), results_no_exp(), results_third_df(), results_fourth_df(), results_fifth_df())
    p <- make_plot(
      data_exp      = results(),
      data_no_exp   = results_no_exp(),
      data_third    = results_third_df(),
      data_fourth   = results_fourth_df(),
      data_fifth    = results_fifth_df(),
      y_var         = "K",
      title         = "Capital (K) Over Time",
      y_label       = "Capital (K)",
      show_no_exp   = input$show_no_exp,
      show_third_exp = input$show_third_exp,
      show_fourth_exp = input$show_fourth_exp,
      show_fifth_exp  = input$show_fifth_exp
    )
    plot_objects$plot_K <- p
    p
  }, res = 100)
  
  output$plot_Y <- renderPlot({
    req(results(), results_no_exp(), results_third_df(), results_fourth_df(), results_fifth_df())
    p <- make_plot(
      data_exp      = results(),
      data_no_exp   = results_no_exp(),
      data_third    = results_third_df(),
      data_fourth   = results_fourth_df(),
      data_fifth    = results_fifth_df(),
      y_var         = "Y",
      title         = "Output (Y) Over Time",
      y_label       = "Output (Y)",
      show_no_exp   = input$show_no_exp,
      show_third_exp = input$show_third_exp,
      show_fourth_exp = input$show_fourth_exp,
      show_fifth_exp  = input$show_fifth_exp
    )
    plot_objects$plot_Y <- p
    p
  }, res = 100)
  
  output$plot_little_k <- renderPlot({
    req(results(), results_no_exp(), results_third_df(), results_fourth_df(), results_fifth_df())
    p <- make_plot(
      data_exp      = results(),
      data_no_exp   = results_no_exp(),
      data_third    = results_third_df(),
      data_fourth   = results_fourth_df(),
      data_fifth    = results_fifth_df(),
      y_var         = "little_k",
      title         = "Capital Efficiency Units",
      y_label       = "k (Capital Efficiency Units)",
      show_no_exp   = input$show_no_exp,
      show_third_exp = input$show_third_exp,
      show_fourth_exp = input$show_fourth_exp,
      show_fifth_exp  = input$show_fifth_exp
    )
    plot_objects$plot_little_k <- p
    p
  }, res = 100)
  
  output$plot_percent_delta_k <- renderPlot({
    req(results(), results_no_exp(), results_third_df(), results_fourth_df(), results_fifth_df())
    p <- make_plot(
      data_exp      = results(),
      data_no_exp   = results_no_exp(),
      data_third    = results_third_df(),
      data_fourth   = results_fourth_df(),
      data_fifth    = results_fifth_df(),
      y_var         = "percent_delta_k",
      title         = "Percent Change in Capital Over Time",
      y_label       = "Δk/k",
      show_no_exp   = input$show_no_exp,
      show_third_exp = input$show_third_exp,
      show_fourth_exp = input$show_fourth_exp,
      show_fifth_exp  = input$show_fifth_exp
    )
    plot_objects$plot_percent_delta_k <- p
    p
  }, res = 100)
  
  output$plot_MPK <- renderPlot({
    req(results(), results_no_exp(), results_third_df(), results_fourth_df(), results_fifth_df())
    p <- make_plot(
      data_exp      = results(),
      data_no_exp   = results_no_exp(),
      data_third    = results_third_df(),
      data_fourth   = results_fourth_df(),
      data_fifth    = results_fifth_df(),
      y_var         = "MPK",
      title         = "Marginal Product of Capital Over Time",
      y_label       = "MPK",
      show_no_exp   = input$show_no_exp,
      show_third_exp = input$show_third_exp,
      show_fourth_exp = input$show_fourth_exp,
      show_fifth_exp  = input$show_fifth_exp
    )
    plot_objects$plot_MPK <- p
    p
  }, res = 100)
  
  output$plot_MPL <- renderPlot({
    req(results(), results_no_exp(), results_third_df(), results_fourth_df(), results_fifth_df())
    p <- make_plot(
      data_exp      = results(),
      data_no_exp   = results_no_exp(),
      data_third    = results_third_df(),
      data_fourth   = results_fourth_df(),
      data_fifth    = results_fifth_df(),
      y_var         = "MPL",
      title         = "Marginal Product of Labor Over Time",
      y_label       = "MPL",
      show_no_exp   = input$show_no_exp,
      show_third_exp = input$show_third_exp,
      show_fourth_exp = input$show_fourth_exp,
      show_fifth_exp  = input$show_fifth_exp
    )
    plot_objects$plot_MPL <- p
    p
  }, res = 100)
  
  output$plot_log_L <- renderPlot({
    req(results(), results_no_exp(), results_third_df(), results_fourth_df(), results_fifth_df())
    p <- make_plot(
      data_exp      = results(),
      data_no_exp   = results_no_exp(),
      data_third    = results_third_df(),
      data_fourth   = results_fourth_df(),
      data_fifth    = results_fifth_df(),
      y_var         = "log_L",
      title         = "Log of Labor (L) Over Time",
      y_label       = "Log(L)",
      show_no_exp   = input$show_no_exp,
      show_third_exp = input$show_third_exp,
      show_fourth_exp = input$show_fourth_exp,
      show_fifth_exp  = input$show_fifth_exp
    )
    plot_objects$plot_log_L <- p
    p
  }, res = 100)
  
  output$plot_log_K <- renderPlot({
    req(results(), results_no_exp(), results_third_df(), results_fourth_df(), results_fifth_df())
    p <- make_plot(
      data_exp      = results(),
      data_no_exp   = results_no_exp(),
      data_third    = results_third_df(),
      data_fourth   = results_fourth_df(),
      data_fifth    = results_fifth_df(),
      y_var         = "log_K",
      title         = "Log of Capital (K) Over Time",
      y_label       = "Log(K)",
      show_no_exp   = input$show_no_exp,
      show_third_exp = input$show_third_exp,
      show_fourth_exp = input$show_fourth_exp,
      show_fifth_exp  = input$show_fifth_exp
    )
    plot_objects$plot_log_K <- p
    p
  }, res = 100)
  
  output$plot_log_Y <- renderPlot({
    req(results(), results_no_exp(), results_third_df(), results_fourth_df(), results_fifth_df())
    p <- make_plot(
      data_exp      = results(),
      data_no_exp   = results_no_exp(),
      data_third    = results_third_df(),
      data_fourth   = results_fourth_df(),
      data_fifth    = results_fifth_df(),
      y_var         = "log_Y",
      title         = "Log of Output (Y) Over Time",
      y_label       = "Log(Y)",
      show_no_exp   = input$show_no_exp,
      show_third_exp = input$show_third_exp,
      show_fourth_exp = input$show_fourth_exp,
      show_fifth_exp  = input$show_fifth_exp
    )
    plot_objects$plot_log_Y <- p
    p
  }, res = 100)
  
  output$plot_log_A <- renderPlot({
    req(results(), results_no_exp(), results_third_df(), results_fourth_df(), results_fifth_df())
    p <- make_plot(
      data_exp      = results(),
      data_no_exp   = results_no_exp(),
      data_third    = results_third_df(),
      data_fourth   = results_fourth_df(),
      data_fifth    = results_fifth_df(),
      y_var         = "log_A",
      title         = "Log of TFP (A) Over Time",
      y_label       = "Log(A)",
      show_no_exp   = input$show_no_exp,
      show_third_exp = input$show_third_exp,
      show_fourth_exp = input$show_fourth_exp,
      show_fifth_exp  = input$show_fifth_exp
    )
    plot_objects$plot_log_A <- p
    p
  }, res = 100) # v3.3: this whole plot code is new with v3.3
  
  
  #----------------------------------
  # DOWNLOAD HANDLERS
  #----------------------------------
  output$downloadData <- downloadHandler( # version1
    filename = function() {
      paste0("results_", Sys.Date(), ".csv")
    },
    content = function(file) {req(results()) # v2.1
      write.csv(results(), file, row.names = FALSE)
    }
  )
  
  output$downloadPlots <- downloadHandler( # version1
    filename = function() { 
      paste0("plots_", Sys.Date(), ".zip")
    },
    content = function(file) {
      temp_dir <- tempdir() # temp file storage but new shiny update change the way file downloads happen so this might not be needed now
      file_paths <- c()
      
      # Use the stored plot objects version2
      plots <- reactiveValuesToList(plot_objects) # Convert reactiveValues to list
      plots <- Filter(Negate(is.null), plots) # Remove NULL entries
      
      for (plot_name in names(plots)) { # Save each plot to a PNG version1
        plot_file <- file.path(temp_dir, paste0(plot_name, ".png"))
        ggsave(plot_file, plots[[plot_name]], device = "png")
        file_paths <- c(file_paths, plot_file)
      }
      zipr(zipfile = file, files = file_paths) # zip em. v1
    }
  )
}

shinyApp(ui = ui, server = server)

# v3.3

# added option to show other experiments with plots
# change new_value to value in experiment table codes to shorten code length

```


# spacer

```{r}
# v3.3.1
library(shiny)
library(ggplot2)
library(DT)    # for interactive table
library(zip)   # to create ZIP files in download handler
library(bslib)
library(rio)   # to read the Excel file # v2.2

#--- Helper function to create each experiment set. ---
initializeExperimentSet <- function(
    expSuffix,         # label like "1", "2", "3", or "4"
    paramNameInput,    # e.g. "param_name", "param_name2"
    newValueInput,     # e.g. "value", "value2"
    startPeriodInput,  # e.g. "start_period", "start_period2"
    lengthInput,       # e.g. "length", "length2"
    addExpButton,      # e.g. "add_experiment", "add_experiment2"
    dtOutput,          # e.g. "experimentsTable", "experimentsTable2"
    deleteRowInput,    # internal ID prefix for deletion, e.g. "delete_1", "delete_2"
    input, output, session
) {
  
  # A reactiveVal to hold the table of experiments for this set
  rv <- reactiveVal(
    data.frame(
      param        = character(0),
      value    = numeric(0),
      start_period = integer(0),
      length       = integer(0),
      stringsAsFactors = FALSE
    )
  )
  
  # Add new experiment row when the user clicks
  observeEvent(input[[addExpButton]], {
    new_experiment <- data.frame(
      param        = input[[paramNameInput]],
      value    = input[[newValueInput]],
      start_period = input[[startPeriodInput]],
      length       = input[[lengthInput]],
      stringsAsFactors = FALSE
    )
    rv( rbind(rv(), new_experiment) )
  })
  
  # Render the experiments table with "Delete" buttons
  output[[dtOutput]] <- renderDT({
    exps <- rv()
    if (nrow(exps) == 0) return(NULL)
    
    deleteButtons <- sapply(seq_len(nrow(exps)), function(i) {
      as.character(
        actionButton(
          inputId = paste0("delete_", expSuffix, "_", i),
          label = "Delete",
          class = "btn btn-danger btn-sm",
          onclick = paste0(
            'Shiny.setInputValue("delete_', expSuffix, '", this.id, {priority: "event"})'
          )
        )
      )
    })
    
    exps$Delete <- deleteButtons
    
    datatable(
      exps,
      escape = FALSE,
      selection = "none",
      options   = list(pageLength = 5)
    )
  }, server = FALSE)
  
  # Handle row deletions
  observeEvent(input[[paste0("delete_", expSuffix)]], {
    row_str <- gsub(paste0("delete_", expSuffix, "_"), "", input[[paste0("delete_", expSuffix)]])
    row_num <- as.numeric(row_str)
    
    exps <- rv()
    if (!is.na(row_num) && row_num >= 1 && row_num <= nrow(exps)) {
      exps <- exps[-row_num, ]
      rv(exps)
    }
  })
  
  return(rv)
}

#--------------------------------------------------------
#     UI
#--------------------------------------------------------
# app layout and input controls version1
ui <- page_sidebar( # version
  title = "Solow-Romer Macro Simulation",
  sidebar = sidebar( # all the input controls
    width = 600, # edit sidebar width. This is not friendly with smaller screens. I was having trouble with the sidebar overlapping with tabs so I added this to default a sidebar lenght.
    h4("Simulation Parameters"),
    sliderInput("Simulation_Period", "Simulation Period (yrs)", 
                min = 20, max = 150, value = 50, step = 1),
    sliderInput("s", "Savings Rate (s)", min = 0.001, max = 1, value = 0.2, step = 0.01), # v2.3 change to min .001 due to div by zero error
    sliderInput("delta", "Depreciation Rate (delta)", min = 0, max = .5, value = 0.15, step = 0.01),
    sliderInput("n", "n", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("z", "Parameter z", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("l", "Parameter l", min = 0, max = 0.99, value = 0.1, step = 0.01), 
    selectInput("A", "Initial value for A", choices = c(1, 100, 1000), selected = 1), # 343
    selectInput("L", "Initial value for L", choices = c(1, 100, 1000), selected = 1), # 343
    
    h4("Experiments"),
    
    # -- ADD TABSETPANEL HERE -- # v3.3.1
    do.call(tabsetPanel, c(id = "experiment_tabs",
                           lapply(1:4, function(i) {
                             tabPanel(
                               paste0("Experiments Set ", i),
                               selectInput(paste0("param_name", i), paste0("Quantitative exp (s, delta, n, z, l) Set ", i),
                                           choices = c("s", "delta", "n", "z", "l"),
                                           selected = "s"),
                               numericInput(paste0("value", i), paste0("New Value Set ", i), value = 0, step = 0.01),
                               numericInput(paste0("start_period", i), paste0("Start Period Set ", i), value = 10, step = 1),
                               numericInput(paste0("length", i), paste0("Length of Effect Set ", i), value = 200, step = 1),
                               actionButton(paste0("add_experiment", i), paste0("Add Exp ", i)),
                               fileInput(paste0("upload_file_", i), paste0("Upload Excel for Exp ", i), accept = c(".xlsx", ".xls")),
                               div(style = "width: 400px;", DTOutput(paste0("experimentsTable", i)))
                             )
                           })
    )),
    # -- END TABSETPANEL -- # v3.3.1
    
    checkboxInput("show_no_exp",    "Show Counterfactual",       value = TRUE),
    checkboxInput("show_third_exp", "Show Third Experiment",     value = FALSE), # v3.3
    checkboxInput("show_fourth_exp","Show Fourth Experiment",    value = FALSE), # v3.3
    checkboxInput("show_fifth_exp", "Show Fifth Experiment",     value = FALSE), # v3.3
    
    actionButton("simulate", "Simulate"),
    h4("Download Results"),
    downloadButton("downloadPlots", "Download All Plots as PNG (ZIP)"),
    downloadButton("downloadData", "Download Data as CSV")
  ),
  mainPanel( # tab controls. v1
    tabsetPanel(
      tabPanel("World", # v 2.2
               # adding option to get average savings rate
               selectInput("selectedSheet", "Select Region", choices = NULL),
               selectInput("selectedColumn", "Select Country", choices = NULL),
               numericInput("startYear", "Start Year", value = 1960),
               numericInput("endYear",   "End Year",   value = 2023),
               actionButton("calculateAvg", "Get Avg Savings Rate 's'"),
               verbatimTextOutput("avgSavingsRate")  # displays the avg s calculated
      ),
      tabPanel("Plots",
               div(style = "width: 1800px; margin: auto;",
                   fluidRow(
                     column(6, plotOutput("plot_K", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_Y", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_little_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_percent_delta_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_MPK", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_MPL", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Log/Ratio scale",
               div(style = "width: 1800px; margin: auto;",
                   fluidRow(
                     column(6, plotOutput("plot_log_L", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_K", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_log_Y", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_A", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Table", tableOutput("resultsTable")),
      tabPanel("No Experiments", tableOutput("resultsNoExpTable")),
      tabPanel("Third Scenario", tableOutput("resultsThirdDfTable")),  # v3: 2nd experiment df
      tabPanel("Fourth Scenario", tableOutput("resultsFourthDfTable")), # v3 
      tabPanel("Fifth Scenario", tableOutput("resultsFifthDfTable"))  # v3
    )
  )
)

#--------------------------------------------------------
#     SERVER # version1
#--------------------------------------------------------
server <- function(input, output, session) {
  
  # adding option for Savings rate average for list of countries. 
  excel_list <- import_list("data/savings_rate_y.xlsx") # v2.2
  
  # Populate region choices
  observe({  # v2.2
    updateSelectInput(session, "selectedSheet", choices = names(excel_list), selected = names(excel_list)[1])
  })
  observeEvent(input$selectedSheet, {  # Update column choices  # v2.2
    df <- excel_list[[input$selectedSheet]]
    updateSelectInput(session, "selectedColumn", choices = setdiff(names(df), "year"), selected = setdiff(names(df), "year")[1])
  })
  
  # find the available years
  observeEvent(input$selectedColumn, { # v2.2
    df <- excel_list[[input$selectedSheet]]
    yearVals <- df$year
    yVals <- as.numeric(df[[input$selectedColumn]])
    valid <- !is.na(yearVals) & !is.na(yVals)
    if (!any(valid)) return()
    validYears <- yearVals[valid]
    minY <- min(validYears)
    maxY <- max(validYears)
    updateNumericInput(session, "startYear", min = minY, max = maxY, value = minY)
    updateNumericInput(session, "endYear",   min = minY, max = maxY, value = maxY)
  })
  
  # Calculate average within the chosen year range
  observeEvent(input$calculateAvg, {
    df <- excel_list[[input$selectedSheet]]
    yearVals <- df$year
    yVals <- as.numeric(df[[input$selectedColumn]])
    valid <- !is.na(yearVals) & !is.na(yVals)
    dfValid <- df[valid, ]
    
    subsetData <- dfValid[dfValid$year >= input$startYear & dfValid$year <= input$endYear, ]
    if (nrow(subsetData) == 0) {  # Check if country has any data
      output$avgSavingsRate <- renderPrint("Country Data Not Available") 
      return()
    }
    
    avgVal <- (mean(subsetData[[input$selectedColumn]]))/100
    updateSliderInput(session, "s", value = avgVal)
    output$avgSavingsRate <- renderPrint(paste("Average Savings Rate:", avgVal)) # Display the average
  }) # v2.2
  
  #----------------------------------
  # EXPERIMENTS TABLE MANAGEMENT # v3 
  #----------------------------------
  # This code along w/ the initializeExperiment function help loop in experiment simulations. 
  experiment_sets <- lapply(1:4, function(i) { # v3.2 looping exp tables
    initializeExperimentSet(
      expSuffix        = as.character(i),
      paramNameInput   = paste0("param_name", i),
      newValueInput    = paste0("value", i),
      startPeriodInput = paste0("start_period", i),
      lengthInput      = paste0("length", i),
      addExpButton     = paste0("add_experiment", i),
      dtOutput         = paste0("experimentsTable", i),
      deleteRowInput   = paste0("delete_", i),
      input = input, output = output, session = session
    )
  })
  names(experiment_sets) <- paste0("experiments", 1:4)  # v3.2 looping exp tables
  
  
  # v3.1: adding excel upload for faster param inputs
  # v3.2: loop this to match expe loop code
  for (i in 1:4) {
    local({
      set_index <- i
      observeEvent(input[[paste0("upload_file_", set_index)]], {
        req(input[[paste0("upload_file_", set_index)]])
        df_uploaded <- import(input[[paste0("upload_file_", set_index)]]$datapath)
        
        # Validate columns
        required_cols <- c("param", "value", "start_period", "length")
        if (!all(required_cols %in% names(df_uploaded))) {
          showModal(modalDialog(
            title = "Error",
            "The uploaded file must contain columns: param, value, start_period, length.",
            easyClose = TRUE
          ))
          return(NULL)
        }
        
        # Append
        current_data <- experiment_sets[[paste0("experiments", set_index)]]()
        updated_data <- rbind(current_data, df_uploaded)
        experiment_sets[[paste0("experiments", set_index)]](updated_data)
      }) # v3.1 and v3.2 end
    })
  }
  
  #----------------------------------
  # 2. SOLOW SIMULATION
  #----------------------------------
  
  simulate_solow <- function(num_periods, s, delta, n, z, l, A_init, L_init, experiments_df = NULL) {
    params <- data.frame(
      Period   = 0:(num_periods - 1),
      s        = rep(s, num_periods),
      delta    = rep(delta, num_periods),
      n        = rep(n, num_periods),
      z        = rep(z, num_periods),
      l        = rep(l, num_periods),
      delta_k  = rep(0.0, num_periods),
      percent_delta_k = rep(0.0, num_periods),
      little_k = rep(0.0, num_periods),
      A        = rep(A_init, num_periods),
      L        = rep(L_init, num_periods),
      K        = rep(0.0, num_periods),
      Y        = rep(0.0, num_periods)
    )
    
    # Calculate initial Capital per Capita Steady state k* 
    k_star_initial <- (s / (delta + n + z*l))^(1.5)*(1 - l)
    params$little_k[1] <- k_star_initial
    
    # this does the quantitative experiments. version 2.1
    if (!is.null(experiments_df) && nrow(experiments_df) > 0) { # v2.1
      for (exp in seq_len(nrow(experiments_df))) {
        start <- experiments_df$start_period[exp] + 1
        end   <- min(start + experiments_df$length[exp] - 1, num_periods)
        param_name <- experiments_df$param[exp]
        value  <- experiments_df$value[exp]
        params[start:end, param_name] <- value
      }
    }
    
    # Calculation portion. # v2.1
    # the "for (i in seq_len" makes sure all calculations are done in that order once every period. If you need to ask why don't edit this portion. 
    for (i in seq_len(num_periods)) { 
      if (i == 1) { # i=1 corresponds to Period=0 in the df
        params$delta_k[i] <- 0
      } else {
        # i-1 = t - 1
        params$delta_k[i] <- params$s[i] * ( (1 - params$l[i])^(2/3) ) * 
          (params$little_k[i-1]^(1/3)) - 
          (params$z[i] * params$l[i] + params$n[i] + params$delta[i]) * params$little_k[i-1]
        
        params$little_k[i] <- params$little_k[i-1] + params$delta_k[i]
      } # different calculation if period 0 or >0
      
      if (i > 1) {# cant be done till period 1. 
        params$A[i] <- params$A[i-1] * (1 + params$z[i]*params$l[i])
        params$L[i] <- params$L[i-1] * (1 + params$n[i])
      }
      
      # this calculations are done every period
      params$K[i] <- params$little_k[i] * params$A[i] * params$L[i]
      params$Y[i] <- (1 - params$l[i])^(2/3) * params$K[i]^(1/3) * (params$A[i] * params$L[i])^(2/3)
    }
    
    # this calculations are done once the for i loop is done for better app efficiency. 
    params$MPL <- (1 - (1/3)) * ((1 - params$l)^(1 - (1/3))) * (params$K / (params$A * params$L)^(1/3)) * params$A # v3.3.1 ch function from ch5 mpk to ch6 mpk
    params$MPK <- (1/3) * ((1 - params$l)^(1 - (1/3))) * (((params$A *  params$L) / params$K)^(1 - (1/3))) # v3.3.1 ch function from ch5 mpk to ch6 mpk
    params$log_L <- log(params$L)
    params$log_K <- log(params$K)
    params$log_Y <- log(params$Y)
    params$log_A <- log(params$A)
    params$percent_delta_k <- (params$delta_k / params$little_k) * 100 # v2.3
    
    params # v3. before v3, this was return(params)
    # when adding calc that need plots = add to tabpanel, and both codes.
  }
  
  #----------------------------------
  # EVENT-REACTIVE RESULTS
  #----------------------------------
  # v3.2 edit to loop with lapply exp tables
  
  results <- eventReactive(input$simulate, { # v2.1
    # If first set is empty, show a modal (original logic)
    if (nrow(experiment_sets$experiments1()) == 0) {
      showModal(modalDialog(
        title = "Error",
        "Please add at least one experiment in Set 1 before running the simulation.",
        easyClose = TRUE,
        footer = NULL
      ))
      return(NULL)
    }
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    
    # v3: streamline this section of the simulate_solow.
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiment_sets$experiments1()) # v3
  })
  
  results_no_exp <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = NULL) # v3
  })
  
  # v3: adding the 3 extra experiment simulations
  results_third_df <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    experiments_df_to_use <- if (nrow(experiment_sets$experiments2()) == 0) NULL else experiment_sets$experiments2()
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiments_df_to_use)
  })
  
  results_fourth_df <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    experiments_df_to_use <- if (nrow(experiment_sets$experiments3()) == 0) NULL else experiment_sets$experiments3()
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiments_df_to_use)
  })
  
  results_fifth_df <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    experiments_df_to_use <- if (nrow(experiment_sets$experiments4()) == 0) NULL else experiment_sets$experiments4()
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiments_df_to_use)
  }) 
  
  # v3.2 updated to be loop with exp tables
  
  
  #----------------------------------
  # 4. OUTPUT: TABLES
  #----------------------------------
  
  # v3 not much change from before v3c for results, and results_no_exp, but
  # added the 3 results tables for the other experiments
  output$resultsTable <- renderTable({req(results()); 
    results()}, rownames = FALSE) # v3
  output$resultsNoExpTable <- renderTable({ req(results_no_exp()) ; 
    results_no_exp() }, rownames = FALSE) # v3
  output$resultsThirdDfTable <- renderTable({ req(results_third_df()); 
    results_third_df() }, rownames = FALSE) # v3
  output$resultsFourthDfTable<- renderTable({ req(results_fourth_df()); 
    results_fourth_df() }, rownames = FALSE) # v3
  output$resultsFifthDfTable <- renderTable({ req(results_fifth_df()); 
    results_fifth_df() }, rownames = FALSE) # v3
  
  #---------------------------
  # 5. PLOTS # v3.3
  #---------------------------
  plot_theme <- theme_bw() + 
    theme(
      plot.title        = element_text(hjust = 0.5),
      axis.title        = element_text(size = 12),
      axis.text         = element_text(size = 10),
      panel.grid.major  = element_line(color = "grey80"),
      panel.grid.minor  = element_blank(),
      strip.background  = element_rect(fill = "grey90", color = "grey90")
    )
  
  # Extended make_plot to include optional 3rd,4th,5th data
  make_plot <- function(
    data_exp,      # "With Experiments" (the main one from Set 1)
    data_no_exp,   # "Without Experiments" (counterfactual)
    data_third = NULL,
    data_fourth = NULL,
    data_fifth = NULL,
    y_var, title, y_label,
    show_no_exp = TRUE,
    show_third_exp = FALSE,
    show_fourth_exp = FALSE,
    show_fifth_exp = FALSE
  ) {
    
    # Base plot with the main experiment data
    p <- ggplot(data_exp, aes(x = Period, y = .data[[y_var]])) +
      geom_line(aes(color = "With Experiments")) +
      geom_point(aes(color = "With Experiments")) +
      scale_color_manual(values = c("With Experiments" = "blue",
                                    "Without Experiments" = "red",
                                    "Third Scenario"  = "green",
                                    "Fourth Scenario" = "purple",
                                    "Fifth Scenario"  = "orange")) +
      ggtitle(title) + xlab("Period") + ylab(y_label) +
      plot_theme
    
    # Optionally add no-exp line
    if (show_no_exp && !is.null(data_no_exp)) {
      p <- p +
        geom_line(data = data_no_exp, 
                  aes(x = Period, y = .data[[y_var]], color = "Without Experiments"), 
                  linetype = "dashed") +
        geom_point(data = data_no_exp, 
                   aes(x = Period, y = .data[[y_var]], color = "Without Experiments"), 
                   shape = 1, size = 3)
    }
    
    # Optionally add third scenario
    if (show_third_exp && !is.null(data_third)) {
      p <- p +
        geom_line(data = data_third,
                  aes(x = Period, y = .data[[y_var]], color = "Third Scenario")) +
        geom_point(data = data_third,
                   aes(x = Period, y = .data[[y_var]], color = "Third Scenario"), size = 2)
    }
    
    # Optionally add fourth scenario
    if (show_fourth_exp && !is.null(data_fourth)) {
      p <- p +
        geom_line(data = data_fourth,
                  aes(x = Period, y = .data[[y_var]], color = "Fourth Scenario")) +
        geom_point(data = data_fourth,
                   aes(x = Period, y = .data[[y_var]], color = "Fourth Scenario"), size = 2)
    }
    
    # Optionally add fifth scenario
    if (show_fifth_exp && !is.null(data_fifth)) {
      p <- p +
        geom_line(data = data_fifth,
                  aes(x = Period, y = .data[[y_var]], color = "Fifth Scenario")) +
        geom_point(data = data_fifth,
                   aes(x = Period, y = .data[[y_var]], color = "Fifth Scenario"), size = 2)
    }
    
    p
  }
  
  # Store plots for download
  plot_objects <- reactiveValues()
  
  output$plot_K <- renderPlot({
    req(results(), results_no_exp(), results_third_df(), results_fourth_df(), results_fifth_df())
    p <- make_plot(
      data_exp      = results(),
      data_no_exp   = results_no_exp(),
      data_third    = results_third_df(),
      data_fourth   = results_fourth_df(),
      data_fifth    = results_fifth_df(),
      y_var         = "K",
      title         = "Capital (K) Over Time",
      y_label       = "Capital (K)",
      show_no_exp   = input$show_no_exp,
      show_third_exp = input$show_third_exp,
      show_fourth_exp = input$show_fourth_exp,
      show_fifth_exp  = input$show_fifth_exp
    )
    plot_objects$plot_K <- p
    p
  }, res = 100)
  
  output$plot_Y <- renderPlot({
    req(results(), results_no_exp(), results_third_df(), results_fourth_df(), results_fifth_df())
    p <- make_plot(
      data_exp      = results(),
      data_no_exp   = results_no_exp(),
      data_third    = results_third_df(),
      data_fourth   = results_fourth_df(),
      data_fifth    = results_fifth_df(),
      y_var         = "Y",
      title         = "Output (Y) Over Time",
      y_label       = "Output (Y)",
      show_no_exp   = input$show_no_exp,
      show_third_exp = input$show_third_exp,
      show_fourth_exp = input$show_fourth_exp,
      show_fifth_exp  = input$show_fifth_exp
    )
    plot_objects$plot_Y <- p
    p
  }, res = 100)
  
  output$plot_little_k <- renderPlot({
    req(results(), results_no_exp(), results_third_df(), results_fourth_df(), results_fifth_df())
    p <- make_plot(
      data_exp      = results(),
      data_no_exp   = results_no_exp(),
      data_third    = results_third_df(),
      data_fourth   = results_fourth_df(),
      data_fifth    = results_fifth_df(),
      y_var         = "little_k",
      title         = "Capital Efficiency Units",
      y_label       = "k (Capital Efficiency Units)",
      show_no_exp   = input$show_no_exp,
      show_third_exp = input$show_third_exp,
      show_fourth_exp = input$show_fourth_exp,
      show_fifth_exp  = input$show_fifth_exp
    )
    plot_objects$plot_little_k <- p
    p
  }, res = 100)
  
  output$plot_percent_delta_k <- renderPlot({
    req(results(), results_no_exp(), results_third_df(), results_fourth_df(), results_fifth_df())
    p <- make_plot(
      data_exp      = results(),
      data_no_exp   = results_no_exp(),
      data_third    = results_third_df(),
      data_fourth   = results_fourth_df(),
      data_fifth    = results_fifth_df(),
      y_var         = "percent_delta_k",
      title         = "Percent Change in Capital Over Time",
      y_label       = "Δk/k",
      show_no_exp   = input$show_no_exp,
      show_third_exp = input$show_third_exp,
      show_fourth_exp = input$show_fourth_exp,
      show_fifth_exp  = input$show_fifth_exp
    )
    plot_objects$plot_percent_delta_k <- p
    p
  }, res = 100)
  
  output$plot_MPK <- renderPlot({
    req(results(), results_no_exp(), results_third_df(), results_fourth_df(), results_fifth_df())
    p <- make_plot(
      data_exp      = results(),
      data_no_exp   = results_no_exp(),
      data_third    = results_third_df(),
      data_fourth   = results_fourth_df(),
      data_fifth    = results_fifth_df(),
      y_var         = "MPK",
      title         = "Interest Rate Return on Capital", # r = MPK # v3.3.1
      y_label       = "r",
      show_no_exp   = input$show_no_exp,
      show_third_exp = input$show_third_exp,
      show_fourth_exp = input$show_fourth_exp,
      show_fifth_exp  = input$show_fifth_exp
    )
    plot_objects$plot_MPK <- p
    p
  }, res = 100)
  
  output$plot_MPL <- renderPlot({
    req(results(), results_no_exp(), results_third_df(), results_fourth_df(), results_fifth_df())
    p <- make_plot(
      data_exp      = results(),
      data_no_exp   = results_no_exp(),
      data_third    = results_third_df(),
      data_fourth   = results_fourth_df(),
      data_fifth    = results_fifth_df(),
      y_var         = "MPL",
      title         = "Wage Rate",
      y_label       = "w",
      show_no_exp   = input$show_no_exp,
      show_third_exp = input$show_third_exp,
      show_fourth_exp = input$show_fourth_exp,
      show_fifth_exp  = input$show_fifth_exp
    )
    plot_objects$plot_MPL <- p
    p
  }, res = 100)
  
  output$plot_log_L <- renderPlot({
    req(results(), results_no_exp(), results_third_df(), results_fourth_df(), results_fifth_df())
    p <- make_plot(
      data_exp      = results(),
      data_no_exp   = results_no_exp(),
      data_third    = results_third_df(),
      data_fourth   = results_fourth_df(),
      data_fifth    = results_fifth_df(),
      y_var         = "log_L",
      title         = "Log of Labor (L) Over Time",
      y_label       = "Log(L)",
      show_no_exp   = input$show_no_exp,
      show_third_exp = input$show_third_exp,
      show_fourth_exp = input$show_fourth_exp,
      show_fifth_exp  = input$show_fifth_exp
    )
    plot_objects$plot_log_L <- p
    p
  }, res = 100)
  
  output$plot_log_K <- renderPlot({
    req(results(), results_no_exp(), results_third_df(), results_fourth_df(), results_fifth_df())
    p <- make_plot(
      data_exp      = results(),
      data_no_exp   = results_no_exp(),
      data_third    = results_third_df(),
      data_fourth   = results_fourth_df(),
      data_fifth    = results_fifth_df(),
      y_var         = "log_K",
      title         = "Log of Capital (K) Over Time",
      y_label       = "Log(K)",
      show_no_exp   = input$show_no_exp,
      show_third_exp = input$show_third_exp,
      show_fourth_exp = input$show_fourth_exp,
      show_fifth_exp  = input$show_fifth_exp
    )
    plot_objects$plot_log_K <- p
    p
  }, res = 100)
  
  output$plot_log_Y <- renderPlot({
    req(results(), results_no_exp(), results_third_df(), results_fourth_df(), results_fifth_df())
    p <- make_plot(
      data_exp      = results(),
      data_no_exp   = results_no_exp(),
      data_third    = results_third_df(),
      data_fourth   = results_fourth_df(),
      data_fifth    = results_fifth_df(),
      y_var         = "log_Y",
      title         = "Log of Output (Y) Over Time",
      y_label       = "Log(Y)",
      show_no_exp   = input$show_no_exp,
      show_third_exp = input$show_third_exp,
      show_fourth_exp = input$show_fourth_exp,
      show_fifth_exp  = input$show_fifth_exp
    )
    plot_objects$plot_log_Y <- p
    p
  }, res = 100)
  
  output$plot_log_A <- renderPlot({
    req(results(), results_no_exp(), results_third_df(), results_fourth_df(), results_fifth_df())
    p <- make_plot(
      data_exp      = results(),
      data_no_exp   = results_no_exp(),
      data_third    = results_third_df(),
      data_fourth   = results_fourth_df(),
      data_fifth    = results_fifth_df(),
      y_var         = "log_A",
      title         = "Log of TFP (A) Over Time",
      y_label       = "Log(A)",
      show_no_exp   = input$show_no_exp,
      show_third_exp = input$show_third_exp,
      show_fourth_exp = input$show_fourth_exp,
      show_fifth_exp  = input$show_fifth_exp
    )
    plot_objects$plot_log_A <- p
    p
  }, res = 100) # v3.3: this whole plot code is new with v3.3
  
  
  #----------------------------------
  # DOWNLOAD HANDLERS
  #----------------------------------
  output$downloadData <- downloadHandler( # version1
    filename = function() {
      paste0("results_", Sys.Date(), ".csv")
    },
    content = function(file) {req(results()) # v2.1
      write.csv(results(), file, row.names = FALSE)
    }
  )
  
  output$downloadPlots <- downloadHandler( # version1
    filename = function() { 
      paste0("plots_", Sys.Date(), ".zip")
    },
    content = function(file) {
      temp_dir <- tempdir() # temp file storage but new shiny update change the way file downloads happen so this might not be needed now
      file_paths <- c()
      
      # Use the stored plot objects version2
      plots <- reactiveValuesToList(plot_objects) # Convert reactiveValues to list
      plots <- Filter(Negate(is.null), plots) # Remove NULL entries
      
      for (plot_name in names(plots)) { # Save each plot to a PNG version1
        plot_file <- file.path(temp_dir, paste0(plot_name, ".png"))
        ggsave(plot_file, plots[[plot_name]], device = "png")
        file_paths <- c(file_paths, plot_file)
      }
      zipr(zipfile = file, files = file_paths) # zip em. v1
    }
  )
}

shinyApp(ui = ui, server = server)

# this is same as v3.3r but im moving exp tables back to sidebar per Moncayo request

# this code is newer tham v3.3 , and will be mark by v3.3.1
# suprisingly the onlycode that change was the ui tabsetpanel code. 
# i move exp tables back to sidebar. 
# after removing them from the sidebar previously, I made a function to loop the making of the exp tables, and loop in the adding of an excel file. 
# re adding them to the sidebar, i kept the loop code but made a call function. This seems to have slowed the app opening a bit, but just need to confirm if this works. 
# i'm not to concerned about it taking a few seconds though

# initially the MPK and MPL where made to fit the ch5 functions and when confirmed I was going to swtich to Ch 6 MPK and MPL whihc i did in this version. v3.3.1 

# v3.3.1

```


I should probably start a new qmd. This one just pass 8k lines of source code.


# spacer


```{r}
# v3.3.2
library(shiny)
library(ggplot2)
library(DT)    # for interactive table
library(zip)   # to create ZIP files in download handler
library(bslib)
library(rio)   # to read the Excel file # v2.2

#--- Helper function to create each experiment set. ---
initializeExperimentSet <- function(
    expSuffix,         # label like "1", "2", "3", or "4"
    paramNameInput,    # e.g. "param_name", "param_name2"
    newValueInput,     # e.g. "value", "value2"
    startPeriodInput,  # e.g. "start_period", "start_period2"
    lengthInput,       # e.g. "length", "length2"
    addExpButton,      # e.g. "add_experiment", "add_experiment2"
    dtOutput,          # e.g. "experimentsTable", "experimentsTable2"
    deleteRowInput,    # internal ID prefix for deletion, e.g. "delete_1", "delete_2"
    input, output, session
) {
  
  # A reactiveVal to hold the table of experiments for this set
  rv <- reactiveVal(
    data.frame(
      param        = character(0),
      value    = numeric(0),
      start_period = integer(0),
      length       = integer(0),
      stringsAsFactors = FALSE
    )
  )
  
  # Add new experiment row when the user clicks
  observeEvent(input[[addExpButton]], {
    new_experiment <- data.frame(
      param        = input[[paramNameInput]],
      value    = input[[newValueInput]],
      start_period = input[[startPeriodInput]],
      length       = input[[lengthInput]],
      stringsAsFactors = FALSE
    )
    rv( rbind(rv(), new_experiment) )
  })
  
  # Render the experiments table with "Delete" buttons
  output[[dtOutput]] <- renderDT({
    exps <- rv()
    if (nrow(exps) == 0) return(NULL)
    
    deleteButtons <- sapply(seq_len(nrow(exps)), function(i) {
      as.character(
        actionButton(
          inputId = paste0("delete_", expSuffix, "_", i),
          label = "Delete",
          class = "btn btn-danger btn-sm",
          onclick = paste0(
            'Shiny.setInputValue("delete_', expSuffix, '", this.id, {priority: "event"})'
          )
        )
      )
    })
    
    exps$Delete <- deleteButtons
    
    datatable(
      exps,
      escape = FALSE,
      selection = "none",
      options   = list(pageLength = 5)
    )
  }, server = FALSE)
  
  # Handle row deletions
  observeEvent(input[[paste0("delete_", expSuffix)]], {
    row_str <- gsub(paste0("delete_", expSuffix, "_"), "", input[[paste0("delete_", expSuffix)]])
    row_num <- as.numeric(row_str)
    
    exps <- rv()
    if (!is.na(row_num) && row_num >= 1 && row_num <= nrow(exps)) {
      exps <- exps[-row_num, ]
      rv(exps)
    }
  })
  
  return(rv)
}

#--------------------------------------------------------
#     UI
#--------------------------------------------------------
# app layout and input controls version1
ui <- page_sidebar( # version
  title = "Solow-Romer Macro Simulation",
  sidebar = sidebar( # all the input controls
    width = 600, # edit sidebar width. This is not friendly with smaller screens. I was having trouble with the sidebar overlapping with tabs so I added this to default a sidebar lenght.
    h4("Simulation Parameters"),
    sliderInput("Simulation_Period", "Simulation Period (yrs)", 
                min = 20, max = 150, value = 50, step = 1),
    sliderInput("s", "Savings Rate (s)", min = 0.001, max = 1, value = 0.2, step = 0.01), # v2.3 change to min .001 due to div by zero error
    sliderInput("delta", "Depreciation Rate (delta)", min = 0, max = .5, value = 0.15, step = 0.01),
    sliderInput("n", "n", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("z", "Parameter z", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("l", "Parameter l", min = 0, max = 0.99, value = 0.1, step = 0.01), 
    selectInput("A", "Initial value for A", choices = c(1, 100, 1000), selected = 1), # 343
    selectInput("L", "Initial value for L", choices = c(1, 100, 1000), selected = 1), # 343
    
    h4("Experiments"),
    
    # -- ADD TABSETPANEL HERE -- # v3.3.1
    do.call(tabsetPanel, c(id = "experiment_tabs",
                           lapply(1:4, function(i) {
                             tabPanel(
                               paste0("Experiments Set ", i),
                               selectInput(paste0("param_name", i), paste0("Quantitative exp (s, delta, n, z, l) Set ", i),
                                           choices = c("s", "delta", "n", "z", "l"),
                                           selected = "s"),
                               numericInput(paste0("value", i), paste0("New Value Set ", i), value = 0, step = 0.01),
                               numericInput(paste0("start_period", i), paste0("Start Period Set ", i), value = 10, step = 1),
                               numericInput(paste0("length", i), paste0("Length of Effect Set ", i), value = 200, step = 1),
                               actionButton(paste0("add_experiment", i), paste0("Add Exp ", i)),
                               fileInput(paste0("upload_file_", i), paste0("Upload Excel for Exp ", i), accept = c(".xlsx", ".xls")),
                               div(style = "width: 400px;", DTOutput(paste0("experimentsTable", i)))
                             )
                           })
    )),
    # -- END TABSETPANEL -- # v3.3.1
    
    checkboxInput("show_counter_visual",    "Show Counterfactual",       value = TRUE),
    checkboxInput("show_second_exp_visual", "Show Second Experiment",     value = FALSE), # v3.3
    checkboxInput("show_third_exp_visual","Show Third Experiment",    value = FALSE), # v3.3
    checkboxInput("show_fourth_exp_visual", "Show Fourth Experiment",     value = FALSE), # v3.3
    
    actionButton("simulate", "Simulate"),
    h4("Download Results"),
    downloadButton("downloadPlots", "Download All Plots as PNG (ZIP)"),
    downloadButton("downloadData", "Download Data as CSV")
  ),
  mainPanel( # tab controls. v1
    tabsetPanel(
      tabPanel("World", # v 2.2
               # adding option to get average savings rate
               selectInput("selectedSheet", "Select Region", choices = NULL),
               selectInput("selectedColumn", "Select Country", choices = NULL),
               numericInput("startYear", "Start Year", value = 1960),
               numericInput("endYear",   "End Year",   value = 2023),
               actionButton("calculateAvg", "Get Avg Savings Rate 's'"),
               verbatimTextOutput("avgSavingsRate")  # displays the avg s calculated
      ),
      tabPanel("Plots",
               div(style = "width: 1800px; margin: auto;",
                   fluidRow(
                     column(6, plotOutput("plot_K", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_Y", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_little_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_percent_delta_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_MPK", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_MPL", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Log/Ratio scale",
               div(style = "width: 1800px; margin: auto;",
                   fluidRow(
                     column(6, plotOutput("plot_log_L", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_K", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_log_Y", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_A", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("First Scenario", tableOutput("results_first_exp_df")),
      tabPanel("Counterfactual", tableOutput("results_counterfactual_df")),
      tabPanel("Second Scenario", tableOutput("results_second_exp_df")),  # v3: 2nd experiment df
      tabPanel("Third Scenario", tableOutput("results_third_exp_df")), # v3 
      tabPanel("Fourth Scenario", tableOutput("results_fourth_exp_df"))  # v3
    )
  )
)

#--------------------------------------------------------
#     SERVER # version1
#--------------------------------------------------------
server <- function(input, output, session) {
  
  # adding option for Savings rate average for list of countries. 
  excel_list <- import_list("data/savings_rate_y.xlsx") # v2.2
  
  # Populate region choices
  observe({  # v2.2
    updateSelectInput(session, "selectedSheet", choices = names(excel_list), selected = names(excel_list)[1])
  })
  observeEvent(input$selectedSheet, {  # Update column choices  # v2.2
    df <- excel_list[[input$selectedSheet]]
    updateSelectInput(session, "selectedColumn", choices = setdiff(names(df), "year"), selected = setdiff(names(df), "year")[1])
  })
  
  # find the available years
  observeEvent(input$selectedColumn, { # v2.2
    df <- excel_list[[input$selectedSheet]]
    yearVals <- df$year
    yVals <- as.numeric(df[[input$selectedColumn]])
    valid <- !is.na(yearVals) & !is.na(yVals)
    if (!any(valid)) return()
    validYears <- yearVals[valid]
    minY <- min(validYears)
    maxY <- max(validYears)
    updateNumericInput(session, "startYear", min = minY, max = maxY, value = minY)
    updateNumericInput(session, "endYear",   min = minY, max = maxY, value = maxY)
  })
  
  # Calculate average within the chosen year range
  observeEvent(input$calculateAvg, {
    df <- excel_list[[input$selectedSheet]]
    yearVals <- df$year
    yVals <- as.numeric(df[[input$selectedColumn]])
    valid <- !is.na(yearVals) & !is.na(yVals)
    dfValid <- df[valid, ]
    
    subsetData <- dfValid[dfValid$year >= input$startYear & dfValid$year <= input$endYear, ]
    if (nrow(subsetData) == 0) {  # Check if country has any data
      output$avgSavingsRate <- renderPrint("Country Data Not Available") 
      return()
    }
    
    avgVal <- (mean(subsetData[[input$selectedColumn]]))/100
    updateSliderInput(session, "s", value = avgVal)
    output$avgSavingsRate <- renderPrint(paste("Average Savings Rate:", avgVal)) # Display the average
  }) # v2.2
  
  #----------------------------------
  # EXPERIMENTS TABLE MANAGEMENT # v3 
  #----------------------------------
  # This code along w/ the initializeExperiment function help loop in experiment simulations. 
  experiment_sets <- lapply(1:4, function(i) { # v3.2 looping exp tables
    initializeExperimentSet(
      expSuffix        = as.character(i),
      paramNameInput   = paste0("param_name", i),
      newValueInput    = paste0("value", i),
      startPeriodInput = paste0("start_period", i),
      lengthInput      = paste0("length", i),
      addExpButton     = paste0("add_experiment", i),
      dtOutput         = paste0("experimentsTable", i),
      deleteRowInput   = paste0("delete_", i),
      input = input, output = output, session = session
    )
  })
  names(experiment_sets) <- paste0("experiments", 1:4)  # v3.2 looping exp tables
  
  
  # v3.1: adding excel upload for faster param inputs
  # v3.2: loop this to match expe loop code
  for (i in 1:4) {
    local({
      set_index <- i
      observeEvent(input[[paste0("upload_file_", set_index)]], {
        req(input[[paste0("upload_file_", set_index)]])
        df_uploaded <- import(input[[paste0("upload_file_", set_index)]]$datapath)
        
        # Validate columns
        required_cols <- c("param", "value", "start_period", "length")
        if (!all(required_cols %in% names(df_uploaded))) {
          showModal(modalDialog(
            title = "Error",
            "The uploaded file must contain columns: param, value, start_period, length.",
            easyClose = TRUE
          ))
          return(NULL)
        }
        
        # Append
        current_data <- experiment_sets[[paste0("experiments", set_index)]]()
        updated_data <- rbind(current_data, df_uploaded)
        experiment_sets[[paste0("experiments", set_index)]](updated_data)
      }) # v3.1 and v3.2 end
    })
  }
  
  #----------------------------------
  # 2. SOLOW SIMULATION
  #----------------------------------
  
  simulate_solow <- function(num_periods, s, delta, n, z, l, A_init, L_init, experiments_df = NULL) {
    params <- data.frame(
      Period   = 0:(num_periods - 1),
      s        = rep(s, num_periods),
      delta    = rep(delta, num_periods),
      n        = rep(n, num_periods),
      z        = rep(z, num_periods),
      l        = rep(l, num_periods),
      delta_k  = rep(0.0, num_periods),
      percent_delta_k = rep(0.0, num_periods),
      little_k = rep(0.0, num_periods),
      A        = rep(A_init, num_periods),
      L        = rep(L_init, num_periods),
      K        = rep(0.0, num_periods),
      Y        = rep(0.0, num_periods)
    )
    
    # Calculate initial Capital per Capita Steady state k* 
    k_star_initial <- (s / (delta + n + z*l))^(1.5)*(1 - l)
    params$little_k[1] <- k_star_initial
    
    # this does the quantitative experiments. version 2.1
    if (!is.null(experiments_df) && nrow(experiments_df) > 0) { # v2.1
      for (exp in seq_len(nrow(experiments_df))) {
        start <- experiments_df$start_period[exp] + 1
        end   <- min(start + experiments_df$length[exp] - 1, num_periods)
        param_name <- experiments_df$param[exp]
        value  <- experiments_df$value[exp]
        params[start:end, param_name] <- value
      }
    }
    
    # Calculation portion. # v2.1
    # the "for (i in seq_len" makes sure all calculations are done in that order once every period. If you need to ask why don't edit this portion. 
    for (i in seq_len(num_periods)) { 
      if (i == 1) { # i=1 corresponds to Period=0 in the df
        params$delta_k[i] <- 0
      } else {
        # i-1 = t - 1
        params$delta_k[i] <- params$s[i] * ( (1 - params$l[i])^(2/3) ) * 
          (params$little_k[i-1]^(1/3)) - 
          (params$z[i] * params$l[i] + params$n[i] + params$delta[i]) * params$little_k[i-1]
        
        params$little_k[i] <- params$little_k[i-1] + params$delta_k[i]
      } # different calculation if period 0 or >0
      
      if (i > 1) {# cant be done till period 1. 
        params$A[i] <- params$A[i-1] * (1 + params$z[i]*params$l[i])
        params$L[i] <- params$L[i-1] * (1 + params$n[i])
      }
      
      # this calculations are done every period
      params$K[i] <- params$little_k[i] * params$A[i] * params$L[i]
      params$Y[i] <- (1 - params$l[i])^(2/3) * params$K[i]^(1/3) * (params$A[i] * params$L[i])^(2/3)
    }
    
    # this calculations are done once the for i loop is done for better app efficiency. 
    params$MPL <- (1 - (1/3)) * ((1 - params$l)^(1 - (1/3))) * (params$K / (params$A * params$L)^(1/3)) * params$A # v3.3.1 ch function from ch5 mpk to ch6 mpk
    params$MPK <- (1/3) * ((1 - params$l)^(1 - (1/3))) * (((params$A *  params$L) / params$K)^(1 - (1/3))) # v3.3.1 ch function from ch5 mpk to ch6 mpk
    params$log_L <- log(params$L)
    params$log_K <- log(params$K)
    params$log_Y <- log(params$Y)
    params$log_A <- log(params$A)
    params$percent_delta_k <- (params$delta_k / params$little_k) * 100 # v2.3
    
    params # v3. before v3, this was return(params)
    # when adding calc that need plots = add to tabpanel, and both codes.
  }
  
  #----------------------------------
  # EVENT-REACTIVE RESULTS
  #----------------------------------
  # v3.2 edit to loop with lapply exp tables
  
  simulate_first_exp_calculations <- eventReactive(input$simulate, { # v2.1
    # If first set is empty, show a modal (original logic)
    if (nrow(experiment_sets$experiments1()) == 0) {
      showModal(modalDialog(
        title = "Error",
        "Please add at least one experiment in Set 1 before running the simulation.",
        easyClose = TRUE,
        footer = NULL
      ))
      return(NULL)
    }
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    
    # v3: streamline this section of the simulate_solow.
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiment_sets$experiments1()) # v3
  })
  
  simulate_counter_exp_calculations <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = NULL) # v3
  })
  
  # v3: adding the 3 extra experiment simulations
  simulate_second_exp_calculations <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    experiments_df_to_use <- if (nrow(experiment_sets$experiments2()) == 0) NULL else experiment_sets$experiments2()
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiments_df_to_use)
  })
  
  simulate_third_exp_calculations <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    experiments_df_to_use <- if (nrow(experiment_sets$experiments3()) == 0) NULL else experiment_sets$experiments3()
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiments_df_to_use)
  })
  
  simulate_fourth_exp_calculations <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    experiments_df_to_use <- if (nrow(experiment_sets$experiments4()) == 0) NULL else experiment_sets$experiments4()
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiments_df_to_use)
  }) 
  
  # v3.2 updated to be loop with exp tables
  
  
  #----------------------------------
  # 4. OUTPUT: TABLES - data frames
  #----------------------------------
  
  # v3 not much change from before v3c for results, and simulate_counter_exp_calculations, but
  # added the 3 results tables for the other experiments
  output$results_first_exp_df <- renderTable({req(simulate_first_exp_calculations()); 
    simulate_first_exp_calculations()}, rownames = FALSE) # v3
  output$results_counterfactual_df <- renderTable({ req(simulate_counter_exp_calculations()) ; 
    simulate_counter_exp_calculations() }, rownames = FALSE) # v3
  output$results_second_exp_df <- renderTable({ req(simulate_second_exp_calculations()); 
    simulate_second_exp_calculations() }, rownames = FALSE) # v3
  output$results_third_exp_df<- renderTable({ req(simulate_third_exp_calculations()); 
    simulate_third_exp_calculations() }, rownames = FALSE) # v3
  output$results_fourth_exp_df <- renderTable({ req(simulate_fourth_exp_calculations()); 
    simulate_fourth_exp_calculations() }, rownames = FALSE) # v3
  
  #---------------------------
  # 5. PLOTS # v3.3
  #---------------------------
  plot_theme <- theme_bw() + 
    theme(
      plot.title        = element_text(hjust = 0.5),
      axis.title        = element_text(size = 12),
      axis.text         = element_text(size = 10),
      panel.grid.major  = element_line(color = "grey80"),
      panel.grid.minor  = element_blank(),
      strip.background  = element_rect(fill = "grey90", color = "grey90")
    )
  
  # Extended make_plot to include optional 3rd,4th,5th data
  make_plot <- function(
    data_exp,      # "First Scenario" (the main one from Set 1)
    data_default_counter,   # "Counterfactual" (counterfactual)
    data_third = NULL,
    data_fourth = NULL,
    data_fifth = NULL,
    y_var, title, y_label,
    show_counter_visual = TRUE,
    show_second_exp_visual = FALSE,
    show_third_exp_visual = FALSE,
    show_fourth_exp_visual = FALSE
  ) {
    
    # Base plot with the main experiment data
    p <- ggplot(data_exp, aes(x = Period, y = .data[[y_var]])) +
      geom_line(aes(color = "First Scenario")) +
      geom_point(aes(color = "First Scenario")) +
      scale_color_manual(values = c("First Scenario" = "blue",
                                    "Counterfactual" = "red",
                                    "Second Scenario"  = "green",
                                    "Third Scenario" = "purple",
                                    "Fourth Scenario"  = "orange")) +
      ggtitle(title) + xlab("Period") + ylab(y_label) +
      plot_theme
    
    # Optionally add no-exp line
    if (show_counter_visual && !is.null(data_default_counter)) {
      p <- p +
        geom_line(data = data_default_counter, 
                  aes(x = Period, y = .data[[y_var]], color = "Counterfactual"), 
                  linetype = "dashed") +
        geom_point(data = data_default_counter, 
                   aes(x = Period, y = .data[[y_var]], color = "Counterfactual"), 
                   shape = 1, size = 3)
    }
    
    # Optionally add Second Scenario
    if (show_second_exp_visual && !is.null(data_third)) {
      p <- p +
        geom_line(data = data_third,
                  aes(x = Period, y = .data[[y_var]], color = "Second Scenario")) +
        geom_point(data = data_third,
                   aes(x = Period, y = .data[[y_var]], color = "Second Scenario"), size = 2)
    }
    
    # Optionally add Third Scenario
    if (show_third_exp_visual && !is.null(data_fourth)) {
      p <- p +
        geom_line(data = data_fourth,
                  aes(x = Period, y = .data[[y_var]], color = "Third Scenario")) +
        geom_point(data = data_fourth,
                   aes(x = Period, y = .data[[y_var]], color = "Third Scenario"), size = 2)
    }
    
    # Optionally add Fourth Scenario
    if (show_fourth_exp_visual && !is.null(data_fifth)) {
      p <- p +
        geom_line(data = data_fifth,
                  aes(x = Period, y = .data[[y_var]], color = "Fourth Scenario")) +
        geom_point(data = data_fifth,
                   aes(x = Period, y = .data[[y_var]], color = "Fourth Scenario"), size = 2)
    }
    
    p
  }
  
  # Store plots for download
  plot_objects <- reactiveValues()
  
  output$plot_K <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "K",
      title         = "Capital (K) Over Time",
      y_label       = "Capital (K)",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_K <- p
    p
  }, res = 100)
  
  output$plot_Y <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "Y",
      title         = "Output (Y) Over Time",
      y_label       = "Output (Y)",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_Y <- p
    p
  }, res = 100)
  
  output$plot_little_k <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "little_k",
      title         = "Capital Efficiency Units",
      y_label       = "k (Capital Efficiency Units)",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_little_k <- p
    p
  }, res = 100)
  
  output$plot_percent_delta_k <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "percent_delta_k",
      title         = "Percent Change in Capital Over Time",
      y_label       = "Δk/k",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_percent_delta_k <- p
    p
  }, res = 100)
  
  output$plot_MPK <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "MPK",
      title         = "Interest Rate Return on Capital", # r = MPK # v3.3.1
      y_label       = "r",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_MPK <- p
    p
  }, res = 100)
  
  output$plot_MPL <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "MPL",
      title         = "Wage Rate",
      y_label       = "w",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_MPL <- p
    p
  }, res = 100)
  
  output$plot_log_L <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "log_L",
      title         = "Log of Labor (L) Over Time",
      y_label       = "Log(L)",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_log_L <- p
    p
  }, res = 100)
  
  output$plot_log_K <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "log_K",
      title         = "Log of Capital (K) Over Time",
      y_label       = "Log(K)",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_log_K <- p
    p
  }, res = 100)
  
  output$plot_log_Y <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "log_Y",
      title         = "Log of Output (Y) Over Time",
      y_label       = "Log(Y)",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_log_Y <- p
    p
  }, res = 100)
  
  output$plot_log_A <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "log_A",
      title         = "Log of TFP (A) Over Time",
      y_label       = "Log(A)",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_log_A <- p
    p
  }, res = 100) # v3.3: this whole plot code is new with v3.3
  
  
  #----------------------------------
  # DOWNLOAD HANDLERS
  #----------------------------------
  output$downloadData <- downloadHandler( # version1
    filename = function() {
      paste0("results_", Sys.Date(), ".csv")
    },
    content = function(file) {req(simulate_first_exp_calculations()) # v2.1
      write.csv(simulate_first_exp_calculations(), file, row.names = FALSE)
    }
  )
  
  output$downloadPlots <- downloadHandler( # version1
    filename = function() { 
      paste0("plots_", Sys.Date(), ".zip")
    },
    content = function(file) {
      temp_dir <- tempdir() # temp file storage but new shiny update change the way file downloads happen so this might not be needed now
      file_paths <- c()
      
      # Use the stored plot objects version2
      plots <- reactiveValuesToList(plot_objects) # Convert reactiveValues to list
      plots <- Filter(Negate(is.null), plots) # Remove NULL entries
      
      for (plot_name in names(plots)) { # Save each plot to a PNG version1
        plot_file <- file.path(temp_dir, paste0(plot_name, ".png"))
        ggsave(plot_file, plots[[plot_name]], device = "png")
        file_paths <- c(file_paths, plot_file)
      }
      zipr(zipfile = file, files = file_paths) # zip em. v1
    }
  )
}

shinyApp(ui = ui, server = server)

# v3.3.2
# change "without experiments" to "counterfactual"
# change no_exp to default_counter
# change results table names (results_exp_  (first ... fourth))
# end it up changing a lot of the variable names to match the order and names of experiments. Also name them base on what they are doing, (eg: simulate_first_exp... is connected to the simulation code, while show_second_exp_visual is connected to the visual code or what shows up in the plots,  results_fourth_exp_df is the df reuslts for that experiment etc)

# deploying this one to test out live
# made a lot of variable name changes, and small possibility of mistakenly changing the wrong variable name

# v3.3.2

```


model spacer
# spacer

```{r}
# v3.3.3 

library(shiny)
library(ggplot2)
library(DT)    # for interactive table
library(zip)   # to create ZIP files in download handler
library(bslib)
library(rio)   # to read the Excel file # v2.2

#--- Helper function to create each experiment set. ---
initializeExperimentSet <- function(
    expSuffix,         # label like "1", "2", "3", or "4"
    paramNameInput,    # e.g. "param_name", "param_name2"
    newValueInput,     # e.g. "value", "value2"
    startPeriodInput,  # e.g. "start_period", "start_period2"
    lengthInput,       # e.g. "length", "length2"
    addExpButton,      # e.g. "add_experiment", "add_experiment2"
    dtOutput,          # e.g. "experimentsTable", "experimentsTable2"
    deleteRowInput,    # internal ID prefix for deletion, e.g. "delete_1", "delete_2"
    input, output, session
) {
  
  # A reactiveVal to hold the table of experiments for this set
  rv <- reactiveVal(
    data.frame(
      param        = character(0),
      value    = numeric(0),
      start_period = integer(0),
      length       = integer(0),
      stringsAsFactors = FALSE
    )
  )
  
  # Add new experiment row when the user clicks
  observeEvent(input[[addExpButton]], {
    new_experiment <- data.frame(
      param        = input[[paramNameInput]],
      value    = input[[newValueInput]],
      start_period = input[[startPeriodInput]],
      length       = input[[lengthInput]],
      stringsAsFactors = FALSE
    )
    rv( rbind(rv(), new_experiment) )
  })
  
  # Render the experiments table with "Delete" buttons
  output[[dtOutput]] <- renderDT({
    exps <- rv()
    if (nrow(exps) == 0) return(NULL)
    
    deleteButtons <- sapply(seq_len(nrow(exps)), function(i) {
      as.character(
        actionButton(
          inputId = paste0("delete_", expSuffix, "_", i),
          label = "Delete",
          class = "btn btn-danger btn-sm",
          onclick = paste0(
            'Shiny.setInputValue("delete_', expSuffix, '", this.id, {priority: "event"})'
          )
        )
      )
    })
    
    exps$Delete <- deleteButtons
    
    datatable(
      exps,
      escape = FALSE,
      selection = "none",
      options   = list(pageLength = 5)
    )
  }, server = FALSE)
  
  # Handle row deletions
  observeEvent(input[[paste0("delete_", expSuffix)]], {
    row_str <- gsub(paste0("delete_", expSuffix, "_"), "", input[[paste0("delete_", expSuffix)]])
    row_num <- as.numeric(row_str)
    
    exps <- rv()
    if (!is.na(row_num) && row_num >= 1 && row_num <= nrow(exps)) {
      exps <- exps[-row_num, ]
      rv(exps)
    }
  })
  
  return(rv)
}

#--------------------------------------------------------
#     UI
#--------------------------------------------------------
# app layout and input controls version1
ui <- page_sidebar( # version
  title = "Solow-Romer Macro Simulation",
  sidebar = sidebar( # all the input controls
    width = 600, # edit sidebar width. This is not friendly with smaller screens. I was having trouble with the sidebar overlapping with tabs so I added this to default a sidebar lenght.
    h4("Simulation Parameters"),
    sliderInput("Simulation_Period", "Simulation Period (yrs)", 
                min = 20, max = 150, value = 50, step = 1),
    sliderInput("s", "Savings Rate (s)", min = 0.001, max = 1, value = 0.2, step = 0.01), # v2.3 change to min .001 due to div by zero error
    sliderInput("delta", "Depreciation Rate (delta)", min = 0, max = .5, value = 0.15, step = 0.01),
    sliderInput("n", "n", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("z", "Parameter z", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("l", "Parameter l", min = 0, max = 0.99, value = 0.1, step = 0.01), 
    selectInput("A", "Initial value for A", choices = c(1, 100, 1000), selected = 1), # 343
    selectInput("L", "Initial value for L", choices = c(1, 100, 1000), selected = 1), # 343
    
    h4("Experiments"),
    
    # -- ADD TABSETPANEL HERE -- # v3.3.1
    do.call(tabsetPanel, c(id = "experiment_tabs",
                           lapply(1:4, function(i) {
                             tabPanel(
                               paste0("Experiments Set ", i),
                               selectInput(paste0("param_name", i), paste0("Quantitative exp (s, delta, n, z, l) Set ", i),
                                           choices = c("s", "delta", "n", "z", "l"),
                                           selected = "s"),
                               numericInput(paste0("value", i), paste0("New Value Set ", i), value = 0, step = 0.01),
                               numericInput(paste0("start_period", i), paste0("Start Period Set ", i), value = 10, step = 1),
                               numericInput(paste0("length", i), paste0("Length of Effect Set ", i), value = 200, step = 1),
                               actionButton(paste0("add_experiment", i), paste0("Add Exp ", i)),
                               fileInput(paste0("upload_file_", i), paste0("Upload Excel for Exp ", i), accept = c(".xlsx", ".xls")),
                               div(style = "width: 400px;", DTOutput(paste0("experimentsTable", i)))
                             )
                           })
    )),
    # -- END TABSETPANEL -- # v3.3.1
    
    checkboxInput("show_counter_visual",    "Show Counterfactual",       value = TRUE),
    checkboxInput("show_second_exp_visual", "Show Second Experiment",     value = FALSE), # v3.3
    checkboxInput("show_third_exp_visual","Show Third Experiment",    value = FALSE), # v3.3
    checkboxInput("show_fourth_exp_visual", "Show Fourth Experiment",     value = FALSE), # v3.3
    
    actionButton("simulate", "Simulate"),
    h4("Download Results"),
    downloadButton("downloadPlots", "Download All Plots as PNG (ZIP)"),
    downloadButton("downloadData", "Download Data as CSV")
  ),
  mainPanel( # tab controls. v1
    tabsetPanel(
      tabPanel("World", # v 2.2
               # adding option to get average savings rate
               selectInput("selectedSheet", "Select Region", choices = NULL),
               selectInput("selectedColumn", "Select Country", choices = NULL),
               numericInput("startYear", "Start Year", value = 1960),
               numericInput("endYear",   "End Year",   value = 2023),
               actionButton("calculateAvg", "Get Avg Savings Rate 's'"),
               verbatimTextOutput("avgSavingsRate")  # displays the avg s calculated
      ),
      tabPanel("Plots",
               div(style = "width: 1800px; margin: auto;",
                   fluidRow(
                     column(6, plotOutput("plot_K", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_Y", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_little_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_percent_delta_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_MPK", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_MPL", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Log/Ratio scale",
               div(style = "width: 1800px; margin: auto;",
                   fluidRow(
                     column(6, plotOutput("plot_log_L", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_K", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_log_Y", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_A", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("First Scenario", tableOutput("results_first_exp_df")),
      tabPanel("Counterfactual", tableOutput("results_counterfactual_df")),
      tabPanel("Second Scenario", tableOutput("results_second_exp_df")),  # v3: 2nd experiment df
      tabPanel("Third Scenario", tableOutput("results_third_exp_df")), # v3 
      tabPanel("Fourth Scenario", tableOutput("results_fourth_exp_df"))  # v3
    )
  )
)

#--------------------------------------------------------
#     SERVER # version1
#--------------------------------------------------------
server <- function(input, output, session) {
  
  # adding option for Savings rate average for list of countries. 
  excel_list <- import_list("data/savings_rate_y.xlsx") # v2.2
  
  # Populate region choices
  observe({  # v2.2
    updateSelectInput(session, "selectedSheet", choices = names(excel_list), selected = names(excel_list)[1])
  })
  observeEvent(input$selectedSheet, {  # Update column choices  # v2.2
    df <- excel_list[[input$selectedSheet]]
    updateSelectInput(session, "selectedColumn", choices = setdiff(names(df), "year"), selected = setdiff(names(df), "year")[1])
  })
  
  # find the available years
  observeEvent(input$selectedColumn, { # v2.2
    df <- excel_list[[input$selectedSheet]]
    yearVals <- df$year
    yVals <- as.numeric(df[[input$selectedColumn]])
    valid <- !is.na(yearVals) & !is.na(yVals)
    if (!any(valid)) return()
    validYears <- yearVals[valid]
    minY <- min(validYears)
    maxY <- max(validYears)
    updateNumericInput(session, "startYear", min = minY, max = maxY, value = minY)
    updateNumericInput(session, "endYear",   min = minY, max = maxY, value = maxY)
  })
  
  # Calculate average within the chosen year range
  observeEvent(input$calculateAvg, {
    df <- excel_list[[input$selectedSheet]]
    yearVals <- df$year
    yVals <- as.numeric(df[[input$selectedColumn]])
    valid <- !is.na(yearVals) & !is.na(yVals)
    dfValid <- df[valid, ]
    
    subsetData <- dfValid[dfValid$year >= input$startYear & dfValid$year <= input$endYear, ]
    if (nrow(subsetData) == 0) {  # Check if country has any data
      output$avgSavingsRate <- renderPrint("Country Data Not Available") 
      return()
    }
    
    avgVal <- (mean(subsetData[[input$selectedColumn]]))/100
    updateSliderInput(session, "s", value = avgVal)
    output$avgSavingsRate <- renderPrint(paste("Average Savings Rate:", avgVal)) # Display the average
  }) # v2.2
  
  #----------------------------------
  # EXPERIMENTS TABLE MANAGEMENT # v3 
  #----------------------------------
  # This code along w/ the initializeExperiment function help loop in experiment simulations. 
  experiment_sets <- lapply(1:4, function(i) { # v3.2 looping exp tables
    initializeExperimentSet(
      expSuffix        = as.character(i),
      paramNameInput   = paste0("param_name", i),
      newValueInput    = paste0("value", i),
      startPeriodInput = paste0("start_period", i),
      lengthInput      = paste0("length", i),
      addExpButton     = paste0("add_experiment", i),
      dtOutput         = paste0("experimentsTable", i),
      deleteRowInput   = paste0("delete_", i),
      input = input, output = output, session = session
    )
  })
  names(experiment_sets) <- paste0("experiments", 1:4)  # v3.2 looping exp tables
  
  
  # v3.1: adding excel upload for faster param inputs
  # v3.2: loop this to match expe loop code
  for (i in 1:4) {
    local({
      set_index <- i
      observeEvent(input[[paste0("upload_file_", set_index)]], {
        req(input[[paste0("upload_file_", set_index)]])
        df_uploaded <- import(input[[paste0("upload_file_", set_index)]]$datapath)
        
        # Validate columns
        required_cols <- c("param", "value", "start_period", "length")
        if (!all(required_cols %in% names(df_uploaded))) {
          showModal(modalDialog(
            title = "Error",
            "The uploaded file must contain columns: param, value, start_period, length.",
            easyClose = TRUE
          ))
          return(NULL)
        }
        
        # Append
        current_data <- experiment_sets[[paste0("experiments", set_index)]]()
        updated_data <- rbind(current_data, df_uploaded)
        experiment_sets[[paste0("experiments", set_index)]](updated_data)
      }) # v3.1 and v3.2 end
    })
  }
  
  #----------------------------------
  # 2. SOLOW SIMULATION
  #----------------------------------
  
  simulate_solow <- function(num_periods, s, delta, n, z, l, A_init, L_init, experiments_df = NULL) {
    params <- data.frame(
      Period   = 0:(num_periods - 1),
      s        = rep(s, num_periods),
      delta    = rep(delta, num_periods),
      n        = rep(n, num_periods),
      z        = rep(z, num_periods),
      l        = rep(l, num_periods),
      delta_k  = rep(0.0, num_periods),
      percent_delta_k = rep(0.0, num_periods),
      little_k = rep(0.0, num_periods),
      A        = rep(A_init, num_periods),
      L        = rep(L_init, num_periods),
      K        = rep(0.0, num_periods),
      Y        = rep(0.0, num_periods)
    )
    
    # Calculate initial Capital per Capita Steady state k* 
    k_star_initial <- (s / (delta + n + z*l))^(1.5)*(1 - l)
    params$little_k[1] <- k_star_initial
    
    # this does the quantitative experiments. version 2.1
    if (!is.null(experiments_df) && nrow(experiments_df) > 0) { # v2.1
      for (exp in seq_len(nrow(experiments_df))) {
        start <- experiments_df$start_period[exp] + 1
        end   <- min(start + experiments_df$length[exp] - 1, num_periods)
        param_name <- experiments_df$param[exp]
        value  <- experiments_df$value[exp]
        params[start:end, param_name] <- value
      }
    }
    
    # Calculation portion. # v2.1
    # the "for (i in seq_len" makes sure all calculations are done in that order once every period. If you need to ask why don't edit this portion. 
    for (i in seq_len(num_periods)) { 
      if (i == 1) { # i=1 corresponds to Period=0 in the df
        params$delta_k[i] <- 0
      } else {
        # i-1 = t - 1
        params$delta_k[i] <- params$s[i] * ( (1 - params$l[i])^(2/3) ) * 
          (params$little_k[i-1]^(1/3)) - 
          (params$z[i] * params$l[i] + params$n[i] + params$delta[i]) * params$little_k[i-1]
        
        params$little_k[i] <- params$little_k[i-1] + params$delta_k[i]
      } # different calculation if period 0 or >0
      
      if (i > 1) {# cant be done till period 1. 
        params$A[i] <- params$A[i-1] * (1 + params$z[i]*params$l[i])
        params$L[i] <- params$L[i-1] * (1 + params$n[i])
      }
      
      # this calculations are done every period
      params$K[i] <- params$little_k[i] * params$A[i] * params$L[i]
      params$Y[i] <- (1 - params$l[i])^(2/3) * params$K[i]^(1/3) * (params$A[i] * params$L[i])^(2/3)
    }
    
    # this calculations are done once the for i loop is done for better app efficiency. 
    params$MPL <- (1 - (1/3)) * ((1 - params$l)^(1 - (1/3))) * (params$K / (params$A * params$L)^(1/3)) * params$A # v3.3.1 ch function from ch5 mpk to ch6 mpk
    params$MPK <- (1/3) * ((1 - params$l)^(1 - (1/3))) * (((params$A *  params$L) / params$K)^(1 - (1/3))) # v3.3.1 ch function from ch5 mpk to ch6 mpk
    params$log_L <- log(params$L)
    params$log_K <- log(params$K)
    params$log_Y <- log(params$Y)
    params$log_A <- log(params$A)
    params$percent_delta_k <- ((round(params$delta_k, 3)) / params$little_k) * 100 # v3.3.3 rounded 3 decimal places
    
    params # v3. before v3, this was return(params)
    # when adding calc that need plots = add to tabpanel, and both codes.
  }
  
  #----------------------------------
  # EVENT-REACTIVE RESULTS
  #----------------------------------
  # v3.2 edit to loop with lapply exp tables
  
  simulate_first_exp_calculations <- eventReactive(input$simulate, { # v2.1
    # If first set is empty, show a modal (original logic)
    if (nrow(experiment_sets$experiments1()) == 0) {
      showModal(modalDialog(
        title = "Error",
        "Please add at least one experiment in Set 1 before running the simulation.",
        easyClose = TRUE,
        footer = NULL
      ))
      return(NULL)
    }
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    
    # v3: streamline this section of the simulate_solow.
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiment_sets$experiments1()) # v3
  })
  
  simulate_counter_exp_calculations <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = NULL) # v3
  })
  
  # v3: adding the 3 extra experiment simulations
  simulate_second_exp_calculations <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    experiments_df_to_use <- if (nrow(experiment_sets$experiments2()) == 0) NULL else experiment_sets$experiments2()
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiments_df_to_use)
  })
  
  simulate_third_exp_calculations <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    experiments_df_to_use <- if (nrow(experiment_sets$experiments3()) == 0) NULL else experiment_sets$experiments3()
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiments_df_to_use)
  })
  
  simulate_fourth_exp_calculations <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    experiments_df_to_use <- if (nrow(experiment_sets$experiments4()) == 0) NULL else experiment_sets$experiments4()
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiments_df_to_use)
  }) 
  
  # v3.2 updated to be loop with exp tables
  
  
  #----------------------------------
  # 4. OUTPUT: TABLES - data frames
  #----------------------------------
  
  # v3 not much change from before v3c for results, and simulate_counter_exp_calculations, but
  # added the 3 results tables for the other experiments
  output$results_first_exp_df <- renderTable({req(simulate_first_exp_calculations()); 
    simulate_first_exp_calculations()}, rownames = FALSE) # v3
  output$results_counterfactual_df <- renderTable({ req(simulate_counter_exp_calculations()) ; 
    simulate_counter_exp_calculations() }, rownames = FALSE) # v3
  output$results_second_exp_df <- renderTable({ req(simulate_second_exp_calculations()); 
    simulate_second_exp_calculations() }, rownames = FALSE) # v3
  output$results_third_exp_df<- renderTable({ req(simulate_third_exp_calculations()); 
    simulate_third_exp_calculations() }, rownames = FALSE) # v3
  output$results_fourth_exp_df <- renderTable({ req(simulate_fourth_exp_calculations()); 
    simulate_fourth_exp_calculations() }, rownames = FALSE) # v3
  
  #---------------------------
  # 5. PLOTS # v3.3
  #---------------------------
  plot_theme <- theme_bw() + 
    theme(
      plot.title        = element_text(hjust = 0.5),
      axis.title        = element_text(size = 12),
      axis.text         = element_text(size = 10),
      panel.grid.major  = element_line(color = "grey80"),
      panel.grid.minor  = element_blank(),
      strip.background  = element_rect(fill = "grey90", color = "grey90")
    )
  
  # Extended make_plot to include optional 3rd,4th,5th data
  make_plot <- function(
    data_exp,      # "First Scenario" (the main one from Set 1)
    data_default_counter,   # "Counterfactual" (counterfactual)
    data_third = NULL,
    data_fourth = NULL,
    data_fifth = NULL,
    y_var, title, y_label,
    show_counter_visual = TRUE,
    show_second_exp_visual = FALSE,
    show_third_exp_visual = FALSE,
    show_fourth_exp_visual = FALSE
  ) {
    
    # Base plot with the main experiment data
    p <- ggplot(data_exp, aes(x = Period, y = .data[[y_var]])) +
      geom_line(aes(color = "First Scenario")) +
      geom_point(data = if(nrow(data_exp) > 10) { # v3.3.3 adding point limit
        data_exp[round(seq(1, nrow(data_exp), length.out = 10)), ]
      } else {
        data_exp
      }, aes(color = "First Scenario")) + # v3.3.3 end of adding point limit
      scale_color_manual(values = c("First Scenario" = "blue",
                                    "Counterfactual" = "red",
                                    "Second Scenario"  = "green",
                                    "Third Scenario" = "purple",
                                    "Fourth Scenario"  = "orange")) +
      ggtitle(title) + xlab("Period") + ylab(y_label) +
      plot_theme
    
    # Optionally add no-exp line
    if (show_counter_visual && !is.null(data_default_counter)) {
      p <- p +
        geom_line(data = data_default_counter, 
                  aes(x = Period, y = .data[[y_var]], color = "Counterfactual"), 
                  linetype = "dashed") +
        geom_point(data = if(nrow(data_default_counter) > 12) { # v3.3.3 adding point limit
          tmp <- data_default_counter[-1, ] # remove n rows
          tmp[round(seq(1, nrow(tmp), length.out = 12)), ]
        } else {
          data_default_counter[-1, ] # end v3.3.3 limit points
        }, aes(x = Period, y = .data[[y_var]], color = "Counterfactual"), 
                   shape = 1, size = 2)
    }
    
    # Optionally add Second Scenario
    if (show_second_exp_visual && !is.null(data_third)) {
      p <- p +
        geom_line(data = data_third,
                  aes(x = Period, y = .data[[y_var]], color = "Second Scenario")) +
        geom_point(data = if(nrow(data_third) > 14) { # v3.3.3 adding point limit
          tmp <- data_third[-(1:3), ]
          tmp[round(seq(1, nrow(tmp), length.out = 14)), ]
        } else {
          data_third[-(1:3), ] # end v3.3.3 
        }, aes(x = Period, y = .data[[y_var]], color = "Second Scenario"), size = 1)
    }
    
    # Optionally add Third Scenario
    if (show_third_exp_visual && !is.null(data_fourth)) {
      p <- p +
        geom_line(data = data_fourth,
                  aes(x = Period, y = .data[[y_var]], color = "Third Scenario")) +
        geom_point(data = if(nrow(data_fourth) > 16) { # v3.3.3 adding point limit
          tmp <- data_fourth[-(1:5), ]
          tmp[round(seq(1, nrow(tmp), length.out = 16)), ]
        } else {
          data_fourth[-(1:5), ] # end v3.3.3 
        }, aes(x = Period, y = .data[[y_var]], color = "Third Scenario"), size = 1)
    }
    
    # Optionally add Fourth Scenario
    if (show_fourth_exp_visual && !is.null(data_fifth)) {
      p <- p +
        geom_line(data = data_fifth,
                  aes(x = Period, y = .data[[y_var]], color = "Fourth Scenario")) +
        geom_point(data = if(nrow(data_fifth) > 18) { # v3.3.3 adding point limit
          tmp <- data_fifth[-(1:7), ]
          tmp[round(seq(1, nrow(tmp), length.out = 18)), ]
        } else {
          data_fifth[-(1:7), ] # end v3.3.3 
        }, aes(x = Period, y = .data[[y_var]], color = "Fourth Scenario"), size = 1)
    }
    
    p
  }
  
  # Store plots for download
  plot_objects <- reactiveValues()
  
  output$plot_K <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "K",
      title         = "Capital (K) Over Time",
      y_label       = "Capital (K)",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_K <- p
    p
  }, res = 100)
  
  output$plot_Y <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "Y",
      title         = "Output (Y) Over Time",
      y_label       = "Output (Y)",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_Y <- p
    p
  }, res = 100)
  
  output$plot_little_k <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "little_k",
      title         = "Capital Efficiency Units",
      y_label       = "k (Capital Efficiency Units)",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_little_k <- p
    p
  }, res = 100)
  
  output$plot_percent_delta_k <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "percent_delta_k",
      title         = "Percent Change in Capital Over Time",
      y_label       = "Δk/k (Percent)",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_percent_delta_k <- p
    p
  }, res = 100)
  
  output$plot_MPK <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "MPK",
      title         = "Interest Rate Return on Capital", # r = MPK # v3.3.1
      y_label       = "r",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_MPK <- p
    p
  }, res = 100)
  
  output$plot_MPL <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "MPL",
      title         = "Wage Rate",
      y_label       = "w",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_MPL <- p
    p
  }, res = 100)
  
  output$plot_log_L <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "log_L",
      title         = "Log of Labor (L) Over Time",
      y_label       = "Log(L)",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_log_L <- p
    p
  }, res = 100)
  
  output$plot_log_K <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "log_K",
      title         = "Log of Capital (K) Over Time",
      y_label       = "Log(K)",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_log_K <- p
    p
  }, res = 100)
  
  output$plot_log_Y <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "log_Y",
      title         = "Log of Output (Y) Over Time",
      y_label       = "Log(Y)",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_log_Y <- p
    p
  }, res = 100)
  
  output$plot_log_A <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "log_A",
      title         = "Log of TFP (A) Over Time",
      y_label       = "Log(A)",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_log_A <- p
    p
  }, res = 100) # v3.3: this whole plot code is new with v3.3
  
  
  #----------------------------------
  # DOWNLOAD HANDLERS
  #----------------------------------
  output$downloadData <- downloadHandler( # version1
    filename = function() {
      paste0("results_", Sys.Date(), ".csv")
    },
    content = function(file) {req(simulate_first_exp_calculations()) # v2.1
      write.csv(simulate_first_exp_calculations(), file, row.names = FALSE)
    }
  )
  
  output$downloadPlots <- downloadHandler( # version1
    filename = function() { 
      paste0("plots_", Sys.Date(), ".zip")
    },
    content = function(file) {
      temp_dir <- tempdir() # temp file storage but new shiny update change the way file downloads happen so this might not be needed now
      file_paths <- c()
      
      # Use the stored plot objects version2
      plots <- reactiveValuesToList(plot_objects) # Convert reactiveValues to list
      plots <- Filter(Negate(is.null), plots) # Remove NULL entries
      
      for (plot_name in names(plots)) { # Save each plot to a PNG version1
        plot_file <- file.path(temp_dir, paste0(plot_name, ".png"))
        ggsave(plot_file, plots[[plot_name]], device = "png")
        file_paths <- c(file_paths, plot_file)
      }
      zipr(zipfile = file, files = file_paths) # zip em. v1
    }
  )
}

shinyApp(ui = ui, server = server)

# v3.3.3

# changing plot visuals, like line size and shape
# rounded delta_k 3 decimal places in the calculation of percent_delta_k
# edit delta_k_name


```

# spacer

```{r}
# v3.3.3.1
library(shiny)
library(ggplot2)
library(DT)    # for interactive table
library(zip)   # to create ZIP files in download handler
library(bslib)
library(rio)   # to read the Excel file # v2.2

#--- Helper function to create each experiment set. ---
initializeExperimentSet <- function(
    expSuffix,         # label like "1", "2", "3", or "4"
    paramNameInput,    # e.g. "param_name", "param_name2"
    newValueInput,     # e.g. "value", "value2"
    startPeriodInput,  # e.g. "start_period", "start_period2"
    lengthInput,       # e.g. "length", "length2"
    addExpButton,      # e.g. "add_experiment", "add_experiment2"
    dtOutput,          # e.g. "experimentsTable", "experimentsTable2"
    deleteRowInput,    # internal ID prefix for deletion, e.g. "delete_1", "delete_2"
    input, output, session
) {
  
  # A reactiveVal to hold the table of experiments for this set
  rv <- reactiveVal(
    data.frame(
      param        = character(0),
      value    = numeric(0),
      start_period = integer(0),
      length       = integer(0),
      stringsAsFactors = FALSE
    )
  )
  
  # Add new experiment row when the user clicks
  observeEvent(input[[addExpButton]], {
    new_experiment <- data.frame(
      param        = input[[paramNameInput]],
      value    = input[[newValueInput]],
      start_period = input[[startPeriodInput]],
      length       = input[[lengthInput]],
      stringsAsFactors = FALSE
    )
    rv( rbind(rv(), new_experiment) )
  })
  
  # Render the experiments table with "Delete" buttons
  output[[dtOutput]] <- renderDT({
    exps <- rv()
    if (nrow(exps) == 0) return(NULL)
    
    deleteButtons <- sapply(seq_len(nrow(exps)), function(i) {
      as.character(
        actionButton(
          inputId = paste0("delete_", expSuffix, "_", i),
          label = "Delete",
          class = "btn btn-danger btn-sm",
          onclick = paste0(
            'Shiny.setInputValue("delete_', expSuffix, '", this.id, {priority: "event"})'
          )
        )
      )
    })
    
    exps$Delete <- deleteButtons
    
    datatable(
      exps,
      escape = FALSE,
      selection = "none",
      options   = list(pageLength = 5)
    )
  }, server = FALSE)
  
  # Handle row deletions
  observeEvent(input[[paste0("delete_", expSuffix)]], {
    row_str <- gsub(paste0("delete_", expSuffix, "_"), "", input[[paste0("delete_", expSuffix)]])
    row_num <- as.numeric(row_str)
    
    exps <- rv()
    if (!is.na(row_num) && row_num >= 1 && row_num <= nrow(exps)) {
      exps <- exps[-row_num, ]
      rv(exps)
    }
  })
  
  return(rv)
}

#--------------------------------------------------------
#     UI
#--------------------------------------------------------
# app layout and input controls version1
ui <- page_sidebar( # version
  title = "Solow-Romer Macro Simulation",
  sidebar = sidebar( # all the input controls
    width = 600, # edit sidebar width. This is not friendly with smaller screens. I was having trouble with the sidebar overlapping with tabs so I added this to default a sidebar lenght.
    h4("Simulation Parameters"),
    sliderInput("Simulation_Period", "Simulation Period (yrs)", 
                min = 20, max = 150, value = 50, step = 1),
    sliderInput("s", "Savings Rate (s)", min = 0.001, max = 1, value = 0.2, step = 0.01), # v2.3 change to min .001 due to div by zero error
    sliderInput("delta", "Depreciation Rate (delta)", min = 0, max = .5, value = 0.15, step = 0.01),
    sliderInput("n", "n", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("z", "Parameter z", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("l", "Parameter l", min = 0, max = 0.99, value = 0.1, step = 0.01), 
    selectInput("A", "Initial value for A", choices = c(1, 100, 1000), selected = 1), # 343
    selectInput("L", "Initial value for L", choices = c(1, 100, 1000), selected = 1), # 343
    
    h4("Experiments"),
    
    # -- ADD TABSETPANEL HERE -- # v3.3.1
    do.call(tabsetPanel, c(id = "experiment_tabs",
                           lapply(1:4, function(i) {
                             tabPanel(
                               paste0("Experiments Set ", i),
                               selectInput(paste0("param_name", i), paste0("Quantitative exp (s, delta, n, z, l) Set ", i),
                                           choices = c("s", "delta", "n", "z", "l"),
                                           selected = "s"),
                               numericInput(paste0("value", i), paste0("New Value Set ", i), value = 0, step = 0.01),
                               numericInput(paste0("start_period", i), paste0("Start Period Set ", i), value = 10, step = 1),
                               numericInput(paste0("length", i), paste0("Length of Effect Set ", i), value = 200, step = 1),
                               actionButton(paste0("add_experiment", i), paste0("Add Exp ", i)),
                               fileInput(paste0("upload_file_", i), paste0("Upload Excel for Exp ", i), accept = c(".xlsx", ".xls")),
                               div(style = "width: 400px;", DTOutput(paste0("experimentsTable", i)))
                             )
                           })
    )),
    # -- END TABSETPANEL -- # v3.3.1
    
    checkboxInput("show_counter_visual",    "Show Counterfactual",       value = TRUE),
    checkboxInput("show_second_exp_visual", "Show Second Experiment",     value = FALSE), # v3.3
    checkboxInput("show_third_exp_visual","Show Third Experiment",    value = FALSE), # v3.3
    checkboxInput("show_fourth_exp_visual", "Show Fourth Experiment",     value = FALSE), # v3.3
    
    actionButton("simulate", "Simulate"),
    h4("Download Results"),
    downloadButton("downloadPlots", "Download All Plots as PNG (ZIP)"),
    downloadButton("downloadData", "Download Data as CSV")
  ),
  mainPanel( # tab controls. v1
    tabsetPanel(
      tabPanel("World", # v 2.2
               # adding option to get average savings rate
               selectInput("selectedSheet", "Select Region", choices = NULL),
               selectInput("selectedColumn", "Select Country", choices = NULL),
               numericInput("startYear", "Start Year", value = 1960),
               numericInput("endYear",   "End Year",   value = 2023),
               actionButton("calculateAvg", "Get Avg Savings Rate 's'"),
               verbatimTextOutput("avgSavingsRate")  # displays the avg s calculated
      ),
      tabPanel("Plots",
               div(style = "width: 1800px; margin: auto;",
                   fluidRow(
                     column(6, plotOutput("plot_K", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_Y", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_little_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_percent_delta_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_MPK", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_MPL", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Log/Ratio scale",
               div(style = "width: 1800px; margin: auto;",
                   fluidRow(
                     column(6, plotOutput("plot_log_L", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_K", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_log_Y", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_A", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Program Results", # v3.3.5
               tabsetPanel(
                 tabPanel("First Scenario", tableOutput("results_first_exp_df")),
                 tabPanel("Counterfactual", tableOutput("results_counterfactual_df")),
                 tabPanel("Second Scenario", tableOutput("results_second_exp_df")),
                 tabPanel("Third Scenario", tableOutput("results_third_exp_df")),
                 tabPanel("Fourth Scenario", tableOutput("results_fourth_exp_df"))
               )
      ) # v3.3.5  # v3
    )
  )
)

#--------------------------------------------------------
#     SERVER # version1
#--------------------------------------------------------
server <- function(input, output, session) {
  
  # adding option for Savings rate average for list of countries. 
  excel_list <- import_list("data/savings_rate_y.xlsx") # v2.2
  
  # Populate region choices
  observe({  # v2.2
    updateSelectInput(session, "selectedSheet", choices = names(excel_list), selected = names(excel_list)[1])
  })
  observeEvent(input$selectedSheet, {  # Update column choices  # v2.2
    df <- excel_list[[input$selectedSheet]]
    updateSelectInput(session, "selectedColumn", choices = setdiff(names(df), "year"), selected = setdiff(names(df), "year")[1])
  })
  
  # find the available years
  observeEvent(input$selectedColumn, { # v2.2
    df <- excel_list[[input$selectedSheet]]
    yearVals <- df$year
    yVals <- as.numeric(df[[input$selectedColumn]])
    valid <- !is.na(yearVals) & !is.na(yVals)
    if (!any(valid)) return()
    validYears <- yearVals[valid]
    minY <- min(validYears)
    maxY <- max(validYears)
    updateNumericInput(session, "startYear", min = minY, max = maxY, value = minY)
    updateNumericInput(session, "endYear",   min = minY, max = maxY, value = maxY)
  })
  
  # Calculate average within the chosen year range
  observeEvent(input$calculateAvg, {
    df <- excel_list[[input$selectedSheet]]
    yearVals <- df$year
    yVals <- as.numeric(df[[input$selectedColumn]])
    valid <- !is.na(yearVals) & !is.na(yVals)
    dfValid <- df[valid, ]
    
    subsetData <- dfValid[dfValid$year >= input$startYear & dfValid$year <= input$endYear, ]
    if (nrow(subsetData) == 0) {  # Check if country has any data
      output$avgSavingsRate <- renderPrint("Country Data Not Available") 
      return()
    }
    
    avgVal <- (mean(subsetData[[input$selectedColumn]]))/100
    updateSliderInput(session, "s", value = avgVal)
    output$avgSavingsRate <- renderPrint(paste("Average Savings Rate:", avgVal)) # Display the average
  }) # v2.2
  
  #----------------------------------
  # EXPERIMENTS TABLE MANAGEMENT # v3 
  #----------------------------------
  # This code along w/ the initializeExperiment function help loop in experiment simulations. 
  experiment_sets <- lapply(1:4, function(i) { # v3.2 looping exp tables
    initializeExperimentSet(
      expSuffix        = as.character(i),
      paramNameInput   = paste0("param_name", i),
      newValueInput    = paste0("value", i),
      startPeriodInput = paste0("start_period", i),
      lengthInput      = paste0("length", i),
      addExpButton     = paste0("add_experiment", i),
      dtOutput         = paste0("experimentsTable", i),
      deleteRowInput   = paste0("delete_", i),
      input = input, output = output, session = session
    )
  })
  names(experiment_sets) <- paste0("experiments", 1:4)  # v3.2 looping exp tables
  
  
  # v3.1: adding excel upload for faster param inputs
  # v3.2: loop this to match expe loop code
  for (i in 1:4) {
    local({
      set_index <- i
      observeEvent(input[[paste0("upload_file_", set_index)]], {
        req(input[[paste0("upload_file_", set_index)]])
        df_uploaded <- import(input[[paste0("upload_file_", set_index)]]$datapath)
        
        # Validate columns
        required_cols <- c("param", "value", "start_period", "length")
        if (!all(required_cols %in% names(df_uploaded))) {
          showModal(modalDialog(
            title = "Error",
            "The uploaded file must contain columns: param, value, start_period, length.",
            easyClose = TRUE
          ))
          return(NULL)
        }
        
        # Append
        current_data <- experiment_sets[[paste0("experiments", set_index)]]()
        updated_data <- rbind(current_data, df_uploaded)
        experiment_sets[[paste0("experiments", set_index)]](updated_data)
      }) # v3.1 and v3.2 end
    })
  }
  
  #----------------------------------
  # 2. SOLOW SIMULATION
  #----------------------------------
  
  simulate_solow <- function(num_periods, s, delta, n, z, l, A_init, L_init, experiments_df = NULL) {
    params <- data.frame(
      Period   = 0:(num_periods - 1),
      s        = rep(s, num_periods),
      delta    = rep(delta, num_periods),
      n        = rep(n, num_periods),
      z        = rep(z, num_periods),
      l        = rep(l, num_periods),
      delta_k  = rep(0.0, num_periods),
      percent_delta_k = rep(0.0, num_periods),
      little_k = rep(0.0, num_periods),
      A        = rep(A_init, num_periods),
      L        = rep(L_init, num_periods),
      K        = rep(0.0, num_periods),
      Y        = rep(0.0, num_periods)
    )
    
    # Calculate initial Capital per Capita Steady state k* 
    k_star_initial <- (s / (delta + n + z*l))^(1.5)*(1 - l)
    params$little_k[1] <- k_star_initial
    
    # this does the quantitative experiments. version 2.1
    if (!is.null(experiments_df) && nrow(experiments_df) > 0) { # v2.1
      for (exp in seq_len(nrow(experiments_df))) {
        start <- experiments_df$start_period[exp] + 1
        end   <- min(start + experiments_df$length[exp] - 1, num_periods)
        param_name <- experiments_df$param[exp]
        value  <- experiments_df$value[exp]
        params[start:end, param_name] <- value
      }
    }
    
    # Calculation portion. # v2.1
    # the "for (i in seq_len" makes sure all calculations are done in that order once every period. If you need to ask why don't edit this portion. 
    for (i in seq_len(num_periods)) { 
      if (i == 1) { # i=1 corresponds to Period=0 in the df
        params$delta_k[i] <- 0
      } else {
        # i-1 = t - 1
        params$delta_k[i] <- params$s[i] * ( (1 - params$l[i])^(2/3) ) * 
          (params$little_k[i-1]^(1/3)) - 
          (params$z[i] * params$l[i] + params$n[i] + params$delta[i]) * params$little_k[i-1]
        
        params$little_k[i] <- params$little_k[i-1] + params$delta_k[i]
      } # different calculation if period 0 or >0
      
      if (i > 1) {# cant be done till period 1. 
        params$A[i] <- params$A[i-1] * (1 + params$z[i]*params$l[i])
        params$L[i] <- params$L[i-1] * (1 + params$n[i])
      }
      
      # this calculations are done every period
      params$K[i] <- params$little_k[i] * params$A[i] * params$L[i]
      params$Y[i] <- (1 - params$l[i])^(2/3) * params$K[i]^(1/3) * (params$A[i] * params$L[i])^(2/3)
    }
    
    # this calculations are done once the for i loop is done for better app efficiency. 
    params$MPL <- (1 - (1/3)) * ((1 - params$l)^(1 - (1/3))) * (params$K / (params$A * params$L)^(1/3)) * params$A # v3.3.1 ch function from ch5 mpk to ch6 mpk
    params$MPK <- (1/3) * ((1 - params$l)^(1 - (1/3))) * (((params$A *  params$L) / params$K)^(1 - (1/3))) # v3.3.1 ch function from ch5 mpk to ch6 mpk
    params$log_L <- log(params$L)
    params$log_K <- log(params$K)
    params$log_Y <- log(params$Y)
    params$log_A <- log(params$A)
    params$percent_delta_k <- ((round(params$delta_k, 3)) / params$little_k) * 100 # v3.3.3 rounded 3 decimal places
    
    params # v3. before v3, this was return(params)
    # when adding calc that need plots = add to tabpanel, and both codes.
  }
  
  #----------------------------------
  # EVENT-REACTIVE RESULTS
  #----------------------------------
  # v3.2 edit to loop with lapply exp tables
  
  simulate_first_exp_calculations <- eventReactive(input$simulate, { # v2.1
    # If first set is empty, show a modal (original logic)
    if (nrow(experiment_sets$experiments1()) == 0) {
      showModal(modalDialog(
        title = "Error",
        "Please add at least one experiment in Set 1 before running the simulation.",
        easyClose = TRUE,
        footer = NULL
      ))
      return(NULL)
    }
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    
    # v3: streamline this section of the simulate_solow.
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiment_sets$experiments1()) # v3
  })
  
  simulate_counter_exp_calculations <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = NULL) # v3
  })
  
  # v3: adding the 3 extra experiment simulations
  simulate_second_exp_calculations <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    experiments_df_to_use <- if (nrow(experiment_sets$experiments2()) == 0) NULL else experiment_sets$experiments2()
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiments_df_to_use)
  })
  
  simulate_third_exp_calculations <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    experiments_df_to_use <- if (nrow(experiment_sets$experiments3()) == 0) NULL else experiment_sets$experiments3()
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiments_df_to_use)
  })
  
  simulate_fourth_exp_calculations <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    experiments_df_to_use <- if (nrow(experiment_sets$experiments4()) == 0) NULL else experiment_sets$experiments4()
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiments_df_to_use)
  }) 
  
  # v3.2 updated to be loop with exp tables
  
  
  #----------------------------------
  # 4. OUTPUT: TABLES - data frames
  #----------------------------------
  
  # v3 not much change from before v3c for results, and simulate_counter_exp_calculations, but
  # added the 3 results tables for the other experiments
  output$results_first_exp_df <- renderTable({req(simulate_first_exp_calculations()); 
    simulate_first_exp_calculations()}, rownames = FALSE) # v3
  output$results_counterfactual_df <- renderTable({ req(simulate_counter_exp_calculations()) ; 
    simulate_counter_exp_calculations() }, rownames = FALSE) # v3
  output$results_second_exp_df <- renderTable({ req(simulate_second_exp_calculations()); 
    simulate_second_exp_calculations() }, rownames = FALSE) # v3
  output$results_third_exp_df<- renderTable({ req(simulate_third_exp_calculations()); 
    simulate_third_exp_calculations() }, rownames = FALSE) # v3
  output$results_fourth_exp_df <- renderTable({ req(simulate_fourth_exp_calculations()); 
    simulate_fourth_exp_calculations() }, rownames = FALSE) # v3
  
  #---------------------------
  # 5. PLOTS # v3.3
  #---------------------------
  plot_theme <- theme_bw() + 
    theme(
      plot.title        = element_text(hjust = 0.5),
      axis.title        = element_text(size = 12),
      axis.text         = element_text(size = 10),
      panel.grid.major  = element_line(color = "grey80"),
      panel.grid.minor  = element_blank(),
      strip.background  = element_rect(fill = "grey90", color = "grey90")
    )
  
  # Extended make_plot to include optional 3rd,4th,5th data
  make_plot <- function(
    data_exp,      # "First Scenario" (the main one from Set 1)
    data_default_counter,   # "Counterfactual" (counterfactual)
    data_third = NULL,
    data_fourth = NULL,
    data_fifth = NULL,
    y_var, title, y_label,
    show_counter_visual = TRUE,
    show_second_exp_visual = FALSE,
    show_third_exp_visual = FALSE,
    show_fourth_exp_visual = FALSE
  ) {
    
    # Base plot with the main experiment data
    p <- ggplot(data_exp, aes(x = Period, y = .data[[y_var]])) +
      geom_line(aes(color = "First Scenario")) +
      geom_point(data = if(nrow(data_exp) > 10) { # v3.3.3 adding point limit
        data_exp[round(seq(1, nrow(data_exp), length.out = 10)), ]
      } else {
        data_exp
      }, aes(color = "First Scenario")) + # v3.3.3 end of adding point limit
      scale_color_manual(values = c("First Scenario" = "blue",
                                    "Counterfactual" = "red",
                                    "Second Scenario"  = "green",
                                    "Third Scenario" = "purple",
                                    "Fourth Scenario"  = "orange")) +
      ggtitle(title) + xlab("Period") + ylab(y_label) +
      plot_theme
    
    # Optionally add no-exp line
    if (show_counter_visual && !is.null(data_default_counter)) {
      p <- p +
        geom_line(data = data_default_counter, 
                  aes(x = Period, y = .data[[y_var]], color = "Counterfactual"), 
                  linetype = "dashed") +
        geom_point(data = if(nrow(data_default_counter) > 12) { # v3.3.3 adding point limit
          tmp <- data_default_counter[-1, ] # remove n rows
          tmp[round(seq(1, nrow(tmp), length.out = 12)), ]
        } else {
          data_default_counter[-1, ] # end v3.3.3 limit points
        }, aes(x = Period, y = .data[[y_var]], color = "Counterfactual"), 
        shape = 1, size = 2)
    }
    
    # Optionally add Second Scenario
    if (show_second_exp_visual && !is.null(data_third)) {
      p <- p +
        geom_line(data = data_third,
                  aes(x = Period, y = .data[[y_var]], color = "Second Scenario")) +
        geom_point(data = if(nrow(data_third) > 14) { # v3.3.3 adding point limit
          tmp <- data_third[-(1:3), ]
          tmp[round(seq(1, nrow(tmp), length.out = 14)), ]
        } else {
          data_third[-(1:3), ] # end v3.3.3 
        }, aes(x = Period, y = .data[[y_var]], color = "Second Scenario"), size = 1)
    }
    
    # Optionally add Third Scenario
    if (show_third_exp_visual && !is.null(data_fourth)) {
      p <- p +
        geom_line(data = data_fourth,
                  aes(x = Period, y = .data[[y_var]], color = "Third Scenario")) +
        geom_point(data = if(nrow(data_fourth) > 16) { # v3.3.3 adding point limit
          tmp <- data_fourth[-(1:5), ]
          tmp[round(seq(1, nrow(tmp), length.out = 16)), ]
        } else {
          data_fourth[-(1:5), ] # end v3.3.3 
        }, aes(x = Period, y = .data[[y_var]], color = "Third Scenario"), size = 1)
    }
    
    # Optionally add Fourth Scenario
    if (show_fourth_exp_visual && !is.null(data_fifth)) {
      p <- p +
        geom_line(data = data_fifth,
                  aes(x = Period, y = .data[[y_var]], color = "Fourth Scenario")) +
        geom_point(data = if(nrow(data_fifth) > 18) { # v3.3.3 adding point limit
          tmp <- data_fifth[-(1:7), ]
          tmp[round(seq(1, nrow(tmp), length.out = 18)), ]
        } else {
          data_fifth[-(1:7), ] # end v3.3.3 
        }, aes(x = Period, y = .data[[y_var]], color = "Fourth Scenario"), size = 1)
    }
    
    p
  }
  
  # Store plots for download
  plot_objects <- reactiveValues()
  
  output$plot_K <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "K",
      title         = "Capital (K) Over Time",
      y_label       = "Capital (K)",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_K <- p
    p
  }, res = 100)
  
  output$plot_Y <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "Y",
      title         = "Output (Y) Over Time",
      y_label       = "Output (Y)",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_Y <- p
    p
  }, res = 100)
  
  output$plot_little_k <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "little_k",
      title         = "Capital Efficiency Units",
      y_label       = "k (Capital Efficiency Units)",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_little_k <- p
    p
  }, res = 100)
  
  output$plot_percent_delta_k <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "percent_delta_k",
      title         = "Percent Change in Capital Over Time",
      y_label       = "Δk/k (Percent)",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_percent_delta_k <- p
    p
  }, res = 100)
  
  output$plot_MPK <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "MPK",
      title         = "Interest Rate Return on Capital", # r = MPK # v3.3.1
      y_label       = "r",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_MPK <- p
    p
  }, res = 100)
  
  output$plot_MPL <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "MPL",
      title         = "Wage Rate",
      y_label       = "w",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_MPL <- p
    p
  }, res = 100)
  
  output$plot_log_L <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "log_L",
      title         = "Log of Labor (L) Over Time",
      y_label       = "Log(L)",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_log_L <- p
    p
  }, res = 100)
  
  output$plot_log_K <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "log_K",
      title         = "Log of Capital (K) Over Time",
      y_label       = "Log(K)",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_log_K <- p
    p
  }, res = 100)
  
  output$plot_log_Y <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "log_Y",
      title         = "Log of Output (Y) Over Time",
      y_label       = "Log(Y)",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_log_Y <- p
    p
  }, res = 100)
  
  output$plot_log_A <- renderPlot({
    req(simulate_first_exp_calculations(), simulate_counter_exp_calculations(), simulate_second_exp_calculations(), simulate_third_exp_calculations(), simulate_fourth_exp_calculations())
    p <- make_plot(
      data_exp      = simulate_first_exp_calculations(),
      data_default_counter   = simulate_counter_exp_calculations(),
      data_third    = simulate_second_exp_calculations(),
      data_fourth   = simulate_third_exp_calculations(),
      data_fifth    = simulate_fourth_exp_calculations(),
      y_var         = "log_A",
      title         = "Log of TFP (A) Over Time",
      y_label       = "Log(A)",
      show_counter_visual   = input$show_counter_visual,
      show_second_exp_visual = input$show_second_exp_visual,
      show_third_exp_visual = input$show_third_exp_visual,
      show_fourth_exp_visual  = input$show_fourth_exp_visual
    )
    plot_objects$plot_log_A <- p
    p
  }, res = 100) # v3.3: this whole plot code is new with v3.3
  
  
  #----------------------------------
  # DOWNLOAD HANDLERS
  #----------------------------------
  output$downloadData <- downloadHandler( # version1
    filename = function() {
      paste0("results_", Sys.Date(), ".csv")
    },
    content = function(file) {req(simulate_first_exp_calculations()) # v2.1
      write.csv(simulate_first_exp_calculations(), file, row.names = FALSE)
    }
  )
  
  output$downloadPlots <- downloadHandler( # version1
    filename = function() { 
      paste0("plots_", Sys.Date(), ".zip")
    },
    content = function(file) {
      temp_dir <- tempdir() # temp file storage but new shiny update change the way file downloads happen so this might not be needed now
      file_paths <- c()
      
      # Use the stored plot objects version2
      plots <- reactiveValuesToList(plot_objects) # Convert reactiveValues to list
      plots <- Filter(Negate(is.null), plots) # Remove NULL entries
      
      for (plot_name in names(plots)) { # Save each plot to a PNG version1
        plot_file <- file.path(temp_dir, paste0(plot_name, ".png"))
        ggsave(plot_file, plots[[plot_name]], device = "png")
        file_paths <- c(file_paths, plot_file)
      }
      zipr(zipfile = file, files = file_paths) # zip em. v1
    }
  )
}

shinyApp(ui = ui, server = server)

# v3.3.3.1

# reverted back to version 3.3.3 and put all df in one tabpanel 
# reverted back due to complications in calculations for the param_mods

# I basically just need to mirror my exp table code
# The main difference is this mods_df will have a function/def/helper function that allows it to be called during the calculations.
# similar to if i == 1 then return 0 or inital etc. this one will be
# if param_mods has value for said calculation and current period then return the param_mod value.
# this one can probably be before the i == 0 since this mods sometimes change period 0
# this code needs to be independent so it can be removed without affecting the model. (ideally)
# I made some good code for this 3/7/2025 with ai help but it was wrong so better to start from scracht

# my next model will be #v3.4
#v3.3.3.1
```

# spacer


```{r}

library(shiny)
library(ggplot2)
library(DT)    # for interactive table
library(zip)   # to create ZIP files in download handler
library(bslib)
library(rio)   # to read the Excel file # v2.2

source("modules/simulation_calc.R") # module for simulate_solow # v3.4

#--- Helper function to create each experiment set. ---
initializeExperimentSet <- function(
    expSuffix,         # label like "1", "2", "3", or "4"
    paramNameInput,    # e.g. "param_name", "param_name2"
    newValueInput,     # e.g. "value", "value2"
    startPeriodInput,  # e.g. "start_period", "start_period2"
    lengthInput,       # e.g. "length", "length2"
    addExpButton,      # e.g. "add_experiment", "add_experiment2"
    dtOutput,          # e.g. "experimentsTable", "experimentsTable2"
    deleteRowInput,    # internal ID prefix for deletion, e.g. "delete_1", "delete_2"
    input, output, session
) {
  
  # A reactiveVal to hold the table of experiments for this set
  rv <- reactiveVal(
    data.frame(
      param        = character(0),
      value    = numeric(0),
      start_period = integer(0),
      length       = integer(0),
      stringsAsFactors = FALSE
    )
  )
  
  # Add new experiment row when the user clicks
  observeEvent(input[[addExpButton]], {
    new_experiment <- data.frame(
      param        = input[[paramNameInput]],
      value    = input[[newValueInput]],
      start_period = input[[startPeriodInput]],
      length       = input[[lengthInput]],
      stringsAsFactors = FALSE
    )
    rv( rbind(rv(), new_experiment) )
  })
  
  # Render the experiments table with "Delete" buttons
  output[[dtOutput]] <- renderDT({
    exps <- rv()
    if (nrow(exps) == 0) return(NULL)
    
    deleteButtons <- sapply(seq_len(nrow(exps)), function(i) {
      as.character(
        actionButton(
          inputId = paste0("delete_", expSuffix, "_", i),
          label = "Delete",
          class = "btn btn-danger btn-sm",
          onclick = paste0(
            'Shiny.setInputValue("delete_', expSuffix, '", this.id, {priority: "event"})'
          )
        )
      )
    })
    
    exps$Delete <- deleteButtons
    
    datatable(
      exps,
      escape = FALSE,
      selection = "none",
      options   = list(pageLength = 5)
    )
  }, server = FALSE)
  
  # Handle row deletions
  observeEvent(input[[paste0("delete_", expSuffix)]], {
    row_str <- gsub(paste0("delete_", expSuffix, "_"), "", input[[paste0("delete_", expSuffix)]])
    row_num <- as.numeric(row_str)
    
    exps <- rv()
    if (!is.na(row_num) && row_num >= 1 && row_num <= nrow(exps)) {
      exps <- exps[-row_num, ]
      rv(exps)
    }
  })
  
  return(rv)
}

############
# v4.1 helper function for endo table
#
#################


initializeEndoSet <- function(
    endoSuffix,         # label like "1", "2", "3", ...
    edParamNameInput, # e.g. "endo_param_name1"
    newedValueInput,     # e.g. "endo_value1"
    StartperiodedInput,     # e.g. "endo_start_period1"
    LengthInputed,    # e.g. "endo_length1"
    addEndoButton,      # e.g. "add_endo_mod1"
    dtOutputId,         # e.g. "endoTable1"
    deletePrefix,       # e.g. "delete_endo_"
    input, output, session
) {
  # A separate reactiveVal specifically for the 'endo' table
  rvEndo <- reactiveVal(
    data.frame(
      param        = character(0),
      value        = numeric(0),
      start_period = integer(0),
      length       = integer(0),
      stringsAsFactors = FALSE
    )
  )
  
  # Observe: Add row when user clicks 'Add' for this set
  observeEvent(input[[addEndoButton]], {
    new_endo <- data.frame(
      param        = input[[edParamNameInput]],
      value        = input[[newedValueInput]],
      start_period = input[[StartperiodedInput]],
      length       = 1, # v4.2 # defaulting to 1 for now. 
      # this is old code for lenght: input[[LengthInputed]]
      stringsAsFactors = FALSE
    )
    rvEndo( rbind(rvEndo(), new_endo) )
  })
  
  # Render the table with "Delete" buttons
  output[[dtOutputId]] <- renderDT({
    endos <- rvEndo()
    if (nrow(endos) == 0) return(NULL)
    
    # Create a delete button for each row
    deleteButtons <- sapply(seq_len(nrow(endos)), function(i) {
      as.character(
        actionButton(
          inputId = paste0("deleteendo_", endoSuffix, "_", i),
          label   = "Delete",
          class   = "btn btn-danger btn-sm",
          onclick = paste0(
            # The JS will set the input with the row to delete
            'Shiny.setInputValue("deleteendo_', endoSuffix, '", this.id, {priority: "event"})'
          )
        )
      )
    })
    endos$Delete <- deleteButtons
    
    datatable(
      endos,
      escape    = FALSE,
      selection = "none",
      options   = list(pageLength = 5)
    )
  }, server = FALSE)
  
  # Observe: Delete rows
  observeEvent(input[[paste0("deleteendo_", endoSuffix)]], {
    row_str <- gsub(paste0("deleteendo_", endoSuffix, "_"), "", input[[paste0("deleteendo_", endoSuffix)]])
    row_num <- as.numeric(row_str)
    
    endos <- rvEndo()
    if (!is.na(row_num) && row_num >= 1 && row_num <= nrow(endos)) {
      endos <- endos[-row_num, ]
      rvEndo(endos)
    }
  })
  
  return(rvEndo)
} # v4.1 end of helper function for endo table




#--------------------------------------------------------
#     UI
#--------------------------------------------------------
# app layout and input controls version1
ui <- page_sidebar( # version
  title = "Solow-Romer Quantitative Simulation",
  sidebar = sidebar( # all the input controls
    width = 600, # edit sidebar width. This is not friendly with smaller screens. I was having trouble with the sidebar overlapping with tabs so I added this to default a sidebar lenght.
    h4("Simulation Parameters"),
    sliderInput("Simulation_Period", "Simulation Period (yrs)", 
                min = 20, max = 150, value = 50, step = 1),
    sliderInput("s", "Savings Rate (s)", min = 0.001, max = 1, value = 0.2, step = 0.01), # v2.3 change to min .001 due to div by zero error
    sliderInput("delta", "Depreciation Rate (delta)", min = 0, max = .5, value = 0.15, step = 0.01),
    sliderInput("n", "Population Growth Rate (n)", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("z", "Productivity Parameter (z)", min = 0, max = 0.1, value = 0.02, step = 0.001),
    sliderInput("l", "Research Share (l)", min = 0, max = 0.99, value = 0.1, step = 0.01), 
    selectInput("A", "Initial TFP", choices = c(1, 100, 1000), selected = 1), # 343
    selectInput("L", "Initial Population (L)", choices = c(1, 100, 1000), selected = 1), # 343
    
    h4("Quantitative Experiments"),
    
    # -- ADD TABSETPANEL HERE -- # v3.3.1
    do.call(tabsetPanel, c(id = "experiment_tabs",
                           lapply(1:4, function(i) {
                             tabPanel(
                               paste0("Exps. Set ", i),
                               selectInput(paste0("param_name", i), paste0("Exogenous Variables (s, delta, n, z, l) Set ", i),
                                           choices = c("s", "delta", "n", "z", "l"),
                                           selected = "s"),
                               numericInput(paste0("value", i), paste0("New Value Set ", i), value = 0, step = 0.01),
                               numericInput(paste0("start_period", i), paste0("Start Period Set ", i), value = 10, step = 1),
                               numericInput(paste0("length", i), paste0("Length of Effect Set ", i), value = 200, step = 1),
                               actionButton(paste0("add_experiment", i), paste0("Add Exp ", i)),
                               fileInput(paste0("upload_file_", i), paste0("Upload Excel for Exp ", i), accept = c(".xlsx", ".xls")),
                               div(style = "width: 400px;", DTOutput(paste0("experimentsTable", i)))
                             )
                           })
    )),
    # -- END TABSETPANEL -- # v3.3.1
    
    
    h4("Endogenous modifications"), # v4.1
    # Endo Table Sets Panel in Sidebar
    do.call(tabsetPanel, c(id = "endo_tabs",
                           lapply(1:4, function(i) {
                             tabPanel(
                               paste0("Endo Set ", i),
                               selectInput(paste0("endo_param_name", i), paste0(" Variables: little_k, A, L, K, Y) Set ", i), 
                                           choices = c("A", "L", "Y", "K", "little_k"), 
                                           selected = "little_k"),
                               numericInput(paste0("endo_value", i),  paste0("New Value ", i), value = 0, step = 0.1),
                               numericInput(paste0("endo_start_period", i), paste0("Modification Period ", i), value = 10, step = 1),
                               #numericInput(paste0("endo_length", i), paste0("Length of Effect ", i), value = 1,  step = 1), # v4.2 remove since it is not use yet. endo mods are only applied for one period for now
                               actionButton(paste0("add_endomod", i), paste0("Add Endo ", i)),
                               fileInput(paste0("endo_upload_file_", i), paste0("Upload Excel for Endo ", i), accept = c(".xlsx", ".xls")),
                               div(style = "width: 400px;", DTOutput(paste0("endoTable", i)))  
                             )
                           })
    )), # end of v4.1
    
    checkboxInput("show_counter_visual",    "Show Counterfactual",       value = TRUE),
    checkboxInput("show_second_exp_visual", "Show Second Experiment",     value = FALSE), # v3.3
    checkboxInput("show_third_exp_visual","Show Third Experiment",    value = FALSE), # v3.3
    checkboxInput("show_fourth_exp_visual", "Show Fourth Experiment",     value = FALSE), # v3.3
    
    actionButton("simulate", "Simulate"),
    h4("Download Results"),
    downloadButton("downloadPlots", "Download All Plots as PNG (ZIP)"),
    downloadButton("downloadData", "Download Data as CSV")
  ),
  mainPanel( # tab controls. v1
    tabsetPanel(
      tabPanel("Plots",
               div(style = "width: 1800px; margin: auto;",
                   fluidRow(
                     column(6, plotOutput("plot_K", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_Y", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_little_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_percent_delta_k", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_MPK", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_MPL", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Ratio scale",
               div(style = "width: 1800px; margin: auto;",
                   fluidRow(
                     column(6, plotOutput("plot_log_L", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_K", width = "900px", height = "600px"))
                   ),
                   fluidRow(
                     column(6, plotOutput("plot_log_Y", width = "900px", height = "600px")),
                     column(6, plotOutput("plot_log_A", width = "900px", height = "600px"))
                   )
               )
      ),
      tabPanel("Program Results", # v3.3.5
               tabsetPanel(
                 tabPanel("First Scenario", tableOutput("results_first_exp_df")),
                 tabPanel("Counterfactual", tableOutput("results_counterfactual_df")),
                 tabPanel("Second Scenario", tableOutput("results_second_exp_df")),
                 tabPanel("Third Scenario", tableOutput("results_third_exp_df")),
                 tabPanel("Fourth Scenario", tableOutput("results_fourth_exp_df"))
               )
      ), # v3.3.5  # v3
      tabPanel("World", # v 2.2
               # adding option to get average savings rate
               selectInput("selectedSheet", "Select Region", choices = NULL),
               selectInput("selectedColumn", "Select Country", choices = NULL),
               numericInput("startYear", "Start Year", value = 1960),
               numericInput("endYear",   "End Year",   value = 2023),
               actionButton("calculateAvg", "Get Avg Savings Rate 's'"),
               verbatimTextOutput("avgSavingsRate")  # displays the avg s calculated
      )
    )
  )
)

#--------------------------------------------------------
#     SERVER # version1
#--------------------------------------------------------
server <- function(input, output, session) {
  
  # adding option for Savings rate average for list of countries. 
  excel_list <- import_list("data/savings_rate_y.xlsx") # v2.2
  
  # Populate region choices
  observe({  # v2.2
    updateSelectInput(session, "selectedSheet", choices = names(excel_list), selected = names(excel_list)[1])
  })
  observeEvent(input$selectedSheet, {  # Update column choices  # v2.2
    df <- excel_list[[input$selectedSheet]]
    updateSelectInput(session, "selectedColumn", choices = setdiff(names(df), "year"), selected = setdiff(names(df), "year")[1])
  })
  
  # find the available years
  observeEvent(input$selectedColumn, { # v2.2
    df <- excel_list[[input$selectedSheet]]
    yearVals <- df$year
    yVals <- as.numeric(df[[input$selectedColumn]])
    valid <- !is.na(yearVals) & !is.na(yVals)
    if (!any(valid)) return()
    validYears <- yearVals[valid]
    minY <- min(validYears)
    maxY <- max(validYears)
    updateNumericInput(session, "startYear", min = minY, max = maxY, value = minY)
    updateNumericInput(session, "endYear",   min = minY, max = maxY, value = maxY)
  })
  
  # Calculate average within the chosen year range
  observeEvent(input$calculateAvg, {
    df <- excel_list[[input$selectedSheet]]
    yearVals <- df$year
    yVals <- as.numeric(df[[input$selectedColumn]])
    valid <- !is.na(yearVals) & !is.na(yVals)
    dfValid <- df[valid, ]
    
    subsetData <- dfValid[dfValid$year >= input$startYear & dfValid$year <= input$endYear, ]
    if (nrow(subsetData) == 0) {  # Check if country has any data
      output$avgSavingsRate <- renderPrint("Country Data Not Available") 
      return()
    }
    
    avgVal <- (mean(subsetData[[input$selectedColumn]]))/100
    updateSliderInput(session, "s", value = avgVal)
    output$avgSavingsRate <- renderPrint(paste("Average Savings Rate:", avgVal)) # Display the average
  }) # v2.2
  
  #----------------------------------
  # EXPERIMENTS TABLE MANAGEMENT # v3 
  #----------------------------------
  # This code along w/ the initializeExperiment function help loop in experiment simulations. 
  experiment_sets <- lapply(1:4, function(i) { # v3.2 looping exp tables
    initializeExperimentSet(
      expSuffix        = as.character(i),
      paramNameInput   = paste0("param_name", i),
      newValueInput    = paste0("value", i),
      startPeriodInput = paste0("start_period", i),
      lengthInput      = paste0("length", i),
      addExpButton     = paste0("add_experiment", i),
      dtOutput         = paste0("experimentsTable", i),
      deleteRowInput   = paste0("delete_", i),
      input = input, output = output, session = session
    )
  })
  names(experiment_sets) <- paste0("experiments", 1:4)  # v3.2 looping exp tables
  
  
  # v3.1: adding excel upload for faster param inputs
  # v3.2: loop this to match expe loop code
  for (i in 1:4) {
    local({
      set_index <- i
      observeEvent(input[[paste0("upload_file_", set_index)]], {
        req(input[[paste0("upload_file_", set_index)]])
        df_uploaded <- import(input[[paste0("upload_file_", set_index)]]$datapath)
        
        # Validate columns
        required_cols <- c("param", "value", "start_period", "length")
        if (!all(required_cols %in% names(df_uploaded))) {
          showModal(modalDialog(
            title = "Error",
            "The uploaded file must contain columns: param, value, start_period, length.",
            easyClose = TRUE
          ))
          return(NULL)
        }
        
        # Append
        current_data <- experiment_sets[[paste0("experiments", set_index)]]()
        updated_data <- rbind(current_data, df_uploaded)
        experiment_sets[[paste0("experiments", set_index)]](updated_data)
      }) # v3.1 and v3.2 end
    })
  }
  
  #########3
  # v4.1 
  #nmaking endo server function
  ############
  
  endo_sets <- lapply(1:4, function(i) {
    initializeEndoSet(
      endoSuffix         = as.character(i), # e.g. "1", "2", etc.
      edParamNameInput = paste0("endo_param_name", i),
      newedValueInput     = paste0("endo_value", i),
      StartperiodedInput     = paste0("endo_start_period", i),
      LengthInputed    = paste0("endo_length", i),
      addEndoButton      = paste0("add_endomod", i),
      dtOutputId         = paste0("endoTable", i),  # Unique output ID
      deletePrefix       = paste0("delete_endo_", i), # So it won't conflict
      input  = input, output = output, session = session
    )
  })
  
  # Give the list a logical name
  names(endo_sets) <- paste0("endo_", 1:4) # enf of server for endo #v4.1
  
  for (i in 1:4) { # v4.1 adding excel upload
    local({
      endo_index <- i
      observeEvent(input[[paste0("endo_upload_file_", endo_index)]], {
        req(input[[paste0("endo_upload_file_", endo_index)]])
        df_endo_uploaded <- import(input[[paste0("endo_upload_file_", endo_index)]]$datapath)
        
        # Validate columns
        endo_required_cols <- c("param", "value", "start_period", "length")
        if (!all(endo_required_cols %in% names(df_endo_uploaded))) {
          showModal(modalDialog(
            title = "Error",
            "The uploaded file must contain columns: param, value, start_period, length.",
            easyClose = TRUE
          ))
          return(NULL)
        }
        
        # Append
        current_endo_data <- endo_sets[[paste0("endo_", endo_index)]]()
        updated_endo_data <- rbind(current_endo_data, df_endo_uploaded)
        endo_sets[[paste0("endo_", endo_index)]](updated_endo_data)
      }) # v4.1 end
    })
  }
  
  
  #----------------------------------
  # EVENT-REACTIVE RESULTS
  #----------------------------------
  # v3.2 edit to loop with lapply exp tables
  
  simulate_first_exp_calculations <- eventReactive(input$simulate, { # v2.1
    # If first set is empty, show a modal (original logic)
    if (nrow(experiment_sets$experiments1()) == 0) {
      showModal(modalDialog(
        title = "Error",
        "Please add at least one experiment in Set 1 before running the simulation.",
        easyClose = TRUE,
        footer = NULL
      ))
      return(NULL)
    }
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    
    # v3: streamline this section of the simulate_solow.
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiment_sets$experiments1(), endomods_df = endo_sets$endo_1()) # v4.1
  })
  
  simulate_counter_exp_calculations <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = NULL) # v3
  })
  
  # v3: adding the 3 extra experiment simulations
  simulate_second_exp_calculations <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    experiments_df_to_use <- if (nrow(experiment_sets$experiments2()) == 0) NULL else experiment_sets$experiments2()
    endo_df_to_use <- if (nrow(endo_sets$endo_2()) == 0) NULL else endo_sets$endo_2()  # v4.1
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiments_df_to_use, endomods_df = endo_df_to_use)  # v4.1
  })
  
  simulate_third_exp_calculations <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    experiments_df_to_use <- if (nrow(experiment_sets$experiments3()) == 0) NULL else experiment_sets$experiments3()
    endo_df_to_use <- if (nrow(endo_sets$endo_3()) == 0) NULL else endo_sets$endo_3() # v4.1
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiments_df_to_use, endomods_df = endo_df_to_use) # v4.1
  })
  
  simulate_fourth_exp_calculations <- eventReactive(input$simulate, {
    num_periods <- input$Simulation_Period + 1
    A_init <- as.numeric(input$A)
    L_init <- as.numeric(input$L)
    experiments_df_to_use <- if (nrow(experiment_sets$experiments4()) == 0) NULL else experiment_sets$experiments4()
    endo_df_to_use <- if (nrow(endo_sets$endo_4()) == 0) NULL else endo_sets$endo_4() # v4.1
    simulate_solow(num_periods, input$s, input$delta, input$n, input$z, input$l,
                   A_init, L_init, experiments_df = experiments_df_to_use, endomods_df = endo_df_to_use) # v4.1
  }) 
  
  # v3.2 updated to be loop with exp tables
  
  
  #----------------------------------
  # 4. OUTPUT: TABLES - data frames
  #----------------------------------
  
  # v3 not much change from before v3c for results, and simulate_counter_exp_calculations, but
  # added the 3 results tables for the other experiments
  output$results_first_exp_df <- renderTable({req(simulate_first_exp_calculations()); 
    simulate_first_exp_calculations()}, rownames = FALSE) # v3
  output$results_counterfactual_df <- renderTable({ req(simulate_counter_exp_calculations()) ; 
    simulate_counter_exp_calculations() }, rownames = FALSE) # v3
  output$results_second_exp_df <- renderTable({ req(simulate_second_exp_calculations()); 
    simulate_second_exp_calculations() }, rownames = FALSE) # v3
  output$results_third_exp_df<- renderTable({ req(simulate_third_exp_calculations()); 
    simulate_third_exp_calculations() }, rownames = FALSE) # v3
  output$results_fourth_exp_df <- renderTable({ req(simulate_fourth_exp_calculations()); 
    simulate_fourth_exp_calculations() }, rownames = FALSE) # v3
  
  #---------------------------
  # 5. PLOTS # v3.3
  #---------------------------
  plot_theme <- theme_bw() + 
    theme(
      plot.title        = element_text(hjust = 0.5),
      axis.title        = element_text(size = 12),
      axis.text         = element_text(size = 10),
      panel.grid.major  = element_line(color = "grey80"),
      panel.grid.minor  = element_blank(),
      strip.background  = element_rect(fill = "grey90", color = "grey90"),
      legend.position = "top",# v4.3
      legend.title = element_blank() # v4.3
    )
  
  # Extended make_plot to include optional 3rd,4th,5th data
  make_plot <- function(
    show_plot_placeholder_first,
    show_plot_placeholder_counter,
    show_plot_placeholder_second = NULL,
    show_plot_placeholder_third = NULL,
    show_plot_placeholder_fourth = NULL,
    y_var, title, y_label,
    show_counter_visual = TRUE,
    show_second_exp_visual = FALSE,
    show_third_exp_visual = FALSE,
    show_fourth_exp_visual = FALSE
  ) {
    
    # Base plot with the main experiment data
    p <- ggplot(show_plot_placeholder_first, aes(x = Period, y = .data[[y_var]])) +
      geom_line(aes(color = "First Scenario")) +
      geom_point(data = if(nrow(show_plot_placeholder_first) > 10) { # v3.3.3 adding point limit
        show_plot_placeholder_first[round(seq(1, nrow(show_plot_placeholder_first), length.out = 10)), ]
      } else {
        show_plot_placeholder_first
      }, aes(color = "First Scenario")) + # v3.3.3 end of adding point limit
      scale_color_manual(values = c("First Scenario" = "blue",
                                    "Counterfactual" = "red",
                                    "Second Scenario"  = "green",
                                    "Third Scenario" = "purple",
                                    "Fourth Scenario"  = "orange")) +
      ggtitle(title) + xlab("Period") + ylab(y_label) +
      plot_theme
    
    # Optionally add no-exp line
    if (show_counter_visual && !is.null(show_plot_placeholder_counter)) {
      p <- p +
        geom_line(data = show_plot_placeholder_counter, 
                  aes(x = Period, y = .data[[y_var]], color = "Counterfactual"), 
                  linetype = "dashed") +
        geom_point(data = if(nrow(show_plot_placeholder_counter) > 12) { # v3.3.3 adding point limit
          tmp <- show_plot_placeholder_counter[-1, ] # remove n rows
          tmp[round(seq(1, nrow(tmp), length.out = 12)), ]
        } else {
          show_plot_placeholder_counter[-1, ] # end v3.3.3 limit points
        }, aes(x = Period, y = .data[[y_var]], color = "Counterfactual"), 
        shape = 1, size = 2)
    }
    
    # Optionally add Second Scenario
    if (show_second_exp_visual && !is.null(show_plot_placeholder_second)) {
      p <- p +
        geom_line(data = show_plot_placeholder_second,
                  aes(x = Period, y = .data[[y_var]], color = "Second Scenario")) +
        geom_point(data = if(nrow(show_plot_placeholder_second) > 14) { # v3.3.3 adding point limit
          tmp <- show_plot_placeholder_second[-(1:3), ]
          tmp[round(seq(1, nrow(tmp), length.out = 14)), ]
        } else {
          show_plot_placeholder_second[-(1:3), ] # end v3.3.3 
        }, aes(x = Period, y = .data[[y_var]], color = "Second Scenario"), size = 1)
    }
    
    # Optionally add Third Scenario
    if (show_third_exp_visual && !is.null(show_plot_placeholder_third)) {
      p <- p +
        geom_line(data = show_plot_placeholder_third,
                  aes(x = Period, y = .data[[y_var]], color = "Third Scenario")) +
        geom_point(data = if(nrow(show_plot_placeholder_third) > 16) { # v3.3.3 adding point limit
          tmp <- show_plot_placeholder_third[-(1:5), ]
          tmp[round(seq(1, nrow(tmp), length.out = 16)), ]
        } else {
          show_plot_placeholder_third[-(1:5), ] # end v3.3.3 
        }, aes(x = Period, y = .data[[y_var]], color = "Third Scenario"), size = 1)
    }
    
    # Optionally add Fourth Scenario
    if (show_fourth_exp_visual && !is.null(show_plot_placeholder_fourth)) {
      p <- p +
        geom_line(data = show_plot_placeholder_fourth,
                  aes(x = Period, y = .data[[y_var]], color = "Fourth Scenario")) +
        geom_point(data = if(nrow(show_plot_placeholder_fourth) > 18) { # v3.3.3 adding point limit
          tmp <- show_plot_placeholder_fourth[-(1:7), ]
          tmp[round(seq(1, nrow(tmp), length.out = 18)), ]
        } else {
          show_plot_placeholder_fourth[-(1:7), ] # end v3.3.3 
        }, aes(x = Period, y = .data[[y_var]], color = "Fourth Scenario"), size = 1)
    }
    
    p
  }
  
  # Store plots for download
  plot_objects <- reactiveValues()
  
  # v4 make plot list to loop render plot code
  plot_specs <- list(
    list(outputId = "plot_K", y_var = "K", 
         title = "Capital (K) Over Time", y_label = "Capital (K)"),
    
    list(outputId = "plot_Y", y_var = "Y", 
         title = "Output (Y) Over Time", y_label = "Output (Y)"),
    
    list(outputId = "plot_little_k", y_var = "little_k", 
         title = "Capital Efficiency Units", y_label = "k (Capital Efficiency Units)"),
    
    list(outputId = "plot_percent_delta_k", y_var = "percent_delta_k", 
         title = "Percent Change in Capital Over Time", y_label = "Δk/k (Percent)"),
    
    list(outputId = "plot_MPK", y_var = "MPK", 
         title = "Interest Rate Return on Capital", y_label = "r"),
    
    list(outputId = "plot_MPL", y_var = "MPL",
         title = "Wage Rate", y_label = "w"),
    
    list(outputId = "plot_log_L",  y_var = "log_L", 
         title = "Log of Labor (L) Over Time", y_label = "Log(L)"),
    
    list(outputId = "plot_log_K", y_var = "log_K",
         title = "Log of Capital (K) Over Time", y_label = "Log(K)"),
    
    list(outputId = "plot_log_Y", y_var = "log_Y",
         title = "Log of Output (Y) Over Time", y_label = "Log(Y)"),
    
    list(outputId = "plot_log_A", y_var = "log_A",
         title = "Log of TFP (A) Over Time", y_label = "Log(A)")
  ) # v4 end of list code for looping renderplot code
  
  
  # v4 loop plot outputs, storing them in the plot_objects reactiveValues
  # I need to switch this code to pull data from the results_..._exp_df instead of running simulate_...._exp_calculations. must fix ASAP. 
  for (spec in plot_specs) {
    
    local({
      plot_id   <- spec$outputId
      var_name  <- spec$y_var
      ttl       <- spec$title
      y_lab     <- spec$y_label
      
      output[[plot_id]] <- renderPlot({
        req(simulate_first_exp_calculations(),
            simulate_counter_exp_calculations(),
            simulate_second_exp_calculations(),
            simulate_third_exp_calculations(),
            simulate_fourth_exp_calculations())
        
        p <- make_plot(
          show_plot_placeholder_first      = simulate_first_exp_calculations(),
          show_plot_placeholder_counter    = simulate_counter_exp_calculations(),
          show_plot_placeholder_second     = simulate_second_exp_calculations(),
          show_plot_placeholder_third      = simulate_third_exp_calculations(),
          show_plot_placeholder_fourth     = simulate_fourth_exp_calculations(),
          
          y_var   = var_name, title   = ttl, y_label = y_lab,
          
          show_counter_visual      = input$show_counter_visual,
          show_second_exp_visual   = input$show_second_exp_visual,
          show_third_exp_visual    = input$show_third_exp_visual,
          show_fourth_exp_visual   = input$show_fourth_exp_visual
        )
        # store in plot_objects for zip download
        plot_objects[[plot_id]] <- p
        p
      }, res = 100)
    })
  } # v4 end of loop plot outoputs
  
  #----------------------------------
  # DOWNLOAD HANDLERS
  #----------------------------------
  output$downloadData <- downloadHandler( # version1
    filename = function() {
      paste0("results_", Sys.Date(), ".csv")
    },
    content = function(file) {req(simulate_first_exp_calculations()) # v2.1
      write.csv(simulate_first_exp_calculations(), file, row.names = FALSE)
    }
  )
  
  output$downloadPlots <- downloadHandler(
    filename = function() { paste0("plots_", Sys.Date(), ".zip") },
    content  = function(file) {
      # Grab all the plots out of the reactiveValues # v4
      all_plots <- reactiveValuesToList(plot_objects) # v4 for new loop plot code
      
      # save them as .png # v4
      tmp_dir   <- tempdir()
      file_paths <- c()
      for (nm in names(all_plots)) { # v4 adjusting to fit loop plot code
        # nm is e.g. "plot_K", "plot_Y", ...
        plot_file <- file.path(tmp_dir, paste0(nm, ".png"))
        ggsave(plot_file, all_plots[[nm]], device = "png")
        file_paths <- c(file_paths, plot_file)
      }
      zip::zipr(zipfile = file, files = file_paths) # v4 
    }
  )
}

shinyApp(ui = ui, server = server)

# v4.3
# added calculations for investment, consumption and depreciaon in the simulate_solow file
# nothnig here should have change besides maybe some names to finish v4.2 or comments

```

